import { CandleData } from './candle-reconstruction-engine';
import { EfficientHMACalculator, EfficientHMAResult } from './efficient-hma-calculator';
import { ehlersProcessor, EhlersSignals } from './ehlers-signal-processing';

export type TrendDirection = 'bullish' | 'bearish' | 'neutral';
export type TrendStrength = 'strong' | 'moderate' | 'weak';

export interface TrendAnalysis {
    symbol: string;
    direction: TrendDirection;
    strength: TrendStrength;
    confidence: number; // 0-100
    hma5: number | null;
    hma40?: number | null;
    hma200: number | null;
    hma5Slope: number | null;
    hma40Slope?: number | null;
    hma200Slope: number | null;
    hma5Color?: 'green' | 'red' | 'neutral';
    hma200Color?: 'green' | 'red' | 'neutral';
    colorAlignment?: boolean;
    crossover?: number;
    longTermTrend: TrendDirection;
    longTermTrendStrength?: number;
    price: number | null;
    lastUpdate: Date;
    recommendation: 'BUY' | 'SELL' | 'HOLD';
    score: number;
    
    // Enhanced fields
    trendHierarchy?: {
        shortTerm: TrendDirection;
        mediumTerm: TrendDirection;
        longTerm: TrendDirection;
        alignment: number; // 0-100, how well timeframes align
    };
    marketStructure?: 'uptrend' | 'downtrend' | 'sideways';
    trendConfirmation?: boolean;
    signalQuality?: 'excellent' | 'good' | 'fair' | 'poor';
    
    ehlers?: EhlersSignals;
    ehlersRecommendation?: {
        action: 'BUY' | 'SELL' | 'HOLD';
        confidence: number;
        reason: string;
        anticipatory: boolean;
    };
    cycleTrading?: {
        suitable: boolean;
        reason: string;
    };
}

export interface MarketScanResult {
    symbol: string;
    displayName: string;
    trend: TrendAnalysis;
    rank: number;
    isRecommended: boolean;
}

export class TrendAnalysisEngine {
    private hmaCalculator: EfficientHMACalculator;
    private trendData: Map<string, TrendAnalysis> = new Map();
    private priceHistory: Map<string, Array<{price: number, timestamp: Date}>> = new Map();
    private updateTimer: NodeJS.Timeout;

    constructor(hmaCalculator: EfficientHMACalculator) {
        this.hmaCalculator = hmaCalculator;
        
        this.updateTimer = setInterval(() => this.updateAllTrends(), 30 * 1000);
    }

    addCandleData(candle: CandleData): void {
        const { symbol, close, timestamp } = candle;

        // Store price history for market structure analysis
        this.storePriceHistory(symbol, close, new Date(timestamp));

        const hmaPeriods = [5, 6, 7, 10, 14, 15, 21, 30, 35, 42, 70, 105];
        this.hmaCalculator.addCandleData(candle, hmaPeriods);
        
        const ehlersSignals = ehlersProcessor.processPrice(symbol, close, timestamp);
        
        const allPeriodsReady = hmaPeriods.every(period => 
            this.hmaCalculator.isReady(symbol, period)
        );
        
        if (allPeriodsReady) {
            this.updateTrendAnalysis(symbol, close, ehlersSignals);
        }
    }

    private storePriceHistory(symbol: string, price: number, timestamp: Date): void {
        if (!this.priceHistory.has(symbol)) {
            this.priceHistory.set(symbol, []);
        }
        
        const history = this.priceHistory.get(symbol)!;
        history.push({ price, timestamp });
        
        // Keep only last 200 price points
        if (history.length > 200) {
            history.shift();
        }
    }

    private updateTrendAnalysis(symbol: string, currentPrice: number, ehlersSignals?: EhlersSignals): void {
        const hmaPeriods = [5, 6, 7, 10, 14, 15, 21, 30, 35, 42, 70, 105];
        
        const hmaData: Array<{
            period: number;
            value: number;
            slope: number | null;
            color: 'green' | 'red' | 'neutral';
        }> = [];

        for (const period of hmaPeriods) {
            const hma = this.hmaCalculator.getLatestHMA(symbol, period);
            if (!hma) return;

            const slope = this.hmaCalculator.getHMASlope(symbol, period, Math.min(5, Math.floor(period / 10) + 2));
            const color = this.getHMAColor(slope);
            
            hmaData.push({
                period,
                value: hma.value,
                slope,
                color
            });
        }

        // New trend hierarchy analysis
        const trendHierarchy = this.analyzeTrendHierarchy(hmaData);
        
        // Market structure analysis
        const marketStructure = this.analyzeMarketStructure(symbol, currentPrice);
        
        // Trend confirmation check
        const trendConfirmation = this.requireTrendConfirmation(hmaData, trendHierarchy);
        
        // Enhanced trend direction using hierarchy
        const direction = this.calculateTrendWithHierarchy(hmaData);
        
        // Calculate strength and confidence with new factors
        const strength = this.calculateEnhancedTrendStrength(trendHierarchy, marketStructure, trendConfirmation);
        const confidence = this.calculateEnhancedConfidence(trendHierarchy, marketStructure, trendConfirmation);
        
        // Long-term trend analysis
        const longTermHMA = hmaData.find(h => h.period === 105);
        const longTermTrend = longTermHMA?.color === 'green' ? 'bullish' : 
                             longTermHMA?.color === 'red' ? 'bearish' : 'neutral';
        
        const longTermStrength = this.calculateLongTermTrendStrength(hmaData, currentPrice);

        // Generate base recommendation with trend filtering
        const baseRecommendation = this.generateTrendAlignedRecommendation(
            direction, strength, confidence, longTermTrend, longTermStrength, trendHierarchy
        );
        
        const baseScore = this.calculateEnhancedTradingScore(
            direction, strength, confidence, trendHierarchy, marketStructure
        );

        // Apply Ehlers signals with trend context
        const { finalRecommendation, enhancedScore } = this.applyEhlersWithTrendContext(
            baseRecommendation, baseScore, ehlersSignals, longTermTrend, longTermStrength, symbol
        );

        // Determine signal quality
        const signalQuality = this.assessSignalQuality(
            trendHierarchy, marketStructure, trendConfirmation, confidence
        );

        const analysis: TrendAnalysis = {
            symbol,
            direction,
            strength,
            confidence,
            hma5: hmaData.find(h => h.period === 5)?.value || null,
            hma200: hmaData.find(h => h.period === 105)?.value || null,
            hma5Slope: hmaData.find(h => h.period === 5)?.slope || null,
            hma200Slope: hmaData.find(h => h.period === 105)?.slope || null,
            hma5Color: hmaData.find(h => h.period === 5)?.color,
            hma200Color: hmaData.find(h => h.period === 105)?.color,
            colorAlignment: trendHierarchy.alignment > 70,
            longTermTrend,
            longTermTrendStrength: longTermStrength,
            trendHierarchy,
            marketStructure,
            trendConfirmation,
            signalQuality,
            price: currentPrice,
            lastUpdate: new Date(),
            recommendation: finalRecommendation,
            score: enhancedScore,
            ehlers: ehlersSignals,
            ehlersRecommendation: ehlersProcessor.generateEhlersRecommendation(symbol),
            cycleTrading: ehlersProcessor.isGoodForCycleTrading(symbol),
        };

        this.trendData.set(symbol, analysis);
        
        console.log(`Enhanced Trend Analysis for ${symbol}: ${direction.toUpperCase()} (${strength}) - ` +
                   `Hierarchy: ${trendHierarchy.alignment.toFixed(1)}% - Structure: ${marketStructure} - ` +
                   `Quality: ${signalQuality} - Score: ${enhancedScore.toFixed(1)} - Recommendation: ${finalRecommendation}`);
    }

    // 1. Trend Hierarchy Analysis
    private analyzeTrendHierarchy(hmaData: Array<{period: number, color: string}>): {
        shortTerm: TrendDirection;
        mediumTerm: TrendDirection;
        longTerm: TrendDirection;
        alignment: number;
    } {
        const shortTerm = hmaData.filter(h => h.period <= 15);
        const mediumTerm = hmaData.filter(h => h.period > 15 && h.period <= 42);
        const longTerm = hmaData.filter(h => h.period > 42);

        const getTimeframeTrend = (timeframe: typeof shortTerm): TrendDirection => {
            const bullish = timeframe.filter(h => h.color === 'green').length / timeframe.length;
            if (bullish > 0.6) return 'bullish';
            if (bullish < 0.4) return 'bearish';
            return 'neutral';
        };

        const shortTrendDir = getTimeframeTrend(shortTerm);
        const mediumTrendDir = getTimeframeTrend(mediumTerm);
        const longTrendDir = getTimeframeTrend(longTerm);

        // Calculate alignment score
        let alignmentScore = 0;
        if (shortTrendDir === mediumTrendDir) alignmentScore += 40;
        if (mediumTrendDir === longTrendDir) alignmentScore += 40;
        if (shortTrendDir === longTrendDir) alignmentScore += 20;

        return {
            shortTerm: shortTrendDir,
            mediumTerm: mediumTrendDir,
            longTerm: longTrendDir,
            alignment: alignmentScore
        };
    }

    // 2. Hierarchical Trend Calculation
    private calculateTrendWithHierarchy(hmaData: Array<{period: number, color: string}>): TrendDirection {
        let bullishScore = 0;
        let bearishScore = 0;
        
        for (const hma of hmaData) {
            // Longer periods get exponentially higher weights
            const weight = Math.pow(Math.log(hma.period + 1) / Math.log(2), 1.5);
            
            if (hma.color === 'green') bullishScore += weight;
            if (hma.color === 'red') bearishScore += weight;
        }
        
        // Require 25% edge for trend confirmation
        if (bullishScore > bearishScore * 1.25) return 'bullish';
        if (bearishScore > bullishScore * 1.25) return 'bearish';
        return 'neutral';
    }

    // 3. Market Structure Analysis
    private analyzeMarketStructure(symbol: string, currentPrice: number): 'uptrend' | 'downtrend' | 'sideways' {
        const history = this.priceHistory.get(symbol);
        if (!history || history.length < 20) return 'sideways';

        // Find recent swing highs and lows
        const recentHistory = history.slice(-50);
        let higherHighs = 0;
        let lowerLows = 0;
        let higherLows = 0;
        let lowerHighs = 0;

        for (let i = 10; i < recentHistory.length - 10; i++) {
            const current = recentHistory[i].price;
            const isHigh = recentHistory.slice(i-5, i+6).every((p, idx) => 
                idx === 5 || p.price <= current
            );
            const isLow = recentHistory.slice(i-5, i+6).every((p, idx) => 
                idx === 5 || p.price >= current
            );

            if (isHigh) {
                // Check if this high is higher than previous highs
                const prevHighs = recentHistory.slice(0, i).filter((_, idx) => {
                    if (idx < 5 || idx >= i-5) return false;
                    return recentHistory.slice(idx-5, idx+6).every((p, pidx) => 
                        pidx === 5 || p.price <= recentHistory[idx].price
                    );
                });
                
                if (prevHighs.length > 0 && current > Math.max(...prevHighs.map(p => p.price))) {
                    higherHighs++;
                } else if (prevHighs.length > 0) {
                    lowerHighs++;
                }
            }

            if (isLow) {
                const prevLows = recentHistory.slice(0, i).filter((_, idx) => {
                    if (idx < 5 || idx >= i-5) return false;
                    return recentHistory.slice(idx-5, idx+6).every((p, pidx) => 
                        pidx === 5 || p.price >= recentHistory[idx].price
                    );
                });
                
                if (prevLows.length > 0 && current > Math.min(...prevLows.map(p => p.price))) {
                    higherLows++;
                } else if (prevLows.length > 0) {
                    lowerLows++;
                }
            }
        }

        // Determine market structure
        if (higherHighs >= 2 && higherLows >= 2) return 'uptrend';
        if (lowerHighs >= 2 && lowerLows >= 2) return 'downtrend';
        return 'sideways';
    }

    // 4. Trend Confirmation
    private requireTrendConfirmation(
        hmaData: Array<{period: number, color: string}>, 
        hierarchy: {shortTerm: TrendDirection, mediumTerm: TrendDirection, longTerm: TrendDirection}
    ): boolean {
        // Check if at least 2 out of 3 timeframes agree
        const directions = [hierarchy.shortTerm, hierarchy.mediumTerm, hierarchy.longTerm];
        const bullishCount = directions.filter(d => d === 'bullish').length;
        const bearishCount = directions.filter(d => d === 'bearish').length;
        
        return Math.max(bullishCount, bearishCount) >= 2;
    }

    // 5. Enhanced Strength Calculation
    private calculateEnhancedTrendStrength(
        hierarchy: any, 
        marketStructure: 'uptrend' | 'downtrend' | 'sideways',
        confirmation: boolean
    ): TrendStrength {
        let strengthScore = 0;
        
        // Hierarchy alignment contributes 40 points
        strengthScore += (hierarchy.alignment / 100) * 40;
        
        // Market structure contributes 30 points
        if (marketStructure !== 'sideways') strengthScore += 30;
        
        // Confirmation contributes 30 points
        if (confirmation) strengthScore += 30;
        
        if (strengthScore >= 70) return 'strong';
        if (strengthScore >= 40) return 'moderate';
        return 'weak';
    }

    // 6. Enhanced Confidence Calculation
    private calculateEnhancedConfidence(
        hierarchy: any,
        marketStructure: 'uptrend' | 'downtrend' | 'sideways',
        confirmation: boolean
    ): number {
        let confidence = 50; // Base confidence
        
        // Add confidence based on hierarchy alignment
        confidence += (hierarchy.alignment / 100) * 30;
        
        // Market structure adds confidence
        if (marketStructure !== 'sideways') confidence += 15;
        
        // Trend confirmation adds confidence
        if (confirmation) confidence += 15;
        
        return Math.min(95, Math.max(10, confidence));
    }

    // 7. Trend-Aligned Recommendation Generation
    private generateTrendAlignedRecommendation(
        direction: TrendDirection,
        strength: TrendStrength,
        confidence: number,
        longTermTrend: TrendDirection,
        longTermStrength: number,
        hierarchy: any
    ): 'BUY' | 'SELL' | 'HOLD' {
        // Strong long-term trend filtering
        if (longTermStrength > 70) {
            if (direction === 'bullish' && longTermTrend === 'bearish') return 'HOLD';
            if (direction === 'bearish' && longTermTrend === 'bullish') return 'HOLD';
        }
        
        // Require minimum confidence and alignment for signals
        if (confidence < 60 || hierarchy.alignment < 50) return 'HOLD';
        
        // Generate recommendation based on aligned direction
        if (direction === 'bullish' && strength !== 'weak') return 'BUY';
        if (direction === 'bearish' && strength !== 'weak') return 'SELL';
        
        return 'HOLD';
    }

    // 8. Enhanced Ehlers Integration with Trend Context
    private applyEhlersWithTrendContext(
        baseRecommendation: 'BUY' | 'SELL' | 'HOLD',
        baseScore: number,
        ehlersSignals: EhlersSignals | undefined,
        longTermTrend: TrendDirection,
        longTermStrength: number,
        symbol: string
    ): { finalRecommendation: 'BUY' | 'SELL' | 'HOLD', enhancedScore: number } {
        const ehlersRecommendation = ehlersProcessor.generateEhlersRecommendation(symbol);
        const cycleTrading = ehlersProcessor.isGoodForCycleTrading(symbol);

        let finalRecommendation = baseRecommendation;
        let enhancedScore = baseScore;

        if (ehlersSignals && ehlersRecommendation) {
            const isCounterTrend = 
                (ehlersRecommendation.action === 'BUY' && longTermTrend === 'bearish') ||
                (ehlersRecommendation.action === 'SELL' && longTermTrend === 'bullish');

            // Strong anticipatory signals
            if (ehlersRecommendation.anticipatory && ehlersRecommendation.signalStrength === 'strong') {
                if (isCounterTrend && longTermStrength > 60) {
                    // Strong opposing trend - reduce signal strength
                    enhancedScore = Math.min(75, baseScore + 10);
                } else if (isCounterTrend) {
                    // Weak opposing trend - allow but reduce bonus
                    finalRecommendation = ehlersRecommendation.action;
                    enhancedScore = Math.min(85, baseScore + 15);
                } else {
                    // Signal aligns with trend - full bonus
                    finalRecommendation = ehlersRecommendation.action;
                    enhancedScore = Math.min(98, baseScore + 25);
                }
            }
            // Medium strength anticipatory signals
            else if (ehlersRecommendation.anticipatory && ehlersRecommendation.signalStrength === 'medium') {
                if (!isCounterTrend || longTermStrength < 50) {
                    finalRecommendation = ehlersRecommendation.action;
                    enhancedScore = Math.min(90, baseScore + 18);
                }
            }
            // Weak signals only if cycle conditions are good and trend allows
            else if (ehlersRecommendation.anticipatory && cycleTrading.suitable && !isCounterTrend) {
                finalRecommendation = ehlersRecommendation.action;
                enhancedScore = Math.min(80, baseScore + 10);
            }
        }

        return { finalRecommendation, enhancedScore };
    }

    // 9. Enhanced Trading Score
    private calculateEnhancedTradingScore(
        direction: TrendDirection,
        strength: TrendStrength,
        confidence: number,
        hierarchy: any,
        marketStructure: 'uptrend' | 'downtrend' | 'sideways'
    ): number {
        let score = confidence; // Start with confidence base
        
        // Add strength bonuses
        if (strength === 'strong') score += 15;
        else if (strength === 'moderate') score += 8;
        
        // Add hierarchy alignment bonus
        score += (hierarchy.alignment / 100) * 20;
        
        // Market structure bonus
        if (marketStructure !== 'sideways') score += 10;
        
        // Direction clarity bonus
        if (direction !== 'neutral') score += 5;
        
        return Math.min(100, Math.max(0, score));
    }

    // 10. Signal Quality Assessment
    private assessSignalQuality(
        hierarchy: any,
        marketStructure: 'uptrend' | 'downtrend' | 'sideways',
        confirmation: boolean,
        confidence: number
    ): 'excellent' | 'good' | 'fair' | 'poor' {
        let qualityScore = 0;
        
        if (hierarchy.alignment > 80) qualityScore += 25;
        else if (hierarchy.alignment > 60) qualityScore += 15;
        else if (hierarchy.alignment > 40) qualityScore += 8;
        
        if (marketStructure !== 'sideways') qualityScore += 25;
        if (confirmation) qualityScore += 25;
        if (confidence > 75) qualityScore += 25;
        else if (confidence > 60) qualityScore += 15;
        else if (confidence > 45) qualityScore += 8;
        
        if (qualityScore >= 80) return 'excellent';
        if (qualityScore >= 60) return 'good';
        if (qualityScore >= 40) return 'fair';
        return 'poor';
    }

    // Helper methods (implement based on your existing logic)
    private getHMAColor(slope: number | null): 'green' | 'red' | 'neutral' {
        if (!slope) return 'neutral';
        if (slope > 0.1) return 'green';
        if (slope < -0.1) return 'red';
        return 'neutral';
    }

    private calculateLongTermTrendStrength(hmaData: any[], currentPrice: number): number {
        // Implement based on your existing logic
        const longTermHMAs = hmaData.filter(h => h.period > 42);
        const bullishCount = longTermHMAs.filter(h => h.color === 'green').length;
        return (bullishCount / longTermHMAs.length) * 100;
    }

    private updateAllTrends(): void {
        // Implement periodic updates
        console.log('Updating all trends with enhanced analysis...');
    }

    // Public methods to access trend data
    getTrendAnalysis(symbol: string): TrendAnalysis | undefined {
        return this.trendData.get(symbol);
    }

    getAllTrends(): Map<string, TrendAnalysis> {
        return new Map(this.trendData);
    }

    dispose(): void {
        if (this.updateTimer) {
            clearInterval(this.updateTimer);
        }
    }
}