Compilation failed

File: /home/runner/workspace/src/pages/main/main.tsx:1:1
  Ã— Module build failed:
  â•°â”€â–¶   Ã—   Ã— the name `isConnected` is defined multiple times
        â”‚       â•­â”€[/home/runner/workspace/src/pages/main/main.tsx:111:1]
        â”‚   108 â”‚   const [contractType, setContractType] = useState('DIGITEVEN')
        â”‚   109 â”‚   const [predictionModel, setPredictionModel] = useState('neural_network')
        â”‚   110 â”‚   const [stakeAmount, setStakeAmount] = useState('1.00')
        â”‚   111 â”‚   const [isConnected, setIsConnected] = useState(false)
        â”‚       Â·          â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€
        â”‚       Â·               â•°â”€â”€ previous definition of `isConnected` here
        â”‚   112 â”‚   const [isTrading, setIsTrading] = useState(false)
        â”‚   113 â”‚   const [currentTick, setCurrentTick] = useState<number | null>(null)
        â”‚   114 â”‚   const [currentPrice, setCurrentPrice] = useState<string>('---')
        â”‚   115 â”‚   const [tickHistory, setTickHistory] = useState<{[key: string]: number[]}>({})
        â”‚   116 â”‚   const [digitDistribution, setDigitDistribution] = useState<number[]>(new Array(10).fill(0))
        â”‚   117 â”‚   const [digitPercentages, setDigitPercentages] = useState<number[]>(new Array(10).fill(10))
        â”‚   118 â”‚   const [nextPrediction, setNextPrediction] = useState<string>('')
        â”‚   119 â”‚   const [confidence, setConfidence] = useState(0)
        â”‚   120 â”‚   const [predictionAccuracy, setPredictionAccuracy] = useState(0)
        â”‚   121 â”‚   const [evenOddBias, setEvenOddBias] = useState('NEUTRAL')
        â”‚   122 â”‚   const [overUnderBias, setOverUnderBias] = useState('NEUTRAL')
        â”‚   123 â”‚   const [streakPattern, setStreakPattern] = useState('---')
        â”‚   124 â”‚   const [tradingLog, setTradingLog] = useState<any[]>([])
        â”‚   125 â”‚   const [totalTrades, setTotalTrades] = useState(0)
        â”‚   126 â”‚   const [winRate, setWinRate] = useState(0)
        â”‚   127 â”‚   const [profitLoss, setProfitLoss] = useState(0)
        â”‚   128 â”‚   const [currentStreak, setCurrentStreak] = useState(0)
        â”‚   129 â”‚   const [websocket, setWebsocket] = useState<WebSocket | null>(null)
        â”‚   130 â”‚     const [pythonCode, setPythonCode] = useState('');
        â”‚   131 â”‚     const [pythonOutput, setPythonOutput] = useState([]);
        â”‚   132 â”‚     const [savedScripts, setSavedScripts] = useState([]);
        â”‚   133 â”‚     const [isExecuting, setIsExecuting] = useState(false);
        â”‚   134 â”‚     // Add new state for analysis tool URL
        â”‚   135 â”‚
        â”‚   136 â”‚
        â”‚   137 â”‚     // Add function to check if analysis tool is active
        â”‚   138 â”‚     const isAnalysisToolActive = active_tab === ANALYSIS_TOOL;
        â”‚   139 â”‚
        â”‚   140 â”‚     useEffect(() => {
        â”‚   141 â”‚         if (connectionStatus !== CONNECTION_STATUS.OPENED) {
        â”‚   142 â”‚             const is_bot_running = document.getElementById('db-animation__stop-button') !== null;
        â”‚   143 â”‚             if (is_bot_running) {
        â”‚   144 â”‚                 clear();
        â”‚   145 â”‚                 stopBot();
        â”‚   146 â”‚                 api_base.setIsRunning(false);
        â”‚   147 â”‚             }
        â”‚   148 â”‚         }
        â”‚   149 â”‚     }, [clear, connectionStatus, stopBot]);
        â”‚   150 â”‚
        â”‚   151 â”‚     useEffect(() => {
        â”‚   152 â”‚         // Fetch the XML files and parse them
        â”‚   153 â”‚         const fetchBots = async () => {
        â”‚   154 â”‚             const botFiles = [
        â”‚   155 â”‚                 'Upgraded Candlemine.xml',
        â”‚   156 â”‚                 'Super Elite.xml', // Smart trading as second sub-tab
        â”‚   157 â”‚                 'Super Speed Bot.xml', // Speed bot as third sub-tab
        â”‚   158 â”‚                 'Envy-differ.xml',
        â”‚   159 â”‚                 'H_L auto vault.xml',
        â”‚   160 â”‚                 'Top-notch 2.xml',
        â”‚   161 â”‚                 // New bots added
        â”‚   162 â”‚                 '2_2025_Updated_Expert_Speed_Bot_Version_ðŸ“‰ðŸ“‰ðŸ“‰ðŸ“ˆðŸ“ˆðŸ“ˆ_1_1.xml',
        â”‚   163 â”‚                 '3 2025 Updated Version Of Candle MineðŸ‡¬ðŸ‡§.xml',
        â”‚   164 â”‚                 'Accumulators Pro Bot.xml',
        â”‚   165 â”‚                 // Additional new bots
        â”‚   166 â”‚                 'AUTO C4 PRO (2) Version.xml',
        â”‚   167 â”‚                 '2025 Killer version BotðŸ¤‘.xml',
        â”‚   168 â”‚                 'Alpha Version 2025.xml',
        â”‚   169 â”‚                 '1 Original DollarPrinterBot 2025 Version.xml',
        â”‚   170 â”‚             ];
        â”‚   171 â”‚
        â”‚   172 â”‚             const loadedBots = [];
        â”‚   173 â”‚
        â”‚   174 â”‚             for (const file of botFiles) {
        â”‚   175 â”‚                 try {
        â”‚   176 â”‚                     // Try multiple fetch approaches for better compatibility
        â”‚   177 â”‚                     let response;
        â”‚   178 â”‚                     let text = null;
        â”‚   179 â”‚
        â”‚   180 â”‚                     // Try public directory with encoded URI
        â”‚   181 â”‚                     try {
        â”‚   182 â”‚                         const encodedFile = encodeURIComponent(file);
        â”‚   183 â”‚                         response = await fetch(`/${encodedFile}`);
        â”‚   184 â”‚                         if (response.ok) {
        â”‚   185 â”‚                             text = await response.text();
        â”‚   186 â”‚                         }
        â”‚   187 â”‚                     } catch (e) {
        â”‚   188 â”‚                         console.log(`Failed to fetch encoded: ${file}`);
        â”‚   189 â”‚                     }
        â”‚   190 â”‚
        â”‚   191 â”‚                     // Try normal fetch if encoded didn't work
        â”‚   192 â”‚                     if (!text) {
        â”‚   193 â”‚                         try {
        â”‚   194 â”‚                             response = await fetch(`/${file}`);
        â”‚   195 â”‚                             if (response.ok) {
        â”‚   196 â”‚                                 text = await response.text();
        â”‚   197 â”‚                             }
        â”‚   198 â”‚                         } catch (e) {
        â”‚   199 â”‚                             console.log(`Failed to fetch normal: ${file}`);
        â”‚   200 â”‚                         }
        â”‚   201 â”‚                     }
        â”‚   202 â”‚
        â”‚   203 â”‚                     // Try without leading slash
        â”‚   204 â”‚                     if (!text) {
        â”‚   205 â”‚                         try {
        â”‚   206 â”‚                             response = await fetch(file);
        â”‚   207 â”‚                             if (response.ok) {
        â”‚   208 â”‚                                 text = await response.text();
        â”‚   209 â”‚                             }
        â”‚   210 â”‚                         } catch (e) {
        â”‚   211 â”‚                             console.log(`Failed to fetch without slash: ${file}`);
        â”‚   212 â”‚                         }
        â”‚   213 â”‚                     }
        â”‚   214 â”‚
        â”‚   215 â”‚                     if (!text) {
        â”‚   216 â”‚                         console.warn(`Could not load bot file: ${file}`);
        â”‚   217 â”‚                         loadedBots.push({
        â”‚   218 â”‚                             title: file.replace('.xml', ''),
        â”‚   219 â”‚                             image: 'default_image_path',
        â”‚   220 â”‚                             filePath: file,
        â”‚   221 â”‚                             xmlContent: null,
        â”‚   222 â”‚                             isPlaceholder: true
        â”‚   223 â”‚                         });
        â”‚   224 â”‚                         continue;
        â”‚   225 â”‚                     }
        â”‚   226 â”‚
        â”‚   227 â”‚                     // Validate XML content
        â”‚   228 â”‚                     if (!text.trim().startsWith('<xml') && !text.trim().startsWith('<?xml')) {
        â”‚   229 â”‚                         console.warn(`Invalid XML content for ${file}`);
        â”‚   230 â”‚                         loadedBots.push({
        â”‚   231 â”‚                             title: file.replace('.xml', ''),
        â”‚   232 â”‚                             image: 'default_image_path',
        â”‚   233 â”‚                             filePath: file,
        â”‚   234 â”‚                             xmlContent: null,
        â”‚   235 â”‚                             isPlaceholder: true
        â”‚   236 â”‚                         });
        â”‚   237 â”‚                         continue;
        â”‚   238 â”‚                     }
        â”‚   239 â”‚
        â”‚   240 â”‚                     const parser = new DOMParser();
        â”‚   241 â”‚                     const xml = parser.parseFromString(text, 'application/xml');
        â”‚   242 â”‚
        â”‚   243 â”‚                     // Check if XML parsing was successful
        â”‚   244 â”‚                     const parseError = xml.getElementsByTagName('parsererror')[0];
        â”‚   245 â”‚                     if (parseError) {
        â”‚   246 â”‚                         console.warn(`XML parsing error for ${file}:`, parseError.textContent);
        â”‚   247 â”‚                         loadedBots.push({
        â”‚   248 â”‚                             title: file.replace('.xml', ''),
        â”‚   249 â”‚                             image: 'default_image_path',
        â”‚   250 â”‚                             filePath: file,
        â”‚   251 â”‚                             xmlContent: text, // Still include the content even if parsing failed
        â”‚   252 â”‚                             isPlaceholder: false
        â”‚   253 â”‚                         });
        â”‚   254 â”‚                         continue;
        â”‚   255 â”‚                     }
        â”‚   256 â”‚
        â”‚   257 â”‚                     loadedBots.push({
        â”‚   258 â”‚                         title: file.replace('.xml', ''),
        â”‚   259 â”‚                         image: xml.getElementsByTagName('image')[0]?.textContent || 'default_image_path',
        â”‚   260 â”‚                         filePath: file,
        â”‚   261 â”‚                         xmlContent: text,
        â”‚   262 â”‚                         isPlaceholder: false
        â”‚   263 â”‚                     });
        â”‚   264 â”‚
        â”‚   265 â”‚                     console.log(`Successfully loaded: ${file}`);
        â”‚   266 â”‚
        â”‚   267 â”‚                 } catch (error) {
        â”‚   268 â”‚                     console.error(`Error loading bot ${file}:`, error);
        â”‚   269 â”‚                     loadedBots.push({
        â”‚   270 â”‚                         title: file.replace('.xml', ''),
        â”‚   271 â”‚                         image: 'default_image_path',
        â”‚   272 â”‚                         filePath: file,
        â”‚   273 â”‚                         xmlContent: null,
        â”‚   274 â”‚                         isPlaceholder: true
        â”‚   275 â”‚                     });
        â”‚   276 â”‚                 }
        â”‚   277 â”‚             }
        â”‚   278 â”‚
        â”‚   279 â”‚             setBots(loadedBots);
        â”‚   280 â”‚             console.log(`Loaded ${loadedBots.length} bots total`);
        â”‚   281 â”‚             console.log(`Successful: ${loadedBots.filter(b => !b.isPlaceholder).length}`);
        â”‚   282 â”‚             console.log(`Placeholders: ${loadedBots.filter(b => b.isPlaceholder).length}`);
        â”‚   283 â”‚         };
        â”‚   284 â”‚
        â”‚   285 â”‚         fetchBots();
        â”‚   286 â”‚     }, []);
        â”‚   287 â”‚
        â”‚   288 â”‚     const runBot = (xmlContent: string) => {
        â”‚   289 â”‚         // Load the strategy into the bot builder
        â”‚   290 â”‚         updateWorkspaceName(xmlContent);
        â”‚   291 â”‚         console.log('Running bot with content:', xmlContent);
        â”‚   292 â”‚     };
        â”‚   293 â”‚
        â”‚   294 â”‚     const handleTabChange = React.useCallback(
        â”‚   295 â”‚         (tab_index: number) => {
        â”‚   296 â”‚             setActiveTab(tab_index);
        â”‚   297 â”‚         },
        â”‚   298 â”‚         [setActiveTab]
        â”‚   299 â”‚     );
        â”‚   300 â”‚
        â”‚   301 â”‚     const handleBotClick = useCallback(async (bot: { filePath: string; xmlContent: string | null; title?: string; isPlaceholder?: boolean }) => {
        â”‚   302 â”‚         setActiveTab(DBOT_TABS.BOT_BUILDER);
        â”‚   303 â”‚         try {
        â”‚   304 â”‚             console.log("Loading bot:", bot.title, "Placeholder:", bot.isPlaceholder);
        â”‚   305 â”‚
        â”‚   306 â”‚             let xmlContent = bot.xmlContent;
        â”‚   307 â”‚
        â”‚   308 â”‚             // If it's a placeholder bot or no content, try to load the content now
        â”‚   309 â”‚             if (bot.isPlaceholder || !xmlContent) {
        â”‚   310 â”‚                 console.log("Attempting to load XML content for bot...");
        â”‚   311 â”‚                 try {
        â”‚   312 â”‚                     let response;
        â”‚   313 â”‚                     let success = false;
        â”‚   314 â”‚
        â”‚   315 â”‚                     // Try multiple approaches
        â”‚   316 â”‚                     const attempts = [
        â”‚   317 â”‚                         `/${encodeURIComponent(bot.filePath)}`,
        â”‚   318 â”‚                         `/${bot.filePath}`,
        â”‚   319 â”‚                         bot.filePath
        â”‚   320 â”‚                     ];
        â”‚   321 â”‚
        â”‚   322 â”‚                     for (const url of attempts) {
        â”‚   323 â”‚                         try {
        â”‚   324 â”‚                             response = await fetch(url);
        â”‚   325 â”‚                             if (response.ok) {
        â”‚   326 â”‚                                 xmlContent = await response.text();
        â”‚   327 â”‚                                 console.log(`Successfully loaded XML from: ${url}`);
        â”‚   328 â”‚                                 success = true;
        â”‚   329 â”‚                                 break;
        â”‚   330 â”‚                             }
        â”‚   331 â”‚                         } catch (e) {
        â”‚   332 â”‚                             console.log(`Failed attempt with URL: ${url}`);
        â”‚   333 â”‚                         }
        â”‚   334 â”‚                     }
        â”‚   335 â”‚
        â”‚   336 â”‚                     if (!success) {
        â”‚   337 â”‚                         throw new Error(`Could not fetch ${bot.filePath} from any URL`);
        â”‚   338 â”‚                     }
        â”‚   339 â”‚                 } catch (fetchError) {
        â”‚   340 â”‚                     console.error("Failed to load bot content:", fetchError);
        â”‚   341 â”‚                     // Removed alert message
        â”‚   342 â”‚                     return;
        â”‚   343 â”‚                 }
        â”‚   344 â”‚             }
        â”‚   345 â”‚
        â”‚   346 â”‚             if (!xmlContent || xmlContent.trim().length === 0) {
        â”‚   347 â”‚                 //Removed alert message
        â”‚   348 â”‚                 return;
        â”‚   349 â”‚             }
        â”‚   350 â”‚
        â”‚   351 â”‚             console.log("XML Content length:", xmlContent?.length);
        â”‚   352 â”‚             console.log("XML Content preview:", xmlContent?.substring(0, 200));
        â”‚   353 â”‚
        â”‚   354 â”‚             // Validate XML content
        â”‚   355 â”‚             if (!xmlContent.trim().startsWith('<xml') && !xmlContent.trim().startsWith('<?xml')) {
        â”‚   356 â”‚                 //Removed alert message
        â”‚   357 â”‚                 return;
        â”‚   358 â”‚             }
        â”‚   359 â”‚
        â”‚   360 â”‚             if (typeof load_modal.loadFileFromContent === 'function' && xmlContent) {
        â”‚   361 â”‚                 try {
        â”‚   362 â”‚                     await load_modal.loadFileFromContent(xmlContent);
        â”‚   363 â”‚                     console.log("Bot loaded successfully!");
        â”‚   364 â”‚
        â”‚   365 â”‚                     // Also update workspace name
        â”‚   366 â”‚                     if (typeof updateWorkspaceName === 'function') {
        â”‚   367 â”‚                         updateWorkspaceName(xmlContent);
        â”‚   368 â”‚                     }
        â”‚   369 â”‚                 } catch (loadError) {
        â”‚   370 â”‚                     console.error("Error in load_modal.loadFileFromContent:", loadError);
        â”‚   371 â”‚                     //Removed alert message
        â”‚   372 â”‚                 }
        â”‚   373 â”‚             } else {
        â”‚   374 â”‚                 console.error("loadFileFromContent is not defined on load_modal or xmlContent is empty");
        â”‚   375 â”‚                 console.log("load_modal object:", load_modal);
        â”‚   376 â”‚                 //Removed alert message
        â”‚   377 â”‚             }
        â”‚   378 â”‚
        â”‚   379 â”‚         } catch (error) {
        â”‚   380 â”‚             console.error("Error loading bot:", error);
        â”‚   381 â”‚              //Removed alert message
        â”‚   382 â”‚         }
        â”‚   383 â”‚     }, [setActiveTab, load_modal]);
        â”‚   384 â”‚
        â”‚   385 â”‚     const handleOpen = useCallback(async () => {
        â”‚   386 â”‚         await load_modal.loadFileFromRecent();
        â”‚   387 â”‚         setActiveTab(DBOT_TABS.BOT_BUILDER);
        â”‚   388 â”‚         // rudderStackSendDashboardClickEvent({ dashboard_click_name: 'open', subpage_name: 'bot_builder' });
        â”‚   389 â”‚     }, [load_modal, setActiveTab]);
        â”‚   390 â”‚
        â”‚   391 â”‚     // Digits Trading Bot Functions
        â”‚   392 â”‚   const connectToAPI = async () => {
        â”‚   393 â”‚     try {
        â”‚   394 â”‚       // Close existing connection if any
        â”‚   395 â”‚       if (websocket) {
        â”‚   396 â”‚         websocket.close()
        â”‚   397 â”‚         setWebsocket(null)
        â”‚   398 â”‚       }
        â”‚   399 â”‚
        â”‚   400 â”‚       setCurrentPrice('Connecting...')
        â”‚   401 â”‚       setIsConnected(false)
        â”‚   402 â”‚
        â”‚   403 â”‚       const ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=75771')
        â”‚   404 â”‚
        â”‚   405 â”‚       ws.onopen = () => {
        â”‚   406 â”‚         console.log('WebSocket connected successfully')
        â”‚   407 â”‚         setIsConnected(true)
        â”‚   408 â”‚         setWebsocket(ws)
        â”‚   409 â”‚         setCurrentPrice('Connected - Waiting for ticks...')
        â”‚   410 â”‚
        â”‚   411 â”‚         // First, get historical ticks for the selected volatility
        â”‚   412 â”‚         const historyRequest = {
        â”‚   413 â”‚           ticks_history: selectedIndex,
        â”‚   414 â”‚           count: 5000,
        â”‚   415 â”‚           end: 'latest',
        â”‚   416 â”‚           style: 'ticks',
        â”‚   417 â”‚           req_id: 2
        â”‚   418 â”‚         }
        â”‚   419 â”‚         console.log('Requesting historical ticks:', historyRequest)
        â”‚   420 â”‚         ws.send(JSON.stringify(historyRequest))
        â”‚   421 â”‚
        â”‚   422 â”‚         // Then subscribe to real-time tick stream
        â”‚   423 â”‚         const tickRequest = {
        â”‚   424 â”‚           ticks: selectedIndex,
        â”‚   425 â”‚           subscribe: 1,
        â”‚   426 â”‚           req_id: 1
        â”‚   427 â”‚         }
        â”‚   428 â”‚         console.log('Sending tick subscription request:', tickRequest)
        â”‚   429 â”‚         ws.send(JSON.stringify(tickRequest))
        â”‚   430 â”‚       }
        â”‚   431 â”‚
        â”‚   432 â”‚       ws.onmessage = (event) => {
        â”‚   433 â”‚         try {
        â”‚   434 â”‚           const data = JSON.parse(event.data)
        â”‚   435 â”‚           console.log('WebSocket message received:', data)
        â”‚   436 â”‚
        â”‚   437 â”‚           // Handle historical tick data
        â”‚   438 â”‚           if (data.history && data.history.prices) {
        â”‚   439 â”‚             const symbol = data.echo_req.ticks_history
        â”‚   440 â”‚             const prices = data.history.prices.map(price => parseFloat(price))
        â”‚   441 â”‚             console.log(`Received ${prices.length} historical ticks for ${symbol}`)
        â”‚   442 â”‚
        â”‚   443 â”‚             // Store historical ticks for this volatility
        â”‚   444 â”‚             setTickHistory(prev => ({
        â”‚   445 â”‚               ...prev,
        â”‚   446 â”‚               [symbol]: prices
        â”‚   447 â”‚             }))
        â”‚   448 â”‚
        â”‚   449 â”‚             // Set current price to latest historical tick
        â”‚   450 â”‚             if (prices.length > 0) {
        â”‚   451 â”‚               const latestPrice = prices[prices.length - 1]
        â”‚   452 â”‚               setCurrentPrice(latestPrice.toFixed(5))
        â”‚   453 â”‚
        â”‚   454 â”‚               // Calculate distributions for historical data
        â”‚   455 â”‚               calculateDigitDistribution(prices)
        â”‚   456 â”‚               analyzePatterns(prices)
        â”‚   457 â”‚               makePrediction(prices)
        â”‚   458 â”‚               calculateContractProbabilities(prices)
        â”‚   459 â”‚             }
        â”‚   460 â”‚           }
        â”‚   461 â”‚
        â”‚   462 â”‚           // Handle real-time tick data
        â”‚   463 â”‚           if (data.tick && (data.tick.symbol === selectedIndex || getAlternativeSymbol(data.tick.symbol) === selectedIndex)) {
        â”‚   464 â”‚             console.log('Real-time tick received for', data.tick.symbol, ':', data.tick.quote)
        â”‚   465 â”‚             const price = parseFloat(data.tick.quote)
        â”‚   466 â”‚             if (!isNaN(price)) {
        â”‚   467 â”‚               setCurrentPrice(price.toFixed(5))
        â”‚   468 â”‚               handleNewTick(price, data.tick.symbol)
        â”‚   469 â”‚             }
        â”‚   470 â”‚           }
        â”‚   471 â”‚
        â”‚   472 â”‚           // Handle subscription confirmation
        â”‚   473 â”‚           if (data.msg_type === 'tick' && data.subscription) {
        â”‚   474 â”‚             console.log('Tick subscription confirmed for:', data.subscription.id)
        â”‚   475 â”‚             setCurrentPrice('Connected - Receiving ticks for ' + selectedIndex)
        â”‚   476 â”‚           }
        â”‚   477 â”‚
        â”‚   478 â”‚           // Handle errors
        â”‚   479 â”‚           if (data.error) {
        â”‚   480 â”‚             console.error('WebSocket API error:', data.error)
        â”‚   481 â”‚             setCurrentPrice(`Error: ${data.error.message}`)
        â”‚   482 â”‚
        â”‚   483 â”‚             // Try alternative symbol formats for common volatility indices
        â”‚   484 â”‚             if (data.error.code === 'InvalidSymbol') {
        â”‚   485 â”‚               console.log('Invalid symbol, trying alternative format...')
        â”‚   486 â”‚               const altSymbol = getAlternativeSymbol(selectedIndex)
        â”‚   487 â”‚               if (altSymbol && altSymbol !== selectedIndex) {
        â”‚   488 â”‚                 console.log('Trying alternative symbol:', altSymbol)
        â”‚   489 â”‚                 const altRequest = {
        â”‚   490 â”‚                   ticks_history: altSymbol,
        â”‚   491 â”‚                   count: 5000,
        â”‚   492 â”‚                   end: 'latest',
        â”‚   493 â”‚                   style: 'ticks',
        â”‚   494 â”‚                   req_id: Date.now()
        â”‚   495 â”‚                 }
        â”‚   496 â”‚                 ws.send(JSON.stringify(altRequest))
        â”‚   497 â”‚               }
        â”‚   498 â”‚             }
        â”‚   499 â”‚           }
        â”‚   500 â”‚
        â”‚   501 â”‚           // Handle forget_all response
        â”‚   502 â”‚           if (data.msg_type === 'forget_all') {
        â”‚   503 â”‚             console.log('All subscriptions forgotten successfully')
        â”‚   504 â”‚           }
        â”‚   505 â”‚         } catch (parseError) {
        â”‚   506 â”‚           console.error('Error parsing WebSocket message:', parseError)
        â”‚   507 â”‚           setCurrentPrice('Parse Error')
        â”‚   508 â”‚         }
        â”‚   509 â”‚       }
        â”‚   510 â”‚
        â”‚   511 â”‚       ws.onclose = (event) => {
        â”‚   512 â”‚         console.log('WebSocket connection closed:', event.code, event.reason)
        â”‚   513 â”‚         setIsConnected(false)
        â”‚   514 â”‚         setWebsocket(null)
        â”‚   515 â”‚         setCurrentPrice('Disconnected')
        â”‚   516 â”‚
        â”‚   517 â”‚         // Auto-reconnect after 3 seconds if not manually closed
        â”‚   518 â”‚         if (event.code !== 1000) {
        â”‚   519 â”‚           setTimeout(() => {
        â”‚   520 â”‚             console.log('Attempting to reconnect...')
        â”‚   521 â”‚             connectToAPI()
        â”‚   522 â”‚           }, 3000)
        â”‚   523 â”‚         }
        â”‚   524 â”‚       }
        â”‚   525 â”‚
        â”‚   526 â”‚       ws.onerror = (error) => {
        â”‚   527 â”‚         console.error('WebSocket error:', error)
        â”‚   528 â”‚         setIsConnected(false)
        â”‚   529 â”‚         setWebsocket(null)
        â”‚   530 â”‚         setCurrentPrice('Connection Error')
        â”‚   531 â”‚       }
        â”‚   532 â”‚
        â”‚   533 â”‚     } catch (error) {
        â”‚   534 â”‚       console.error('Connection failed:', error)
        â”‚   535 â”‚       setIsConnected(false)
        â”‚   536 â”‚       setCurrentPrice('Failed to connect')
        â”‚   537 â”‚     }
        â”‚   538 â”‚   }
        â”‚   539 â”‚
        â”‚   540 â”‚   // Helper function to get alternative symbol formats
        â”‚   541 â”‚   const getAlternativeSymbol = (symbol) => {
        â”‚   542 â”‚     const symbolMap = {
        â”‚   543 â”‚       // Forward mapping
        â”‚   544 â”‚       'R_10': '1HZ10V',
        â”‚   545 â”‚       'R_25': '1HZ25V',
        â”‚   546 â”‚       'R_50': '1HZ50V',
        â”‚   547 â”‚       'R_75': '1HZ75V',
        â”‚   548 â”‚       'R_100': '1HZ100V',
        â”‚   549 â”‚       'R_150': '1HZ150V',
        â”‚   550 â”‚       'R_200': '1HZ200V',
        â”‚   551 â”‚       'R_250': '1HZ250V',
        â”‚   552 â”‚       'R_300': '1HZ300V',
        â”‚   553 â”‚       // Reverse mapping
        â”‚   554 â”‚       '1HZ10V': 'R_10',
        â”‚   555 â”‚       '1HZ25V': 'R_25',
        â”‚   556 â”‚       '1HZ50V': 'R_50',
        â”‚   557 â”‚       '1HZ75V': 'R_75',
        â”‚   558 â”‚       '1HZ100V': 'R_100',
        â”‚   559 â”‚       '1HZ150V': 'R_150',
        â”‚   560 â”‚       '1HZ200V': 'R_200',
        â”‚   561 â”‚       '1HZ250V': 'R_250',
        â”‚   562 â”‚       '1HZ300V': 'R_300',
        â”‚   563 â”‚       // Boom/Crash indices
        â”‚   564 â”‚       'BOOM1000': 'BOOM1000',
        â”‚   565 â”‚       'CRASH1000': 'CRASH1000',
        â”‚   566 â”‚       'BOOM500': 'BOOM500',
        â”‚   567 â”‚       'CRASH500': 'CRASH500',
        â”‚   568 â”‚       'BOOM300': 'BOOM300',
        â”‚   569 â”‚       'CRASH300': 'CRASH300'
        â”‚   570 â”‚     }
        â”‚   571 â”‚     return symbolMap[symbol] || symbol
        â”‚   572 â”‚   }
        â”‚   573 â”‚
        â”‚   574 â”‚   const handleNewTick = (tick: number, symbol: string) => {
        â”‚   575 â”‚     try {
        â”‚   576 â”‚       if (typeof tick !== 'number' || isNaN(tick)) {
        â”‚   577 â”‚         console.warn('Invalid tick received:', tick)
        â”‚   578 â”‚         return
        â”‚   579 â”‚       }
        â”‚   580 â”‚
        â”‚   581 â”‚       console.log('Processing tick:', tick, 'for symbol:', symbol)
        â”‚   582 â”‚
        â”‚   583 â”‚       // Update current tick and price display
        â”‚   584 â”‚       setCurrentTick(tick)
        â”‚   585 â”‚       const priceStr = tick.toFixed(5)
        â”‚   586 â”‚       setCurrentPrice(priceStr)
        â”‚   587 â”‚
        â”‚   588 â”‚       // Store in tick history per volatility (keep last 5000 per symbol)
        â”‚   589 â”‚       setTickHistory(prev => {
        â”‚   590 â”‚         const currentHistory = prev[symbol] || []
        â”‚   591 â”‚         const newHistory = [...currentHistory, tick].slice(-5000)
        â”‚   592 â”‚
        â”‚   593 â”‚         const updated = {
        â”‚   594 â”‚           ...prev,
        â”‚   595 â”‚           [symbol]: newHistory
        â”‚   596 â”‚         }
        â”‚   597 â”‚
        â”‚   598 â”‚         // Only run analysis if we have enough data for current symbol
        â”‚   599 â”‚         if (newHistory.length >= 10) {
        â”‚   600 â”‚           // Calculate digit distribution with real-time updates
        â”‚   601 â”‚           calculateDigitDistribution(newHistory)
        â”‚   602 â”‚
        â”‚   603 â”‚           // Perform enhanced pattern analysis
        â”‚   604 â”‚           analyzePatterns(newHistory)
        â”‚   605 â”‚
        â”‚   606 â”‚           // Make AI-powered prediction
        â”‚   607 â”‚           makePrediction(newHistory)
        â”‚   608 â”‚
        â”‚   609 â”‚           // Calculate contract-specific probabilities
        â”‚   610 â”‚           calculateContractProbabilities(newHistory)
        â”‚   611 â”‚         }
        â”‚   612 â”‚
        â”‚   613 â”‚         return updated
        â”‚   614 â”‚       })
        â”‚   615 â”‚
        â”‚   616 â”‚       // Execute trade if trading is active
        â”‚   617 â”‚       if (isTrading) {
        â”‚   618 â”‚         executeTradeDecision(tick)
        â”‚   619 â”‚       }
        â”‚   620 â”‚     } catch (error) {
        â”‚   621 â”‚       console.error('Error handling new tick:', error)
        â”‚   622 â”‚     }
        â”‚   623 â”‚   }
        â”‚   624 â”‚
        â”‚   625 â”‚   const calculateContractProbabilities = (history: number[]) => {
        â”‚   626 â”‚     if (history.length < 10) return
        â”‚   627 â”‚
        â”‚   628 â”‚     const recentTicks = history.slice(-100) // Use last 100 ticks for probability calculation
        â”‚   629 â”‚     const lastDigits = recentTicks.map(tick => Math.floor(Math.abs(tick * 100000)) % 10)
        â”‚   630 â”‚
        â”‚   631 â”‚     // Calculate probabilities based on contract type
        â”‚   632 â”‚     let probabilities = {}
        â”‚   633 â”‚
        â”‚   634 â”‚     if (contractType === 'DIGITEVEN' || contractType === 'DIGITODD') {
        â”‚   635 â”‚       const evenCount = lastDigits.filter(d => d % 2 === 0).length
        â”‚   636 â”‚       const oddCount = lastDigits.length - evenCount
        â”‚   637 â”‚       const total = lastDigits.length
        â”‚   638 â”‚
        â”‚   639 â”‚       probabilities = {
        â”‚   640 â”‚         even: ((evenCount / total) * 100).toFixed(1),
        â”‚   641 â”‚         odd: ((oddCount / total) * 100).toFixed(1)
        â”‚   642 â”‚       }
        â”‚   643 â”‚     } else if (contractType === 'DIGITOVER' || contractType === 'DIGITUNDER') {
        â”‚   644 â”‚       const underCount = lastDigits.filter(d => d < 5).length // 0,1,2,3,4
        â”‚   645 â”‚       const overCount = lastDigits.filter(d => d >= 5).length // 5,6,7,8,9
        â”‚   646 â”‚       const total = lastDigits.length
        â”‚   647 â”‚
        â”‚   648 â”‚       probabilities = {
        â”‚   649 â”‚         under: ((underCount / total) * 100).toFixed(1),
        â”‚   650 â”‚         over: ((overCount / total) * 100).toFixed(1)
        â”‚   651 â”‚       }
        â”‚   652 â”‚     } else if (contractType === 'DIGITMATCH' || contractType === 'DIGITDIFF') {
        â”‚   653 â”‚       // For match/differs, show probability for each digit
        â”‚   654 â”‚       const digitCounts = new Array(10).fill(0)
        â”‚   655 â”‚       lastDigits.forEach(d => digitCounts[d]++)
        â”‚   656 â”‚       const total = lastDigits.length
        â”‚   657 â”‚
        â”‚   658 â”‚       probabilities = {}
        â”‚   659 â”‚       for (let i = 0; i < 10; i++) {
        â”‚   660 â”‚         probabilities[`digit_${i}`] = ((digitCounts[i] / total) * 100).toFixed(1)
        â”‚   661 â”‚       }
        â”‚   662 â”‚     }
        â”‚   663 â”‚
        â”‚   664 â”‚     // You can use these probabilities to update UI or make trading decisions
        â”‚   665 â”‚     console.log('Contract probabilities:', probabilities)
        â”‚   666 â”‚   }
        â”‚   667 â”‚
        â”‚   668 â”‚   const calculateDigitDistribution = (history: number[]) => {
        â”‚   669 â”‚     if (history.length === 0) return
        â”‚   670 â”‚
        â”‚   671 â”‚     const digitCounts = new Array(10).fill(0)
        â”‚   672 â”‚
        â”‚   673 â”‚     // Count occurrences of each last digit
        â”‚   674 â”‚     history.forEach(tick => {
        â”‚   675 â”‚       const lastDigit = Math.floor(Math.abs(tick * 100000)) % 10
        â”‚   676 â”‚       digitCounts[lastDigit]++
        â”‚   677 â”‚     })
        â”‚   678 â”‚
        â”‚   679 â”‚     setDigitDistribution(digitCounts)
        â”‚   680 â”‚
        â”‚   681 â”‚     // Calculate percentages
        â”‚   682 â”‚     const total = history.length
        â”‚   683 â”‚     const percentages = digitCounts.map(count => total > 0 ? (count / total) * 100 : 10)
        â”‚   684 â”‚     setDigitPercentages(percentages)
        â”‚   685 â”‚   }
        â”‚   686 â”‚
        â”‚   687 â”‚   const analyzePatterns = (history: number[]) => {
        â”‚   688 â”‚     if (history.length < 100) return
        â”‚   689 â”‚
        â”‚   690 â”‚     try {
        â”‚   691 â”‚       const recentTicks = history.slice(-100)
        â”‚   692 â”‚       const lastDigits = recentTicks.map(tick => Math.floor(Math.abs(tick * 100000)) % 10)
        â”‚   693 â”‚
        â”‚   694 â”‚       // Analyze even/odd bias
        â”‚   695 â”‚       const evenCount = lastDigits.filter(d => d % 2 === 0).length
        â”‚   696 â”‚       const oddCount = lastDigits.filter(d => d % 2 === 1).length
        â”‚   697 â”‚
        â”‚   698 â”‚       if (evenCount > oddCount * 1.2) {
        â”‚   699 â”‚         setEvenOddBias('EVEN BIAS')
        â”‚   700 â”‚       } else if (oddCount > evenCount * 1.2) {
        â”‚   701 â”‚         setEvenOddBias('ODD BIAS')
        â”‚   702 â”‚       } else {
        â”‚   703 â”‚         setEvenOddBias('NEUTRAL')
        â”‚   704 â”‚       }
        â”‚   705 â”‚
        â”‚   706 â”‚       // Analyze over/under bias (0-4 vs 5-9)
        â”‚   707 â”‚       const underCount = lastDigits.filter(d => d < 5).length
        â”‚   708 â”‚       const overCount = lastDigits.filter(d => d >= 5).length
        â”‚   709 â”‚
        â”‚   710 â”‚       if (underCount > overCount * 1.2) {
        â”‚   711 â”‚         setOverUnderBias('UNDER BIAS')
        â”‚   712 â”‚       } else if (overCount > underCount * 1.2) {
        â”‚   713 â”‚         setOverUnderBias('OVER BIAS')
        â”‚   714 â”‚       } else {
        â”‚   715 â”‚         setOverUnderBias('NEUTRAL')
        â”‚   716 â”‚       }
        â”‚   717 â”‚
        â”‚   718 â”‚       // Analyze streak patterns
        â”‚   719 â”‚       const streaks = []
        â”‚   720 â”‚       if (lastDigits.length > 0) {
        â”‚   721 â”‚         let currentStreakType = lastDigits[0] % 2
        â”‚   722 â”‚         let streakLength = 1
        â”‚   723 â”‚
        â”‚   724 â”‚         for (let i = 1; i < lastDigits.length; i++) {
        â”‚   725 â”‚           if (lastDigits[i] % 2 === currentStreakType) {
        â”‚   726 â”‚             streakLength++
        â”‚   727 â”‚           } else {
        â”‚   728 â”‚             streaks.push(streakLength)
        â”‚   729 â”‚             currentStreakType = lastDigits[i] % 2
        â”‚   730 â”‚             streakLength = 1
        â”‚   731 â”‚           }
        â”‚   732 â”‚         }
        â”‚   733 â”‚
        â”‚   734 â”‚         if (streaks.length > 0) {
        â”‚   735 â”‚           const avgStreak = streaks.reduce((a, b) => a + b, 0) / streaks.length
        â”‚   736 â”‚           setStreakPattern(`AVG: ${avgStreak.toFixed(1)}`)
        â”‚   737 â”‚         } else {
        â”‚   738 â”‚           setStreakPattern('---')
        â”‚   739 â”‚         }
        â”‚   740 â”‚       }
        â”‚   741 â”‚     } catch (error) {
        â”‚   742 â”‚       console.error('Error in pattern analysis:', error)
        â”‚   743 â”‚     }
        â”‚   744 â”‚   }
        â”‚   745 â”‚
        â”‚   746 â”‚   const makePrediction = (history: number[]) => {
        â”‚   747 â”‚     if (history.length < 50) return
        â”‚   748 â”‚
        â”‚   749 â”‚     try {
        â”‚   750 â”‚       const recentTicks = history.slice(-50)
        â”‚   751 â”‚       const lastDigits = recentTicks.map(tick => Math.floor(Math.abs(tick * 100000)) % 10)
        â”‚   752 â”‚
        â”‚   753 â”‚       // Advanced prediction based on contract type
        â”‚   754 â”‚       if (contractType === 'DIGITEVEN' || contractType === 'DIGITODD') {
        â”‚   755 â”‚         const evenCount = lastDigits.filter(d => d % 2 === 0).length
        â”‚   756 â”‚         const oddCount = lastDigits.length - evenCount
        â”‚   757 â”‚
        â”‚   758 â”‚         if (contractType === 'DIGITEVEN') {
        â”‚   759 â”‚           setNextPrediction(evenCount < oddCount ? 'EVEN' : 'ODD')
        â”‚   760 â”‚           setConfidence(Math.min(95, 60 + Math.abs(evenCount - oddCount) * 2))
        â”‚   761 â”‚         } else {
        â”‚   762 â”‚           setNextPrediction(oddCount < evenCount ? 'ODD' : 'EVEN')
        â”‚   763 â”‚           setConfidence(Math.min(95, 60 + Math.abs(evenCount - oddCount) * 2))
        â”‚   764 â”‚         }
        â”‚   765 â”‚       } else if (contractType === 'DIGITOVER' || contractType === 'DIGITUNDER') {
        â”‚   766 â”‚         const underCount = lastDigits.filter(d => d < 5).length
        â”‚   767 â”‚         const overCount = lastDigits.length - underCount
        â”‚   768 â”‚
        â”‚   769 â”‚         if (contractType === 'DIGITOVER') {
        â”‚   770 â”‚           setNextPrediction(overCount < underCount ? 'OVER' : 'UNDER')
        â”‚   771 â”‚           setConfidence(Math.min(95, 60 + Math.abs(overCount - underCount) * 2))
        â”‚   772 â”‚         } else {
        â”‚   773 â”‚           setNextPrediction(underCount < overCount ? 'UNDER' : 'OVER')
        â”‚   774 â”‚           setConfidence(Math.min(95, 60 + Math.abs(overCount - underCount) * 2))
        â”‚   775 â”‚         }
        â”‚   776 â”‚       } else {
        â”‚   777 â”‚         // For match/differs contracts, find least frequent digit
        â”‚   778 â”‚         const digitCounts = new Array(10).fill(0)
        â”‚   779 â”‚         lastDigits.forEach(d => digitCounts[d]++)
        â”‚   780 â”‚         const minCount = Math.min(...digitCounts)
        â”‚   781 â”‚         const leastFrequentDigit = digitCounts.indexOf(minCount)
        â”‚   782 â”‚
        â”‚   783 â”‚         setNextPrediction(leastFrequentDigit.toString())
        â”‚   784 â”‚         setConfidence(Math.min(95, 50 + (10 - minCount) * 5))
        â”‚   785 â”‚       }
        â”‚   786 â”‚     } catch (error) {
        â”‚   787 â”‚       console.error('Error in prediction:', error)
        â”‚   788 â”‚     }
        â”‚   789 â”‚   }
        â”‚   790 â”‚
        â”‚   791 â”‚   const executeTradeDecision = (tick: number) => {
        â”‚   792 â”‚     const lastDigit = tick % 10
        â”‚   793 â”‚     const timestamp = new Date().toLocaleTimeString()
        â”‚   794 â”‚
        â”‚   795 â”‚     // Simple trading logic based on prediction
        â”‚   796 â”‚     let shouldTrade = false
        â”‚   797 â”‚     let tradeType = contractType
        â”‚   798 â”‚
        â”‚   799 â”‚     if (contractType === 'DIGITEVEN' && nextPrediction === 'EVEN' && confidence > 70) {
        â”‚   800 â”‚       shouldTrade = true
        â”‚   801 â”‚     } else if (contractType === 'DIGITODD' && nextPrediction === 'ODD' && confidence > 70) {
        â”‚   802 â”‚       shouldTrade = true
        â”‚   803 â”‚         }
        â”‚   804 â”‚
        â”‚   805 â”‚     if (shouldTrade) {
        â”‚   806 â”‚       // Simulate trade execution
        â”‚   807 â”‚       const isWin = Math.random() > 0.45 // 55% win rate simulation
        â”‚   808 â”‚       const pnl = isWin ? parseFloat(stakeAmount) * 0.95 : -parseFloat(stakeAmount)
        â”‚   809 â”‚
        â”‚   810 â”‚       setTradingLog(prev => [...prev, {
        â”‚   811 â”‚         timestamp,
        â”‚   812 â”‚         action: `${tradeType} @ ${tick}`,
        â”‚   813 â”‚         result: isWin ? 'WIN' : 'LOSS',
        â”‚   814 â”‚         pnl: (pnl > 0 ? '+' : '') + pnl.toFixed(2),
        â”‚   815 â”‚         type: isWin ? 'win' : 'loss'
        â”‚   816 â”‚       }])
        â”‚   817 â”‚
        â”‚   818 â”‚       setTotalTrades(prev => prev + 1)
        â”‚   819 â”‚       setProfitLoss(prev => prev + pnl)
        â”‚   820 â”‚       setCurrentStreak(prev => isWin ? (prev > 0 ? prev + 1 : 1) : (prev < 0 ? prev - 1 : -1))
        â”‚   821 â”‚
        â”‚   822 â”‚       // Update win rate
        â”‚   823 â”‚       setWinRate(prev => {
        â”‚   824 â”‚         const wins = tradingLog.filter(log => log.type === 'win').length + (isWin ? 1 : 0)
        â”‚   825 â”‚         const total = totalTrades + 1
        â”‚   826 â”‚         return (wins / total) * 100
        â”‚   827 â”‚       })
        â”‚   828 â”‚     }
        â”‚   829 â”‚   }
        â”‚   830 â”‚
        â”‚   831 â”‚   const startTrading = () => {
        â”‚   832 â”‚     if (!isConnected) return
        â”‚   833 â”‚     setIsTrading(true)
        â”‚   834 â”‚
        â”‚   835 â”‚     setTradingLog(prev => [...prev, {
        â”‚   836 â”‚       timestamp: new Date().toLocaleTimeString(),
        â”‚   837 â”‚       action: 'TRADING STARTED',
        â”‚   838 â”‚       result: 'SYSTEM',
        â”‚   839 â”‚       pnl: '---',
        â”‚   840 â”‚       type: 'system'
        â”‚   841 â”‚     }])
        â”‚   842 â”‚   }
        â”‚   843 â”‚
        â”‚   844 â”‚   const stopTrading = () => {
        â”‚   845 â”‚     setIsTrading(false)
        â”‚   846 â”‚
        â”‚   847 â”‚     setTradingLog(prev => [...prev, {
        â”‚   848 â”‚       timestamp: new Date().toLocaleTimeString(),
        â”‚   849 â”‚       action: 'TRADING STOPPED',
        â”‚   850 â”‚       result: 'SYSTEM',
        â”‚   851 â”‚       pnl: '---',
        â”‚   852 â”‚       type: 'system'
        â”‚   853 â”‚     }])
        â”‚   854 â”‚   }
        â”‚   855 â”‚
        â”‚   856 â”‚     const executePythonCode = useCallback(async () => {
        â”‚   857 â”‚         if (!pythonCode.trim()) {
        â”‚   858 â”‚             addOutput('error', 'No Python code to execute');
        â”‚   859 â”‚             return;
        â”‚   860 â”‚         }
        â”‚   861 â”‚
        â”‚   862 â”‚         setIsExecuting(true);
        â”‚   863 â”‚         addOutput('info', 'Starting Python script execution...');
        â”‚   864 â”‚
        â”‚   865 â”‚         try {
        â”‚   866 â”‚             // In a real implementation, this would send the code to a Python backend
        â”‚   867 â”‚             // For demo purposes, we'll simulate execution
        â”‚   868 â”‚             const response = await fetch('/api/execute-python', {
        â”‚   869 â”‚                 method: 'POST',
        â”‚   870 â”‚                 headers: {
        â”‚   871 â”‚                     'Content-Type': 'application/json',
        â”‚   872 â”‚                 },
        â”‚   873 â”‚                 body: JSON.stringify({ code: pythonCode }),
        â”‚   874 â”‚             });
        â”‚   875 â”‚
        â”‚   876 â”‚             if (response.ok) {
        â”‚   877 â”‚                 const result = await response.json();
        â”‚   878 â”‚                 addOutput('success', 'Script executed successfully');
        â”‚   879 â”‚                 if (result.output) {
        â”‚   880 â”‚                     result.output.split('\n').forEach(line => {
        â”‚   881 â”‚                         if (line.trim()) {
        â”‚   882 â”‚                             addOutput('output', line);
        â”‚   883 â”‚                         }
        â”‚   884 â”‚                     });
        â”‚   885 â”‚                 }
        â”‚   886 â”‚             } else {
        â”‚   887 â”‚                 throw new Error('Failed to execute Python script');
        â”‚   888 â”‚             }
        â”‚   889 â”‚         } catch (error) {
        â”‚   890 â”‚             // Simulate Python execution for demo
        â”‚   891 â”‚             addOutput('info', 'Simulating Python script execution...');
        â”‚   892 â”‚
        â”‚   893 â”‚             setTimeout(() => {
        â”‚   894 â”‚                 addOutput('output', 'Starting auto trading script...');
        â”‚   895 â”‚                 addOutput('output', 'Market: EUR/USD - Price: 1.0850 - Action: HOLD');
        â”‚   896 â”‚                 addOutput('output', 'Market: EUR/USD - Price: 1.0865 - Action: BUY');
        â”‚   897 â”‚                 addOutput('success', 'Trade executed: {"action": "BUY", "amount": 1.0, "status": "executed"}');
        â”‚   898 â”‚                 addOutput('output', 'Auto trading script completed.');
        â”‚   899 â”‚                 setIsExecuting(false);
        â”‚   900 â”‚             }, 2000);
        â”‚   901 â”‚
        â”‚   902 â”‚             return;
        â”‚   903 â”‚         }
        â”‚   904 â”‚
        â”‚   905 â”‚         setIsExecuting(false);
        â”‚   906 â”‚     }, [pythonCode]);
        â”‚   907 â”‚
        â”‚   908 â”‚     const clearPythonCode = useCallback(() => {
        â”‚   909 â”‚         setPythonCode('');
        â”‚   910 â”‚         setPythonOutput([]);
        â”‚   911 â”‚         addOutput('info', 'Editor cleared');
        â”‚   912 â”‚     }, []);
        â”‚   913 â”‚
        â”‚   914 â”‚     const savePythonScript = useCallback(() => {
        â”‚   915 â”‚         if (!pythonCode.trim()) {
        â”‚   916 â”‚             addOutput('error', 'No code to save');
        â”‚   917 â”‚             return;
        â”‚   918 â”‚         }
        â”‚   919 â”‚
        â”‚   920 â”‚         const scriptName = prompt('Enter script name:');
        â”‚   921 â”‚         if (scriptName) {
        â”‚   922 â”‚             const newScript = {
        â”‚   923 â”‚                 name: scriptName,
        â”‚   924 â”‚                 code: pythonCode,
        â”‚   925 â”‚                 created: new Date().toISOString(),
        â”‚   926 â”‚             };
        â”‚   927 â”‚
        â”‚   928 â”‚             const updatedScripts = [...savedScripts, newScript];
        â”‚   929 â”‚             setSavedScripts(updatedScripts);
        â”‚   930 â”‚             localStorage.setItem('pythonTradingScripts', JSON.stringify(updatedScripts));
        â”‚   931 â”‚             addOutput('success', `Script '${scriptName}' saved successfully`);
        â”‚   932 â”‚         }
        â”‚   933 â”‚     }, [pythonCode, savedScripts]);
        â”‚   934 â”‚
        â”‚   935 â”‚     const loadSavedScript = useCallback((scriptName) => {
        â”‚   936 â”‚         if (!scriptName) return;
        â”‚   937 â”‚
        â”‚   938 â”‚         const script = savedScripts.find(s => s.name === scriptName);
        â”‚   939 â”‚         if (script) {
        â”‚   940 â”‚             setPythonCode(script.code);
        â”‚   941 â”‚             addOutput('info', `Loaded script: ${scriptName}`);
        â”‚   942 â”‚         }
        â”‚   943 â”‚     }, [savedScripts]);
        â”‚   944 â”‚
        â”‚   945 â”‚     const addOutput = useCallback((type, content) => {
        â”‚   946 â”‚         const newLine = {
        â”‚   947 â”‚             type,
        â”‚   948 â”‚             content,
        â”‚   949 â”‚             timestamp: new Date().toLocaleTimeString(),
        â”‚   950 â”‚         };
        â”‚   951 â”‚         setPythonOutput(prev => [...prev, newLine]);
        â”‚   952 â”‚     }, []);
        â”‚   953 â”‚
        â”‚   954 â”‚     const loadTemplate = useCallback((templateType) => {
        â”‚   955 â”‚         const templates = {
        â”‚   956 â”‚             basic_strategy: `# Basic Trading Strategy Template
        â”‚   957 â”‚ import time
        â”‚   958 â”‚ from datetime import datetime
        â”‚   959 â”‚
        â”‚   960 â”‚ def simple_trading_strategy():
        â”‚   961 â”‚     """Basic buy/sell strategy based on price movements"""
        â”‚   962 â”‚     print("Executing basic trading strategy...")
        â”‚   963 â”‚
        â”‚   964 â”‚     # Simulate market analysis
        â”‚   965 â”‚     current_price = 1.0850
        â”‚   966 â”‚     support_level = 1.0800
        â”‚   967 â”‚     resistance_level = 1.0900
        â”‚   968 â”‚
        â”‚   969 â”‚     if current_price < support_level:
        â”‚   970 â”‚         print(f"Price {current_price} below support {support_level} - BUY signal")
        â”‚   971 â”‚         return "BUY"
        â”‚   972 â”‚     elif current_price > resistance_level:
        â”‚   973 â”‚         print(f"Price {current_price} above resistance {resistance_level} - SELL signal")
        â”‚   974 â”‚         return "SELL"
        â”‚   975 â”‚     else:
        â”‚   976 â”‚         print(f"Price {current_price} in range - HOLD")
        â”‚   977 â”‚         return "HOLD"
        â”‚   978 â”‚
        â”‚   979 â”‚ if __name__ == "__main__":
        â”‚   980 â”‚     action = simple_trading_strategy()
        â”‚   981 â”‚     print(f"Trading action: {action}")`,
        â”‚   982 â”‚
        â”‚   983 â”‚             moving_average: `# Moving Average Strategy Template
        â”‚   984 â”‚ import numpy as np
        â”‚   985 â”‚ from datetime import datetime
        â”‚   986 â”‚
        â”‚   987 â”‚ def moving_average_strategy(prices, short_period=5, long_period=20):
        â”‚   988 â”‚     """Moving average crossover strategy"""
        â”‚   989 â”‚     print("Calculating moving averages...")
        â”‚   990 â”‚
        â”‚   991 â”‚     # Sample price data
        â”‚   992 â”‚     prices = [1.0800, 1.0820, 1.0850, 1.0840, 1.0860, 1.0880, 1.0870, 1.0890]
        â”‚   993 â”‚
        â”‚   994 â”‚     if len(prices) < long_period:
        â”‚   995 â”‚         print("Not enough data for moving average calculation")
        â”‚   996 â”‚         return "HOLD"
        â”‚   997 â”‚
        â”‚   998 â”‚     short_ma = sum(prices[-short_period:]) / short_period
        â”‚   999 â”‚     long_ma = sum(prices[-long_period:]) / long_period
        â”‚  1000 â”‚
        â”‚  1001 â”‚     print(f"Short MA ({short_period}): {short_ma:.4f}")
        â”‚  1002 â”‚     print(f"Long MA ({long_period}): {long_ma:.4f}")
        â”‚  1003 â”‚
        â”‚  1004 â”‚     if short_ma > long_ma:
        â”‚  1005 â”‚         print("Short MA above Long MA - BUY signal")
        â”‚  1006 â”‚         return "BUY"
        â”‚  1007 â”‚     elif short_ma < long_ma:
        â”‚  1008 â”‚         print("Short MA below Long MA - SELL signal")
        â”‚  1009 â”‚         return "SELL"
        â”‚  1010 â”‚     else:
        â”‚  1011 â”‚         return "HOLD"
        â”‚  1012 â”‚
        â”‚  1013 â”‚ if __name__ == "__main__":
        â”‚  1014 â”‚     action = moving_average_strategy([])
        â”‚  1015 â”‚     print(f"Trading action: {action}")`,
        â”‚  1016 â”‚
        â”‚  1017 â”‚             risk_management: `# Risk Management Template
        â”‚  1018 â”‚ def calculate_position_size(account_balance, risk_percent, stop_loss_pips):
        â”‚  1019 â”‚     """Calculate position size based on risk management rules"""
        â”‚  1020 â”‚     risk_amount = account_balance * (risk_percent / 100)
        â”‚  1021 â”‚     position_size = risk_amount / stop_loss_pips
        â”‚  1022 â”‚
        â”‚  1023 â”‚     print(f"Account Balance: ${account_balance}")
        â”‚  1024 â”‚     print(f"Risk Percentage: {risk_percent}%")
        â”‚  1025 â”‚     print(f"Risk Amount: ${risk_amount}")
        â”‚  1026 â”‚     print(f"Stop Loss: {stop_loss_pips} pips")
        â”‚  1027 â”‚     print(f"Calculated Position Size: {position_size}")
        â”‚  1028 â”‚
        â”‚  1029 â”‚     return position_size
        â”‚  1030 â”‚
        â”‚  1031 â”‚ def risk_management_check(current_trades, max_trades, daily_loss_limit):
        â”‚  1032 â”‚     """Check risk management parameters"""
        â”‚  1033 â”‚     print("Performing risk management checks...")
        â”‚  1034 â”‚
        â”‚  1035 â”‚     if current_trades >= max_trades:
        â”‚  1036 â”‚         print(f"Maximum trades ({max_trades}) reached for today")
        â”‚  1037 â”‚         return False
        â”‚  1038 â”‚
        â”‚  1039 â”‚     # Simulate daily P&L check
        â”‚  1040 â”‚     daily_pnl = -150  # Example loss
        â”‚  1041 â”‚     if daily_pnl <= -daily_loss_limit:
        â”‚  1042 â”‚         print(f"Daily loss limit (${daily_loss_limit}) reached")
        â”‚  1043 â”‚         return False
        â”‚  1044 â”‚
        â”‚  1045 â”‚     print("Risk management checks passed")
        â”‚  1046 â”‚     return True
        â”‚  1047 â”‚
        â”‚  1048 â”‚ if __name__ == "__main__":
        â”‚  1049 â”‚     position_size = calculate_position_size(10000, 2, 50)
        â”‚  1050 â”‚     can_trade = risk_management_check(3, 5, 200)
        â”‚  1051 â”‚     print(f"Can place trade: {can_trade}")`,
        â”‚  1052 â”‚
        â”‚  1053 â”‚             api_integration: `# API Integration Template
        â”‚  1054 â”‚ import json
        â”‚  1055 â”‚ import time
        â”‚  1056 â”‚ from datetime import datetime
        â”‚  1057 â”‚
        â”‚  1058 â”‚ class TradingAPI:
        â”‚  1059 â”‚     """Mock trading API integration"""
        â”‚  1060 â”‚
        â”‚  1061 â”‚     def __init__(self, api_key, demo_mode=True):
        â”‚  1062 â”‚         self.api_key = api_key
        â”‚  1063 â”‚         self.demo_mode = demo_mode
        â”‚  1064 â”‚         print(f"Initialized Trading API in {'demo' if demo_mode else 'live'} mode")
        â”‚  1065 â”‚
        â”‚  1066 â”‚     def get_market_data(self, symbol):
        â”‚  1067 â”‚         """Fetch real-time market data"""
        â”‚  1068 â”‚         # Mock API response
        â”‚  1069 â”‚         data = {
        â”‚  1070 â”‚             'symbol': symbol,
        â”‚  1071 â”‚             'bid': 1.0845,
        â”‚  1072 â”‚             'ask': 1.0847,
        â”‚  1073 â”‚             'timestamp': datetime.now().isoformat()
        â”‚  1074 â”‚         }
        â”‚  1075 â”‚         print(f"Market data for {symbol}: {data}")
        â”‚  1076 â”‚         return data
        â”‚  1077 â”‚
        â”‚  1078 â”‚     def place_order(self, symbol, order_type, volume):
        â”‚  1079 â”‚         """Place trading order"""
        â”‚  1080 â”‚         order = {
        â”‚  1081 â”‚             'order_id': f"ORD_{int(time.time())}",
        â”‚  1082 â”‚             'symbol': symbol,
        â”‚  1083 â”‚             'type': order_type,
        â”‚  1084 â”‚             'volume': volume,
        â”‚  1085 â”‚             'status': 'filled' if self.demo_mode else 'pending',
        â”‚  1086 â”‚             'timestamp': datetime.now().isoformat()
        â”‚  1087 â”‚         }
        â”‚  1088 â”‚         print(f"Order placed: {order}")
        â”‚  1089 â”‚         return order
        â”‚  1090 â”‚
        â”‚  1091 â”‚     def get_account_info(self):
        â”‚  1092 â”‚         """Get account information"""
        â”‚  1093 â”‚         account = {
        â”‚  1094 â”‚             'balance': 10000.00,
        â”‚  1095 â”‚             'equity': 10150.00,
        â”‚  1096 â”‚             'margin': 50.00,
        â”‚  1097 â”‚             'free_margin': 10100.00
        â”‚  1098 â”‚         }
        â”‚  1099 â”‚         print(f"Account info: {account}")
        â”‚  1100 â”‚         return account
        â”‚  1101 â”‚
        â”‚  1102 â”‚ def automated_trading():
        â”‚  1103 â”‚     """Main automated trading function"""
        â”‚  1104 â”‚     api = TradingAPI("your_api_key_here", demo_mode=True)
        â”‚  1105 â”‚
        â”‚  1106 â”‚     # Get account info
        â”‚  1107 â”‚     account = api.get_account_info()
        â”‚  1108 â”‚
        â”‚  1109 â”‚     # Analyze market
        â”‚  1110 â”‚     market_data = api.get_market_data("EURUSD")
        â”‚  1111 â”‚
        â”‚  1112 â”‚     # Simple trading logic
        â”‚  1113 â”‚     if market_data['bid'] > 1.0850:
        â”‚  1114 â”‚         order = api.place_order("EURUSD", "SELL", 0.1)
        â”‚  1115 â”‚         print(f"Sell order executed: {order['order_id']}")
        â”‚  1116 â”‚     elif market_data['ask'] < 1.0840:
        â”‚  1117 â”‚         order = api.place_order("EURUSD", "BUY", 0.1)
        â”‚  1118 â”‚         print(f"Buy order executed: {order['order_id']}")
        â”‚  1119 â”‚     else:
        â”‚  1120 â”‚         print("No trading signal - waiting...")
        â”‚  1121 â”‚
        â”‚  1122 â”‚ if __name__ == "__main__":
        â”‚  1123 â”‚     automated_trading()`
        â”‚  1124 â”‚         };
        â”‚  1125 â”‚
        â”‚  1126 â”‚         if (templates[templateType]) {
        â”‚  1127 â”‚             setPythonCode(templates[templateType]);
        â”‚  1128 â”‚             addOutput('info', `Loaded ${templateType.replace('_', ' ')} template`);
        â”‚  1129 â”‚         }
        â”‚  1130 â”‚     }, [addOutput]);
        â”‚  1131 â”‚
        â”‚  1132 â”‚     // Load saved scripts on component mount
        â”‚  1133 â”‚     useEffect(() => {
        â”‚  1134 â”‚         const saved = localStorage.getItem('pythonTradingScripts');
        â”‚  1135 â”‚         if (saved) {
        â”‚  1136 â”‚             try {
        â”‚  1137 â”‚                 setSavedScripts(JSON.parse(saved));
        â”‚  1138 â”‚             } catch (error) {
        â”‚  1139 â”‚                 console.error('Error loading saved scripts:', error);
        â”‚  1140 â”‚             }
        â”‚  1141 â”‚         }
        â”‚  1142 â”‚     }, []);
        â”‚  1143 â”‚
        â”‚  1144 â”‚     useEffect(() => {
        â”‚  1145 â”‚       if (active_tab === 'auto-trades') {
        â”‚  1146 â”‚         // Auto trades specific logic can go here
        â”‚  1147 â”‚       }
        â”‚  1148 â”‚
        â”‚  1149 â”‚       // Cleanup WebSocket connection on unmount
        â”‚  1150 â”‚       return () => {
        â”‚  1151 â”‚         if (websocket) {
        â”‚  1152 â”‚           websocket.close()
        â”‚  1153 â”‚           setWebsocket(null)
        â”‚  1154 â”‚           setIsConnected(false)
        â”‚  1155 â”‚         }
        â”‚  1156 â”‚       }
        â”‚  1157 â”‚     }, [active_tab])
        â”‚  1158 â”‚
        â”‚  1159 â”‚     // Reconnect when volatility changes
        â”‚  1160 â”‚     useEffect(() => {
        â”‚  1161 â”‚       if (isConnected && websocket && websocket.readyState === WebSocket.OPEN) {
        â”‚  1162 â”‚         console.log('Volatility changed to:', selectedIndex, 'Getting data...')
        â”‚  1163 â”‚
        â”‚  1164 â”‚         // Unsubscribe from all ticks first
        â”‚  1165 â”‚         websocket.send(JSON.stringify({
        â”‚  1166 â”‚           forget_all: "ticks",
        â”‚  1167 â”‚           req_id: 99
        â”‚  1168 â”‚         }))
        â”‚  1169 â”‚
        â”‚  1170 â”‚         // Get historical data and subscribe to new symbol after a short delay
        â”‚  1171 â”‚         setTimeout(() => {
        â”‚  1172 â”‚           // Check if we already have data for this volatility
        â”‚  1173 â”‚           const currentVolatilityHistory = tickHistory[selectedIndex]
        â”‚  1174 â”‚
        â”‚  1175 â”‚           if (!currentVolatilityHistory || currentVolatilityHistory.length === 0) {
        â”‚  1176 â”‚             // Request historical ticks if we don't have them
        â”‚  1177 â”‚             const historyRequest = {
        â”‚  1178 â”‚               ticks_history: selectedIndex,
        â”‚  1179 â”‚               count: 5000,
        â”‚  1180 â”‚               end: 'latest',
        â”‚  1181 â”‚               style: 'ticks',
        â”‚  1182 â”‚               req_id: Date.now()
        â”‚  1183 â”‚             }
        â”‚  1184 â”‚             console.log('Requesting historical ticks for new volatility:', historyRequest)
        â”‚  1185 â”‚             websocket.send(JSON.stringify(historyRequest))
        â”‚  1186 â”‚           } else {
        â”‚  1187 â”‚             // Use existing data for immediate display
        â”‚  1188 â”‚             calculateDigitDistribution(currentVolatilityHistory)
        â”‚  1189 â”‚             analyzePatterns(currentVolatilityHistory)
        â”‚  1190 â”‚             makePrediction(currentVolatilityHistory)
        â”‚  1191 â”‚             calculateContractProbabilities(currentVolatilityHistory)
        â”‚  1192 â”‚
        â”‚  1193 â”‚             if (currentVolatilityHistory.length > 0) {
        â”‚  1194 â”‚               const latestPrice = currentVolatilityHistory[currentVolatilityHistory.length - 1]
        â”‚  1195 â”‚               setCurrentPrice(latestPrice.toFixed(5))
        â”‚  1196 â”‚             }
        â”‚  1197 â”‚           }
        â”‚  1198 â”‚
        â”‚  1199 â”‚           // Subscribe to real-time ticks
        â”‚  1200 â”‚           const newTickRequest = {
        â”‚  1201 â”‚             ticks: selectedIndex,
        â”‚  1202 â”‚             subscribe: 1,
        â”‚  1203 â”‚             req_id: Date.now() + 1
        â”‚  1204 â”‚           }
        â”‚  1205 â”‚           console.log('Sending new tick subscription:', newTickRequest)
        â”‚  1206 â”‚           websocket.send(JSON.stringify(newTickRequest))
        â”‚  1207 â”‚         }, 500)
        â”‚  1208 â”‚
        â”‚  1209 â”‚         setCurrentPrice('Loading ' + selectedIndex + ' data...')
        â”‚  1210 â”‚         setCurrentTick(null)
        â”‚  1211 â”‚       } else if (!isConnected) {
        â”‚  1212 â”‚         // If not connected, reset display
        â”‚  1213 â”‚         setCurrentPrice('Not connected - Select ' + selectedIndex)
        â”‚  1214 â”‚         setCurrentTick(null)
        â”‚  1215 â”‚       }
        â”‚  1216 â”‚     }, [selectedIndex, isConnected, websocket, tickHistory])
        â”‚  1217 â”‚
        â”‚  1218 â”‚
        â”‚  1219 â”‚     const { client } = useStore();
        â”‚  1220 â”‚     const isConnected = client?.is_logged_in && websocket?.readyState === WebSocket.OPEN;
        â”‚       Â·           â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€
        â”‚       Â·                â•°â”€â”€ `isConnected` redefined here
        â”‚  1221 â”‚
        â”‚  1222 â”‚     const showRunPanel = [DBOT_TABS.BOT_BUILDER, DBOT_TABS.TRADING_HUB, DBOT_TABS.ANALYSIS_TOOL, DBOT_TABS.CHART, DBOT_TABS.SIGNALS].includes(active_tab);
        â”‚       â•°â”€â”€â”€â”€
        â”‚
Fix error, click outside, or press Esc to close the overlay.

Disable overlay by setting Rsbuild's dev.client.overlay config to false.