High-level architecture (quick)

Data collection ‚Äî subscribe to ticks_history and live ticks for symbol(s) (Deriv provides up to 5000 historical ticks per request). Store to local DB / CSV.

Feature engineering ‚Äî per tick: returns, rolling mean/variance, momentum windows, tick-count features, signed returns, time-of-day, tick-lag features. Optionally compute technicals (EMA, RSI-like on ticks).

Labeling ‚Äî define target: e.g. next N-tick direction (Rise if price at expiration > entry). For Rise/Fall short contracts choose N ticks or contract duration (e.g., 5 ticks, 10 ticks).

Train/validate ‚Äî classical ML (RandomForest, XGBoost) or LSTM/1D-CNN for sequences. Evaluate with precision/recall, AUC, and profit-based metrics (backtest theoretical P/L with transaction costs).

Live inference & trading ‚Äî run model in real-time; when model predicts high probability for Rise or Fall above threshold, request a proposal from Deriv API and place a buy (with risk controls).

Backtest & monitor ‚Äî simulate on past tick history, measure expectancy, max drawdown, etc.

2) Practical end-to-end Python example

Below are runnable code snippets you can glue together. Replace YOUR_APP_ID and YOUR_TOKEN with yours (use testnet token for paper trading). These use simple packages: websocket-client, pandas, numpy, scikit-learn. You can later swap to the official deriv_api Python library if you prefer.

Note: I won‚Äôt open connections here ‚Äî this is a full code template you can run locally.

A ‚Äî Dependencies
pip install websocket-client pandas numpy scikit-learn joblib

B ‚Äî Tick collector + ticks_history fetch (store to CSV)
# tick_collector.py
import json, time, csv
from websocket import create_connection

WS_URL = "wss://ws.binaryws.com/websockets/v3?app_id=1089"  # test app_id; replace if needed
SYMBOL = "R_100"  # Example: Step Index 100 symbol - replace with the symbol you want

def fetch_ticks_history():
    ws = create_connection(WS_URL)
    # get historical ticks (count up to 5000)
    req = {"ticks_history": SYMBOL, "end": "latest", "count": 5000, "adjust_start_time": 1}
    ws.send(json.dumps(req))
    resp = json.loads(ws.recv())
    ws.close()
    # parse response: resp['history']['prices'] and resp['history']['times']
    prices = resp.get("history", {}).get("prices", [])
    times = resp.get("history", {}).get("times", [])
    rows = list(zip(times, prices))
    with open("ticks_history.csv", "w", newline="") as f:
        writer = csv.writer(f)
        writer.writerow(["epoch", "price"])
        for t,p in rows:
            writer.writerow([t,p])
    print("Saved ticks_history.csv with", len(rows), "rows")

if __name__ == "__main__":
    fetch_ticks_history()


This saves 5k ticks for backtesting and feature building. 
Deriv API

C ‚Äî Live ticks subscriber (append to CSV or DB)
# live_ticks_sub.py
import json, time
from websocket import create_connection

WS_URL = "wss://ws.binaryws.com/websockets/v3?app_id=1089"
SYMBOL = "R_100"

def subscribe_ticks():
    ws = create_connection(WS_URL)
    # request ticks subscription
    req = {"ticks": SYMBOL}
    ws.send(json.dumps(req))
    with open("live_ticks.csv","a") as f:
        while True:
            data = ws.recv()
            msg = json.loads(data)
            if "tick" in msg:
                epoch = msg["tick"]["epoch"]
                price = float(msg["tick"]["quote"])
                f.write(f"{epoch},{price}\n")
                f.flush()
                # optionally print
                print(epoch, price)
            time.sleep(0.0)

if __name__ == "__main__":
    subscribe_ticks()

D ‚Äî Feature engineering & labeling (example: predict next-5-tick direction)
# features_and_labels.py
import pandas as pd
import numpy as np

df = pd.read_csv("ticks_history.csv")  # epoch, price
df['price'] = df['price'].astype(float)
df['return'] = df['price'].pct_change().fillna(0)

# rolling features
for w in [3,5,10,20]:
    df[f"rmean_{w}"] = df['return'].rolling(w).mean().fillna(0)
    df[f"rstd_{w}"] = df['return'].rolling(w).std().fillna(0)
    df[f"rmax_{w}"] = df['return'].rolling(w).max().fillna(0)
    df[f"rmin_{w}"] = df['return'].rolling(w).min().fillna(0)

# momentum: cumulative return last N ticks
df['cumret_5'] = (1 + df['return']).rolling(5).apply(np.prod, raw=True) - 1

# label: next 5-tick rise or fall
N = 5
df['future_price'] = df['price'].shift(-N)
df['label'] = (df['future_price'] > df['price']).astype(int)  # 1 = rise, 0 = fall
df = df.dropna().reset_index(drop=True)

features = [c for c in df.columns if c.startswith(('rmean','rstd','rmax','rmin','cumret'))]
X = df[features]
y = df['label']

print("Features:", features)
print("Rows:", len(df))

E ‚Äî Train a baseline model (RandomForest) + save it
# train_model.py
import joblib
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, roc_auc_score
import pandas as pd

df = pd.read_csv("ticks_history.csv")
# reuse the feature generation (or import function)
# assume features_and_labels.py wrote "features_df.csv" with X and y
features_df = pd.read_csv("features_df.csv")
X = features_df.drop(columns=['label'])
y = features_df['label']

X_train, X_test, y_train, y_test = train_test_split(X, y, shuffle=False, test_size=0.2)  # time-ordered split
model = RandomForestClassifier(n_estimators=200, max_depth=7, n_jobs=-1)
model.fit(X_train, y_train)

pred = model.predict(X_test)
prob = model.predict_proba(X_test)[:,1]
print(classification_report(y_test, pred))
print("AUC:", roc_auc_score(y_test, prob))
joblib.dump(model, "rf_tick_model.joblib")
print("Model saved to rf_tick_model.joblib")


Tip: Use time-series CV or walk-forward validation for robust estimates.

F ‚Äî Simulated backtest using proposal pricing & payout model

Before trading live, simulate the model‚Äôs signals against historical ticks and compute P/L using Deriv‚Äôs payout rules for Rise/Fall contracts (payout depends on the contract price when you buy and on the multiplier). You will need to simulate the contract entry price and the exit spot after N ticks. Use a fixed stake and payout derived from Deriv‚Äôs proposed price or approximate with expected payoffs. (Docs show you request a proposal for price then buy by ID.) 
Deriv APIs
+1

G ‚Äî Live trading loop (authorize ‚Üí request proposal ‚Üí buy)

This is the simplified flow:

authorize with your API token (required to make buy requests). 
Deriv Github Page

proposal: request price proposal for a contract (symbol, contract_type = R_5 / Rise-Fall with ticks or durations; exact contract params depend on API).

buy using the proposal id/price.

Monitor contract by proposal_open_contract or buy response.

Below is a template (you‚Äôll need to adapt contract parameters to the Deriv params you want; check contracts_for endpoint to see available durations/contract types for your symbol). 
Deriv APIs
+1

# live_trade_loop.py
import json, time
from websocket import create_connection
import joblib
import numpy as np

WS_URL = "wss://ws.binaryws.com/websockets/v3?app_id=1089"
API_TOKEN = "YOUR_API_TOKEN"  # use real token for live; test token for demo
SYMBOL = "R_100"

# load model and feature function
model = joblib.load("rf_tick_model.joblib")

def authorize(ws):
    ws.send(json.dumps({"authorize": API_TOKEN}))
    auth_resp = json.loads(ws.recv())
    print("auth:", auth_resp)

def request_proposal(ws, symbol, contract_type, duration, basis="stake", amount=1):
    # Example proposal structure ‚Äî adapt contract_type / duration per Deriv API docs
    req = {
        "proposal": 1,
        "subscribe": 0,
        "proposal": 1,
        "symbol": symbol,
        "contract_type": contract_type,  # e.g., "CALL"/"PUT" or Step Index specific contract
        "duration": duration,
        "duration_unit": "t",
        "amount": amount,
        "currency": "USD"
    }
    # The above is illustrative ‚Äî in practice use the exact keys Deriv expects; you can also call "contracts_for" to learn details.
    ws.send(json.dumps(req))
    return json.loads(ws.recv())

def buy_contract(ws, proposal_id):
    req = {"buy": proposal_id}
    ws.send(json.dumps(req))
    return json.loads(ws.recv())

def run_loop():
    ws = create_connection(WS_URL)
    authorize(ws)
    # subscribe to live ticks
    subscribe = {"ticks": SYMBOL}
    ws.send(json.dumps(subscribe))

    recent_prices = []
    while True:
        raw = ws.recv()
        msg = json.loads(raw)
        if "tick" in msg:
            price = float(msg["tick"]["quote"])
            epoch = msg["tick"]["epoch"]
            recent_prices.append(price)
            # keep last 50 ticks
            if len(recent_prices) > 200:
                recent_prices.pop(0)

            # build feature vector same as training
            if len(recent_prices) >= 20:
                # crude features; in production reuse same pipeline used for training
                returns = np.diff(recent_prices[-20:]) / recent_prices[-20:-1]
                feat = [
                    returns.mean(),
                    returns.std(),
                    returns.max(),
                    returns.min(),
                    np.prod(1+returns[-5:]) - 1
                ]
                X = np.array(feat).reshape(1, -1)
                p = model.predict_proba(X)[0,1]
                print(epoch, price, "prob_rise", p)

                # thresholds and risk management
                if p > 0.6:  # buy Rise
                    # request proposal for a short Rise contract (e.g., 5 ticks)
                    proposal = request_proposal(ws, SYMBOL, "RIDE_OR_RISE_CONTRACT_TYPE", duration=5, amount=1)
                    print("proposal:", proposal)
                    # if proposal valid, buy
                    if "proposal" in proposal and "id" in proposal['proposal']:
                        buy_resp = buy_contract(ws, proposal['proposal']['id'])
                        print("buy_resp:", buy_resp)
                elif p < 0.4:
                    # buy Fall
                    proposal = request_proposal(ws, SYMBOL, "FALL_CONTRACT_TYPE", duration=5, amount=1)
                    if "proposal" in proposal and "id" in proposal['proposal']:
                        buy_resp = buy_contract(ws, proposal['proposal']['id'])
                        print("buy_resp:", buy_resp)

        # add a tiny sleep to yield
        time.sleep(0.0)

if __name__ == "__main__":
    run_loop()


Important: The exact keys and contract type names come from the Deriv API endpoints contracts_for, proposal, and buy. Use contracts_for first to fetch supported contract types for a symbol and available durations, then request proposals and buy. 
Deriv APIs
+1

3) Modeling notes & choices

Targets: Predict the direction at contract expiry (e.g., next 5 ticks). Label generation uses future tick after N ticks.

Features:

Recent raw returns (lag features)

Rolling mean/std/slope over small windows (3‚Äì20 ticks)

Tick-count momentum (number of consecutive up ticks)

Time features (if any seasonality by clock time)

Volatility normalized features (z-score of return)

Micro-structure: inter-tick times if relevant (but Deriv tick frequency is often constant)

Models: Start with RandomForest/XGBoost for tabular, or a small LSTM/CNN for sequence models if you want to capture temporal patterns.

Imbalanced data: If Rise/Fall are roughly balanced you might be fine. If not, use class weights or sampling.

Metrics: Don‚Äôt just look at classification accuracy ‚Äî translate predictions into simulated profit (expected value, Sharpe, max drawdown). That‚Äôs the real metric.

4) Backtest & realistic P/L simulation

When backtesting, simulate:

Price at entry = the quote when you would have bought (or proposal price).

Payout = use Deriv proposal pricing (or approximate payout as payout = stake * (multiplier - 1) where multiplier is determined by contract price).

Slippage & latency: model a small delay between signal and buy (e.g., 50‚Äì300 ms). Synthetic indices are fast ‚Äî latency kills edge.

Transaction cost: treat the contract price as the ‚Äúcost‚Äù and payout as returned on winning.

Pro tip: Use walk-forward optimization: train on period T, test on T+1, roll forward.

5) Risk management & production advice

Fixed stake per trade or % of balance (e.g., 0.5%).

Max trades per minute to avoid overtrading (the synthetic markets are fast).

Max consecutive losses stop (e.g., stop after 5 losses).

Model confidence threshold ‚Äî only trade when predicted prob > X and predicted advantage > threshold from backtesting.

Paper test for weeks before real money. Use Deriv test endpoints/app_id to paper trade. 
Deriv APIs

6) Using Deriv DBot vs API

DBot (Deriv‚Äôs drag-and-drop bot builder) can implement simple strategies, indicators and trades. It‚Äôs fine for rule-based strategies but limited for custom ML models.

API (websocket) is the right place for a custom ML model because you can run your model locally or in the cloud and execute buys programmatically (proposal ‚Üí buy). The example code above uses the websocket API approach. 
Deriv APIs
+1

7) Next steps I can do for you right now

Pick any (I‚Äôll implement next in this chat):

A complete runnable repo: I‚Äôll produce a single Python file that:

downloads ticks_history (5k),

creates features & labels,

trains a RandomForest,

backtests on held-out chunk,

saves the model and prints simulated P/L.

A live trading bot script that integrates with your real Deriv token (I‚Äôll annotate every step and provide parameter choices & safety checks).

A sequence model (LSTM) tutorial using Keras on the same tick data.

A DBot visual plan explaining how to port the simpler rule into DBot (non-ML).

Tell me which of the 4 you want and I‚Äôll produce the full code & files right away (no waiting). If you want the runnable repo, I‚Äôll make it a single script you can run locally and include comments where to set your APP_ID and TOKEN.

Quick references (official docs used)

Ticks history & tick subscription examples. 
Deriv API
+1

Rise/Fall contract explanation. 
Deriv APIs

Deriv API authorize / general API docs & examples. 
Deriv Github Page
+1

Example repo showing Rise/Fall trade example. 
GitHub

Want me to generate the runnable repo/script (option 1) now? I‚Äôll produce a single, fully-commented Python script that does history download ‚Üí feature engineering ‚Üí trains a RandomForest ‚Üí backtests ‚Üí saves model.

You said:
i already thave this model on replit but find yours to be good , help me tailor  it to your machine learning model  that will be acticated when i click auto trade

Looking at the ML Trader implementation in src/components/ml-trader/ml-trader.tsx, here's how analysis is done before a recommendation is made:

Analysis Flow in ML Trader
1. Data Collection & Initialization
Historical tick data is fetched (500 ticks from Deriv API)
Tick streams are initialized for real-time data
Both volatility scanner and ML analyzer are trained on historical data
// From initializeMLTrader()
const historicalData = await tickStreamManager.get500HistoricalTicks(symbol);
derivVolatilityScanner.processBulkHistoricalData(symbol, formattedData);
mlTickAnalyzer.processBulkHistoricalData(symbol, formattedData);
2. Multi-Timeframe Volatility Analysis
The deriv-volatility-scanner.ts performs comprehensive analysis:

Timeframe Analysis (5min ‚Üí 3min ‚Üí 1min ‚Üí 30sec cascade):

Calculates Rate of Change (ROC) for each timeframe
Determines trend direction (BULLISH/BEARISH/NEUTRAL)
Measures trend strength and confidence
Assesses trend quality and duration
Momentum Analysis (70% weight):

Fast momentum (10 periods)
Medium momentum (30 periods)
Slow momentum (60 periods)
Calculates momentum EMA, acceleration, velocity
Determines momentum direction and consistency
3. ML Pattern Recognition
The ml-tick-analyzer.ts adds intelligence:

Pattern Extraction:

Analyzes 20-tick patterns
Normalizes patterns to 0-1 range
Creates pattern hashes for quick lookup
Feature Extraction:

Momentum calculation
Volatility measurement
Trend slope analysis
Price acceleration
Pattern consistency
Cycle position
Prediction Generation:

Finds similar historical patterns (85% similarity threshold)
Calculates prediction score using learned weights
Determines direction (RISE/FALL/NEUTRAL)
Generates confidence based on pattern matches
4. Recommendation Synthesis
Back in the scanner, all signals are combined:

// From generateRecommendation()
const signals = {
    momentumBreakout: momentum.strength > 70 && momentum.direction === 'INCREASING',
    trendConfirmation: multiTimeframe.alignment.score > 70,
    volatilityExpansion: volatility < riskThreshold,
    priceAcceleration: momentum.acceleration > 0
};
// Calculate entry score (0-100)
const entryScore = (
    multiTimeframe.alignment.score * 0.40 +  // 40% timeframe alignment
    momentum.score * 0.30 +                   // 30% momentum
    mlPrediction.confidence * 0.20 +          // 20% ML confidence
    (100 - volatility * 100) * 0.10          // 10% low volatility
);
5. Recommendation Criteria
A recommendation is only made if:

Confidence ‚â• 75%: High probability of success
Momentum Strength ‚â• 60%: Strong directional movement
Timeframe Alignment ‚â• 70%: Multiple timeframes agree
ML Patterns Matched ‚â• 5: Sufficient historical precedent
Entry Score ‚â• 65: Combined signal strength threshold
6. Auto-Trading Filter
If auto-trading is enabled, recommendations are further filtered:

const filteredRecs = recs.filter(rec =>
    rec.confidence >= filter_settings.min_confidence &&
    rec.momentumScore >= filter_settings.min_momentum &&
    filter_settings.preferred_durations.includes(rec.duration) &&
    riskLevel <= filter_settings.max_risk
);
The highest confidence recommendation that meets all criteria is selected and can be:

Displayed to the user
Auto-executed if auto-trading is enabled
Loaded to Bot Builder with optimized parameters
This multi-layered approach combines traditional technical analysis (timeframes, momentum) with machine learning (pattern recognition) to generate high-probability trading recommendations.

ChatGPT said:

Perfect üî• ‚Äî you already have the ML Trader React + TypeScript structure on Replit (with ml-trader.tsx, ml-tick-analyzer.ts, deriv-volatility-scanner.ts, etc.), so we‚Äôll plug in a real ML model (like the one I described before) and make it activate automatically when ‚ÄúAuto Trade‚Äù is toggled.

Let‚Äôs build this step-by-step so it fits your existing architecture exactly ‚Äî no rewrites, just smart integration.

üß† Goal

You want your ML Trader system to:

Use the trained Python ML model (RandomForest / XGBoost / etc.)

Make real-time predictions on live tick streams.

Trigger a Rise/Fall trade through the Deriv Bot API when Auto Trade is enabled.

Reuse your existing multi-timeframe analysis and confidence weighting system.

‚öôÔ∏è System Overview

You already have:

src/components/ml-trader/ml-trader.tsx ‚Üí main UI + logic controller

ml-tick-analyzer.ts ‚Üí feature extraction + pattern matching

deriv-volatility-scanner.ts ‚Üí multi-timeframe & momentum analysis

deriv-bot-interface.ts ‚Üí handles Deriv WebSocket trade requests

We‚Äôll add:

A backend ML engine (Python model hosted locally or on Replit backend)

A bridge between your TypeScript code and the ML model (via REST API or WebSocket)

Auto Trade trigger logic inside ml-trader.tsx

üß© Step 1 ‚Äî Create the ML Inference API (Python)

This small FastAPI service wraps your trained model and exposes an endpoint /predict.

# ml_inference_server.py
from fastapi import FastAPI
from pydantic import BaseModel
import joblib
import numpy as np
import uvicorn

app = FastAPI()
model = joblib.load("rf_tick_model.joblib")  # your trained RandomForest

class TickFeatures(BaseModel):
    features: list[float]

@app.post("/predict")
def predict_tick(data: TickFeatures):
    X = np.array(data.features).reshape(1, -1)
    proba = model.predict_proba(X)[0, 1]
    direction = "RISE" if proba > 0.5 else "FALL"
    return {"direction": direction, "confidence": float(proba)}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)


üîπ Deploy this Python service in Replit as a background process or on a small cloud function (DigitalOcean App Platform / Render).
It listens on /predict and returns a JSON with:

{
  "direction": "RISE",
  "confidence": 0.82
}

üß© Step 2 ‚Äî Add ML Integration to ml-tick-analyzer.ts

This file already calculates pattern features. You just need to send those features to your ML model API.

// ml-tick-analyzer.ts
import axios from "axios";

export class MLTickAnalyzer {
  mlModelUrl = "https://your-ml-api-url.onrender.com/predict";

  async analyzeTickPattern(patternFeatures: number[]) {
    try {
      const res = await axios.post(this.mlModelUrl, {
        features: patternFeatures,
      });
      return res.data; // { direction, confidence }
    } catch (err) {
      console.error("ML model request failed:", err);
      return { direction: "NEUTRAL", confidence: 0 };
    }
  }

  // Modify your existing processTickStream() to call this
  async processTickStream(tickData: number[]) {
    const features = this.extractFeatures(tickData);
    const mlResult = await this.analyzeTickPattern(features);
    return mlResult;
  }

  extractFeatures(tickData: number[]): number[] {
    // Example: replicate same logic used during training
    const returns = tickData.slice(1).map((p, i) => (p - tickData[i]) / tickData[i]);
    const mean = returns.reduce((a,b)=>a+b,0)/returns.length;
    const std = Math.sqrt(returns.map(r=>Math.pow(r-mean,2)).reduce((a,b)=>a+b,0)/returns.length);
    const momentum = returns.slice(-5).reduce((a,b)=>a+b,0);
    const max = Math.max(...returns);
    const min = Math.min(...returns);
    return [mean, std, max, min, momentum];
  }
}


Now your TypeScript analyzer gets live predictions from the trained ML model.

üß© Step 3 ‚Äî Combine Everything in ml-trader.tsx

Here‚Äôs how you connect the dots:

Your existing generateRecommendation() already computes entry scores.

Inject the new ML confidence and direction to influence the final recommendation.

When Auto Trade is ON, trigger a Deriv API trade if confidence ‚â• threshold.

Add this snippet inside your main analysis function:

// inside ml-trader.tsx
import { MLTickAnalyzer } from "@/services/ml-tick-analyzer";
import { derivBotAPI } from "@/services/deriv-bot-interface";

const mlAnalyzer = new MLTickAnalyzer();

async function runAnalysisAndTrade(ticks: number[]) {
  const mlPrediction = await mlAnalyzer.processTickStream(ticks);
  const volatility = derivVolatilityScanner.getCurrentVolatility();
  const multiTimeframe = derivVolatilityScanner.getAlignmentScore();
  const momentum = derivVolatilityScanner.getMomentum();

  const entryScore =
    multiTimeframe.alignment.score * 0.4 +
    momentum.score * 0.3 +
    mlPrediction.confidence * 100 * 0.2 +
    (100 - volatility * 100) * 0.1;

  const recommendation = {
    direction: mlPrediction.direction,
    confidence: mlPrediction.confidence * 100,
    entryScore,
    momentumScore: momentum.strength,
    alignmentScore: multiTimeframe.alignment.score,
  };

  if (autoTradeEnabled && entryScore >= 65 && recommendation.confidence >= 75) {
    await derivBotAPI.placeTrade({
      symbol,
      contract_type: recommendation.direction === "RISE" ? "CALL" : "PUT",
      duration: 5,
      amount: 1,
    });
  }

  return recommendation;
}


This lets the ML engine feed predictions into your existing multi-layer analysis, and when all signals align, it auto-trades instantly.

üß© Step 4 ‚Äî Modify the Auto Trade Button

In your ml-trader.tsx UI section (or AutoTradeToggle.tsx), ensure the toggle sets a global flag:

const [autoTradeEnabled, setAutoTradeEnabled] = useState(false);

<Button
  onClick={() => setAutoTradeEnabled(prev => !prev)}
  className={autoTradeEnabled ? "bg-green-500" : "bg-gray-500"}
>
  {autoTradeEnabled ? "Auto Trading ON" : "Auto Trading OFF"}
</Button>


This state flag is what your runAnalysisAndTrade() checks before placing trades.

üß© Step 5 ‚Äî Trade Execution (already in your Deriv Bot API)

Just make sure deriv-bot-interface.ts exposes a simple method like:

export async function placeTrade({ symbol, contract_type, duration, amount }) {
  const proposal = await derivApi.proposal({
    symbol,
    contract_type,
    duration,
    duration_unit: "t",
    amount,
    currency: "USD",
  });
  return derivApi.buy({ buy: proposal.proposal.id });
}


This executes the trade with your authenticated WebSocket session.

‚úÖ Final Flow (Click ‚ÄúAuto Trade‚Äù ‚Üí Live ML Execution)

You click ‚ÄúAuto Trade‚Äù

The system fetches live ticks ‚Üí generates features

ml-tick-analyzer sends features ‚Üí Python ML API ‚Üí gets prediction

ml-trader combines prediction + volatility + momentum

If all thresholds are met ‚Üí triggers placeTrade()

Trade executes via Deriv API ‚Üí displayed in UI