import { CandleData } from './candle-reconstruction-engine';
import { EfficientHMACalculator, EfficientHMAResult, EfficientHMASlopeResult } from './efficient-hma-calculator';
import { DerivMarketConfig } from './ehlers-signal-processing';
import { 
    EhlersPredictiveSystem, 
    EhlersTradingBot, 
    TenSecondCandleEngine,
    EhlersAnalysis,
    TrendSignal as EhlersTrendSignal,
    tenSecondCandleEngine,
    ehlersTradingBot
} from './ehlers-predictive-system';

export type TrendDirection = 'bullish' | 'bearish' | 'neutral';
export type TrendStrength = 'strong' | 'moderate' | 'weak';



export interface TrendAnalysis {
    symbol: string;
    timestamp: number;
    direction: TrendDirection;
    strength: TrendStrength;
    confidence: number;
    score: number;
    price: number;
    recommendation: 'BUY' | 'SELL' | 'HOLD';
    reason: string;
    lastUpdate: Date;

    // Technical indicators
    shortTermHMA?: number;
    longTermHMA?: number;
    rocAlignment?: 'BULLISH' | 'BEARISH' | 'NEUTRAL';
    longTermTrend?: TrendDirection;
    longTermTrendStrength?: number;

    // Enhanced Ehlers data
    ehlers?: {
        decycler: number;
        instantaneousTrendline: number;
        snr: number;
        netValue: number;
        anticipatorySignal: number;
    };

    ehlersRecommendation?: {
        action: string;
        confidence: number;
        reason: string;
        anticipatory: boolean;
        signalStrength: 'weak' | 'medium' | 'strong';
        isPullbackSignal?: boolean;
    };

    

    // Sustained momentum analysis for Higher/Lower trades
    sustainedMomentum?: {
        hasSustainedMomentum: boolean;
        direction: 'HIGHER' | 'LOWER' | 'NEUTRAL';
        strength: number;
        confidence: number;
        duration: number;
        factors: string[];
    };

    // Momentum breakout analysis for strong 1-minute trends
    momentumBreakout?: {
        hasBreakout: boolean;
        breakoutType: 'BULLISH_BREAKOUT' | 'BEARISH_BREAKOUT' | 'NONE';
        strength: number;
        confidence: number;
        factors: string[];
    };

    // Cycle trading assessment
    cycleTrading?: {
        suitable: boolean;
        snrLevel: 'poor' | 'good' | 'excellent';
        recommendation: string;
    };

    // Deriv market specific signals
    derivSignals?: {
        riseFall: {
            action: 'RISE' | 'FALL' | 'WAIT';
            confidence: number;
            reasoning: string;
        };
        higherLower: {
            action: 'HIGHER' | 'LOWER' | 'WAIT';
            confidence: number;
            reasoning: string;
        };
    };

    // Enhanced Ehlers Predictive System (10-second candles)
    ehlersPredict?: {
        analysis: EhlersAnalysis;
        signal: EhlersTrendSignal;
        marketPhase: 'trending' | 'cycling' | 'transitioning';
        recommendation: 'BUY' | 'SELL' | 'HOLD';
        strength: 'weak' | 'medium' | 'strong';
        timeframe: '10s' | '1m';
    };
}

export interface MarketScanResult {
    symbol: string;
    displayName: string;
    trend: TrendAnalysis;
    rank: number;
    isRecommended: boolean;
}

export class TrendAnalysisEngine {
    private hmaCalculator: EfficientHMACalculator;
    private trendData: Map<string, TrendAnalysis> = new Map();
    private updateTimer: NodeJS.Timeout;
    private signalCache: Map<string, {
        signal: 'BULLISH' | 'BEARISH' | null;
        timestamp: number;
        confirmationCount: number;
        strength: number; // Store confidence of the cached signal
        lastUpdate: number;
    }> = new Map();
    private readonly SIGNAL_PERSISTENCE_MS = 15 * 60 * 1000; // 15 minutes (increased from 10)
    private readonly MIN_CONFIRMATION_COUNT = 5; // Require 5 confirmations before changing signal
    private readonly SIGNAL_STRENGTH_THRESHOLD = 60; // Minimum confidence to cache a new signal

    constructor(hmaCalculator: EfficientHMACalculator) {
        this.hmaCalculator = hmaCalculator;

        // Update trend analysis periodically
        this.updateTimer = setInterval(() => this.updateAllTrends(), 30 * 1000); // Every 30 seconds
        
        console.log('ðŸš€ TrendAnalysisEngine initialized with Ehlers Predictive System (10s candles)');
    }

    /**
     * Add candle data and update trend analysis
     */
    addCandleData(candle: CandleData): void {
        const { symbol, close, timestamp } = candle;

        // Initialize Ehlers system for this symbol if not already done
        ehlersTradingBot.initializeSymbol(symbol);

        // Use multiple HMA periods that divide evenly into 210 candles
        // 210 = 2Ã—3Ã—5Ã—7, so we use periods: 5, 6, 7, 10, 14, 15, 21, 30, 35, 42, 70, 105
        const hmaPeriods = [5, 6, 7, 10, 14, 15, 21, 30, 35, 42, 70, 105];
        this.hmaCalculator.addCandleData(candle, hmaPeriods);

        

        // Update trend analysis when all HMA periods are ready
        const allPeriodsReady = hmaPeriods.every(period =>
            this.hmaCalculator.isReady(symbol, period)
        );

        if (allPeriodsReady) {
            this.updateTrendAnalysis(symbol, close);
        }
    }

    /**
     * Update trend analysis for a specific symbol with enhanced pullback detection
     */
    private updateTrendAnalysis(symbol: string, currentPrice: number): void {
        // Calculate ROC indicators for trend analysis
        const { candleReconstructionEngine } = require('./candle-reconstruction-engine');
        const recentCandles = candleReconstructionEngine.getCandles(symbol, 30);

        if (!recentCandles || recentCandles.length < 10) {
            console.log(`${symbol}: Insufficient candle data for analysis (need 10, have ${recentCandles?.length || 0})`);
            return;
        }

        const prices = recentCandles.map((candle: any) => candle.close);
        const highs = recentCandles.map((candle: any) => candle.high);
        const lows = recentCandles.map((candle: any) => candle.low);

        

        // Detect sustained momentum for Higher/Lower trades
        const sustainedMomentum = this.detectSustainedMomentum(symbol, recentCandles);

        // Detect momentum breakout patterns for 1-minute candles
        const momentumBreakout = this.detectMomentumBreakout(recentCandles, symbol);

        // Use default ROC periods (can be made configurable later)
        const rocPeriods = this.getROCPeriods(false); // Default to non-sensitive
        const longTermROC = this.calculateROC(prices, rocPeriods.longTerm);
        const shortTermROC = this.calculateROC(prices, rocPeriods.shortTerm);

        if (longTermROC === null || shortTermROC === null) {
            console.log(`${symbol}: Failed to calculate ROC indicators`);
            return;
        }

        // Determine ROC alignment and trend direction
        const rocAlignment = this.determineROCAlignment(longTermROC, shortTermROC);
        const direction = this.determineTrendDirectionByROC(rocAlignment);

        // Calculate trend strength based on ROC magnitude
        const strength = this.calculateTrendStrengthByROC(longTermROC, shortTermROC);

        // Calculate confidence based on ROC alignment and strength
        const confidence = this.calculateConfidenceByROC(longTermROC, shortTermROC, rocAlignment);

        // Get ROC-based signal validation with persistence
        const rawROCSignal = this.validateROCAlignment(symbol, longTermROC, shortTermROC);
        const persistentROCSignal = this.getPersistedSignal(symbol, rawROCSignal, confidence);

        // Override direction based on persistent ROC signal validation
        let finalDirection = direction;
        if (persistentROCSignal === 'BULLISH') {
            finalDirection = 'bullish';
        } else if (persistentROCSignal === 'BEARISH') {
            finalDirection = 'bearish';
        } else {
            finalDirection = 'neutral'; // No valid signal
        }

        // Generate recommendation based on persistent ROC signal validation
        const recommendation = this.generateRecommendationByROC(finalDirection, strength, confidence, persistentROCSignal);

        // Calculate overall score based on ROC alignment and validation
        let score = this.calculateTradingScoreByROC(finalDirection, strength, confidence, rocAlignment);

        // Boost score significantly for valid ROC signals - INCREASED WEIGHT
        if (persistentROCSignal === 'BULLISH' || persistentROCSignal === 'BEARISH') {
            score = Math.min(98, score + 45); // Increased from 30 to 45 points for valid ROC signal
        }

        // Additional ROC alignment bonus - NEW ENHANCEMENT
        if (rocAlignment !== 'NEUTRAL') {
            score = Math.min(98, score + 15); // Extra 15 points for any ROC alignment
        }

        

        // Get Enhanced Ehlers Predictive Analysis (10-second candles)
        const ehlersAnalysis = ehlersTradingBot.getLatestAnalysis(symbol);
        let ehlersPredict: any = null;

        if (ehlersAnalysis) {
            // Determine recommendation based on Ehlers predictive signals
            let ehlersRecommendation = 'HOLD';
            let ehlersStrength: 'weak' | 'medium' | 'strong' = 'weak';

            if (ehlersAnalysis.signal.entry && ehlersAnalysis.signal.confidence > 70) {
                ehlersRecommendation = ehlersAnalysis.signal.direction === 'bullish' ? 'BUY' : 
                                     ehlersAnalysis.signal.direction === 'bearish' ? 'SELL' : 'HOLD';
                
                if (ehlersAnalysis.signal.strength > 80) ehlersStrength = 'strong';
                else if (ehlersAnalysis.signal.strength > 60) ehlersStrength = 'medium';
            }

            ehlersPredict = {
                analysis: ehlersAnalysis,
                signal: ehlersAnalysis.signal,
                marketPhase: ehlersAnalysis.marketPhase,
                recommendation: ehlersRecommendation,
                strength: ehlersStrength,
                timeframe: '10s'
            };

            console.log(`ðŸ“ˆ ${symbol} Ehlers Predictive: ${ehlersRecommendation} (${ehlersStrength}) - Phase: ${ehlersAnalysis.marketPhase}`);
        }

        

        // Integration Priority - Only use top 3 systems
        let finalRecommendation = recommendation;
        let enhancedScore = score;

        // Priority 1: Ehlers Predictive System (HIGHEST PRIORITY for 10-second analysis)
        if (ehlersPredict && ehlersPredict.signal.entry && ehlersPredict.signal.confidence >= 75 && ehlersPredict.strength !== 'weak') {
            finalRecommendation = ehlersPredict.recommendation;
            enhancedScore = Math.min(98, ehlersPredict.signal.confidence + 25);
            console.log(`ðŸŽ¯ EHLERS PREDICTIVE PRIORITY: ${ehlersPredict.recommendation} (${ehlersPredict.strength}) - Phase: ${ehlersPredict.marketPhase} (${enhancedScore.toFixed(1)}%)`);
        }
        // Priority 2: Momentum Breakout (SECOND PRIORITY for 1-minute trends)
        else if (momentumBreakout.hasBreakout && momentumBreakout.confidence >= 80) {
            finalRecommendation = momentumBreakout.breakoutType === 'BULLISH_BREAKOUT' ? 'BUY' : 'SELL';
            enhancedScore = Math.min(98, momentumBreakout.confidence + 20);
            console.log(`ðŸš€ MOMENTUM BREAKOUT PRIORITY: ${momentumBreakout.breakoutType} - Strength: ${momentumBreakout.strength}% (${enhancedScore.toFixed(1)}%)`);
        }
        // Priority 3: ROC Signals (THIRD PRIORITY for rate of change analysis)
        else if (persistentROCSignal && confidence >= 75) {
            finalRecommendation = persistentROCSignal === 'BULLISH' ? 'BUY' : 'SELL';
            enhancedScore = Math.min(98, confidence + 25); // High bonus for strong ROC
            console.log(`ðŸŽ¯ ROC PRIORITY: ${persistentROCSignal} signal with high confidence (${enhancedScore.toFixed(1)}%)`);
        }

        const analysis: TrendAnalysis = {
            symbol,
            direction: finalDirection,
            strength,
            confidence,
            price: currentPrice,
            lastUpdate: new Date(),
            recommendation: finalRecommendation,
            score: enhancedScore,
            longTermROC,
            shortTermROC,
            rocAlignment,
            
            
            sustainedMomentum, // Add sustained momentum analysis
            momentumBreakout, // Add momentum breakout analysis
            ehlersPredict, // Add Ehlers Predictive System results
        };

        this.trendData.set(symbol, analysis);

        console.log(`ROC-Based Trend Analysis for ${symbol}: ${finalDirection.toUpperCase()} (${strength}) - ROC Signal: ${persistentROCSignal || 'NONE'} (Raw: ${rawROCSignal || 'NONE'}) - LT ROC: ${longTermROC.toFixed(3)}% ST ROC: ${shortTermROC.toFixed(3)}% - Score: ${score.toFixed(1)} - Recommendation: ${recommendation}`);
    }

    /**
     * Analyze HMA alignment across all periods
     */
    private analyzeHMAAlignment(hmaData: Array<{period: number; value: number; slope: number | null; color: 'green' | 'red' | 'neutral'}>): {
        alignedCount: number;
        totalCount: number;
        alignmentPercentage: number;
        dominantColor: 'green' | 'red' | 'neutral';
        isAligned: boolean;
        shortTermAlignment: number; // 0-100
        longTermAlignment: number; // 0-100
    } {
        const totalCount = hmaData.length;
        const colorCounts = {
            green: hmaData.filter(h => h.color === 'green').length,
            red: hmaData.filter(h => h.color === 'red').length,
            neutral: hmaData.filter(h => h.color === 'neutral').length
        };

        const dominantColor = colorCounts.green > colorCounts.red && colorCounts.green > colorCounts.neutral ? 'green' :
                             colorCounts.red > colorCounts.green && colorCounts.red > colorCounts.neutral ? 'red' : 'neutral';

        const alignedCount = colorCounts[dominantColor];
        const alignmentPercentage = (alignedCount / totalCount) * 100;

        // Short-term alignment (periods <= 21)
        const shortTermHMAs = hmaData.filter(h => h.period <= 21);
        const shortTermAligned = shortTermHMAs.filter(h => h.color === dominantColor).length;
        const shortTermAlignment = (shortTermHMAs.length > 0 ? (shortTermAligned / shortTermHMAs.length) * 100 : 0);

        // Long-term alignment (periods > 21)
        const longTermHMAs = hmaData.filter(h => h.period > 21);
        const longTermAligned = longTermHMAs.filter(h => h.color === dominantColor).length;
        const longTermAlignment = longTermHMAs.length > 0 ? (longTermAligned / longTermHMAs.length) * 100 : 0;

        return {
            alignedCount,
            totalCount,
            alignmentPercentage,
            dominantColor,
            isAligned: alignmentPercentage >= 75 && dominantColor !== 'neutral', // Require 75% alignment
            shortTermAlignment,
            longTermAlignment
        };
    }

    /**
     * Determine trend direction based on HMA alignment
     */
    private determineTrendDirectionByAlignment(alignment: any): TrendDirection {
        if (alignment.isAligned) {
            return alignment.dominantColor === 'green' ? 'bullish' : 'bearish';
        }
        return 'neutral';
    }

    /**
     * Calculate trend strength based on alignment score
     */
    private calculateTrendStrengthByAlignment(alignment: any): TrendStrength {
        if (alignment.alignmentPercentage >= 90) {
            return 'strong';
        } else if (alignment.alignmentPercentage >= 75) {
            return 'moderate';
        }
        return 'weak';
    }

    /**
     * Calculate confidence based on alignment consistency
     */
    private calculateConfidenceByAlignment(alignment: any): number {
        let confidence = alignment.alignmentPercentage; // Base confidence from alignment percentage

        // Bonus for strong short-term and long-term alignment
        if (alignment.shortTermAlignment >= 80 && alignment.longTermAlignment >= 80) {
            confidence += 15;
        } else if (alignment.shortTermAlignment >= 70 && alignment.longTermAlignment >= 70) {
            confidence += 10;
        }

        // Penalty for neutral dominant color
        if (alignment.dominantColor === 'neutral') {
            confidence -= 20;
        }

        return Math.min(100, Math.max(0, confidence));
    }

    /**
     * Generate recommendation based on SMA conditions and candle patterns
     */
    private generateRecommendationByAlignment(
        direction: TrendDirection,
        strength: TrendStrength,
        confidence: number,
        alignment: any,
        symbol?: string
    ): 'BUY' | 'SELL' | 'HOLD' {
        if (!symbol) {
            return 'HOLD';
        }

        // Get specific signal validation using dual ROC and candle patterns
        const signalValidation = this.validateDualROCSignal(symbol);

        if (!signalValidation) {
            return 'HOLD';
        }

        // Apply the validated signal
        if (signalValidation === 'BULLISH') {
            return 'BUY';
        } else if (signalValidation === 'BEARISH') {
            return 'SELL';
        }

        return 'HOLD';
    }

    /**
     * Calculate trading score based on alignment
     */
    private calculateTradingScoreByAlignment(
        direction: TrendDirection,
        strength: TrendStrength,
        confidence: number,
        alignment: any
    ): number {
        let score = 0;

        // Base score from alignment percentage
        score += alignment.alignmentPercentage * 0.6;

        // Alignment quality bonus
        if (alignment.isAligned) {
            score += 20;
        }

        // Short-term and long-term alignment bonus
        score += (alignment.shortTermAlignment * 0.15);
        score += (alignment.longTermAlignment * 0.15);

        // Direction scoring
        if (direction === 'bullish' || direction === 'bearish') {
            score += 15;
        }

        // Strength scoring
        switch (strength) {
            case 'strong':
                score += 20;
                break;
            case 'moderate':
                score += 10;
                break;
            case 'weak':
                score += 2;
                break;
        }

        return Math.min(100, Math.max(0, score));
    }

    /**
     * Calculate long-term trend strength using multiple HMAs
     */
    private calculateLongTermTrendStrengthMultiHMA(
        hmaData: Array<{period: number; value: number; slope: number | null; color: string}>,
        currentPrice: number,
        symbol: string
    ): number {
        const longTermHMAs = hmaData.filter(h => h.period >= 35); // Use longer periods
        if (longTermHMAs.length === 0) return 0;

        // Calculate consistency in long-term HMAs
        const colorCounts = {
            green: longTermHMAs.filter(h => h.color === 'green').length,
            red: longTermHMAs.filter(h => h.color === 'red').length,
            neutral: longTermHMAs.filter(h => h.color === 'neutral').length
        };

        const maxCount = Math.max(colorCounts.green, colorCounts.red, colorCounts.neutral);
        const consistency = (maxCount / longTermHMAs.length) * 100;

        // Calculate average slope magnitude
        const validSlopes = longTermHMAs.filter(h => h.slope !== null).map(h => h.slope!);
        const avgSlopeMagnitude = validSlopes.length > 0 ?
            validSlopes.reduce((sum, slope) => sum + Math.abs(slope), 0) / validSlopes.length : 0;

        return Math.min(100, consistency * 0.7 + (avgSlopeMagnitude * 1000 * 30));
    }

    /**
     * Get HMA color based on slope
     */
    private getHMAColor(slope: number | null): 'green' | 'red' | 'neutral' {
        if (!slope) return 'neutral';

        const slopeThreshold = 0.0001; // Threshold for color determination

        if (slope > slopeThreshold) return 'green';
        if (slope < -slopeThreshold) return 'red';
        return 'neutral';
    }

    /**
     * Calculate Rate of Change (ROC) indicator
     */
    private calculateROC(prices: number[], period: number = 14): number | null {
        if (prices.length < period + 1) return null;

        const currentPrice = prices[prices.length - 1];
        const pastPrice = prices[prices.length - 1 - period];

        return ((currentPrice - pastPrice) / pastPrice) * 100;
    }

    /**
     * Get ROC periods based on sensitivity setting
     */
    private getROCPeriods(sensitive: boolean = false): { longTerm: number; shortTerm: number; ultraShort: number } {
        if (sensitive) {
            return {
                longTerm: 10, // Half of default 20
                shortTerm: 3,   // Half of default 5 (rounded)
                ultraShort: 1   // For 1-minute trend momentum
            };
        }
        return {
            longTerm: 20, // Default long-term period
            shortTerm: 5,   // Default short-term period
            ultraShort: 2   // For capturing immediate momentum
        };
    }

    /**
     * Determine ROC alignment status
     */
    private determineROCAlignment(longTermROC: number, shortTermROC: number): 'BULLISH' | 'BEARISH' | 'NEUTRAL' {
        const longTermThreshold = 0.05; // 0.05%
        const shortTermThreshold = 0.1;  // 0.1%

        // Both ROC positive and short-term accelerating upward
        if (longTermROC > longTermThreshold && shortTermROC > shortTermThreshold && shortTermROC > longTermROC) {
            return 'BULLISH';
        }

        // Both ROC negative and short-term accelerating downward
        if (longTermROC < -longTermThreshold && shortTermROC < -shortTermThreshold && shortTermROC < longTermROC) {
            return 'BEARISH';
        }

        return 'NEUTRAL';
    }

    /**
     * Determine trend direction based on ROC alignment
     */
    private determineTrendDirectionByROC(rocAlignment: 'BULLISH' | 'BEARISH' | 'NEUTRAL'): TrendDirection {
        if (rocAlignment === 'BULLISH') return 'bullish';
        if (rocAlignment === 'BEARISH') return 'bearish';
        return 'neutral';
    }

    /**
     * Calculate trend strength based on ROC magnitude
     */
    private calculateTrendStrengthByROC(longTermROC: number, shortTermROC: number): TrendStrength {
        const rocMagnitude = Math.abs(longTermROC) + Math.abs(shortTermROC);
        const acceleration = Math.abs(shortTermROC - longTermROC);

        if (rocMagnitude > 0.5 && acceleration > 0.2) {
            return 'strong';
        } else if (rocMagnitude > 0.2 || acceleration > 0.1) {
            return 'moderate';
        }

        return 'weak';
    }

    /**
     * Calculate confidence based on ROC alignment and strength
     */
    private calculateConfidenceByROC(longTermROC: number, shortTermROC: number, rocAlignment: 'BULLISH' | 'BEARISH' | 'NEUTRAL'): number {
        let confidence = 40; // Base confidence

        // ROC alignment bonus - INCREASED WEIGHT
        if (rocAlignment !== 'NEUTRAL') {
            confidence += 40; // Increased from 30 to 40 points for aligned ROC
        }

        // ROC magnitude bonus - ENHANCED
        const rocMagnitude = Math.abs(longTermROC) + Math.abs(shortTermROC);
        confidence += Math.min(25, rocMagnitude * 12); // Increased multiplier and cap

        // Acceleration bonus (short-term momentum stronger than long-term) - ENHANCED
        const acceleration = Math.abs(shortTermROC - longTermROC);
        confidence += Math.min(15, acceleration * 25); // Increased multiplier and cap

        return Math.min(100, Math.max(0, confidence));
    }

    /**
     * Validate ROC alignment for trading signals with enhanced confluence
     */
    private validateROCAlignment(symbol: string, longTermROC: number, shortTermROC: number): 'BULLISH' | 'BEARISH' | null {
        // Import candle reconstruction engine
        const { candleReconstructionEngine } = require('./candle-reconstruction-engine');

        // Get recent candles for comprehensive pattern validation
        const recentCandles = candleReconstructionEngine.getCandles(symbol, 10);

        if (recentCandles.length < 5) {
            console.log(`${symbol}: Insufficient candle data for pattern validation`);
            return null;
        }

        const lastCandle = recentCandles[recentCandles.length - 1];
        const previousCandle = recentCandles[recentCandles.length - 2];
        const last5Candles = recentCandles.slice(-5);

        // Enhanced multi-timeframe validation
        const confluenceFactors = this.calculateConfluenceFactors(symbol, longTermROC, shortTermROC, last5Candles);
        
        // Require minimum confluence score for signal validation
        if (confluenceFactors.score < 0.65) {
            console.log(`${symbol}: Confluence score too low: ${confluenceFactors.score.toFixed(2)}`);
            return null;
        }

        // Determine candle colors
        const isLastCandleGreen = lastCandle.close > lastCandle.open;
        const isLastCandleRed = lastCandle.close < lastCandle.open;

        // BULLISHSIGNAL CONDITIONS:
        // 1. Long-term ROC positive (upward trend)
        // 2. Short-term ROC stronger positive (acceleration)
        // 3. Last candle is green and closes above previous high
        if (longTermROC > 0.05 && // Long-term positive momentum (> 0.05%)
            shortTermROC > 0.1 && // Short-term positive momentum (> 0.1%)
            shortTermROC > longTermROC && // Short-term stronger than long-term (acceleration)
            isLastCandleGreen &&
            lastCandle.close > previousCandle.high) {

            console.log(`${symbol}: âœ… ROCBULLISH signal confirmed:
                - Long-term ROC (20): ${longTermROC.toFixed(3)}% (positive trend)
                - Short-term ROC (5): ${shortTermROC.toFixed(3)}% (accelerating upward)
                - ROC alignment: SHORT > LONG (${shortTermROC.toFixed(3)}% > ${longTermROC.toFixed(3)}%)
                - Last candle GREEN: ${lastCandle.open.toFixed(5)} â†’ ${lastCandle.close.toFixed(5)}
                - Closes above prev high: ${lastCandle.close.toFixed(5)} > ${previousCandle.high.toFixed(5)}`);
            return 'BULLISH';
        }

        // BEARISH SIGNAL CONDITIONS:
        // 1. Long-term ROC negative (downward trend)
        // 2. Short-term ROC stronger negative (acceleration)
        // 3. Last candle is red and closes below previous low
        if (longTermROC < -0.05 && // Long-term negative momentum (< -0.05%)
            shortTermROC < -0.1 && // Short-term negative momentum (< -0.1%)
            shortTermROC < longTermROC && // Short-term more negative than long-term (acceleration)
            isLastCandleRed &&
            lastCandle.close < previousCandle.low) {

            console.log(`${symbol}: âœ… ROC BEARISH signal confirmed:
                - Long-term ROC (20): ${longTermROC.toFixed(3)}% (negative trend)
                - Short-term ROC (5): ${shortTermROC.toFixed(3)}% (accelerating downward)
                - ROC alignment: SHORT < LONG (${shortTermROC.toFixed(3)}% < ${longTermROC.toFixed(3)}%)
                - Last candle RED: ${lastCandle.open.toFixed(5)} â†’ ${lastCandle.close.toFixed(5)}
                - Closes below prev low: ${lastCandle.close.toFixed(5)} < ${previousCandle.low.toFixed(5)}`);
            return 'BEARISH';
        }

        // Log why signal was not generated
        console.log(`${symbol}: âŒ ROC signal not generated:
            - Long-term ROC (20): ${longTermROC.toFixed(3)}%
            - Short-term ROC (5): ${shortTermROC.toFixed(3)}%
            - ROC alignment: ${shortTermROC > longTermROC ? 'SHORT > LONG' : shortTermROC < longTermROC ? 'SHORT < LONG' : 'EQUAL'}
            - Candle color: ${isLastCandleGreen ? 'GREEN' : isLastCandleRed ? 'RED' : 'NEUTRAL'}
            - Price action: ${lastCandle.close > previousCandle.high ? 'Above prev high' : lastCandle.close < previousCandle.low ? 'Below prev low' : 'Inside range'}`);

        return null;
    }

    /**
     * Generate recommendation based on ROC alignment with adaptive thresholds
     */
    private generateRecommendationByROC(
        direction: TrendDirection,
        strength: TrendStrength,
        confidence: number,
        rocSignal: 'BULLISH' | 'BEARISH' | null
    ): 'BUY' | 'SELL' | 'HOLD' {
        // Only generate signals when ROC alignment is confirmed
        if (!rocSignal) {
            return 'HOLD';
        }

        // Dynamic threshold based on market conditions
        const adaptiveThreshold = this.calculateAdaptiveThreshold(strength, direction);
        
        // Apply the validated ROC signal with adaptive thresholds
        if (rocSignal === 'BULLISH' && confidence > adaptiveThreshold.bullish) {
            return 'BUY';
        } else if (rocSignal === 'BEARISH' && confidence > adaptiveThreshold.bearish) {
            return 'SELL';
        }

        return 'HOLD';
    }

    /**
     * Calculate adaptive thresholds based on market strength and volatility
     */
    private calculateAdaptiveThreshold(strength: TrendStrength, direction: TrendDirection): {
        bullish: number;
        bearish: number;
    } {
        let baseThreshold = 65; // Conservative base

        // Adjust based on trend strength
        switch (strength) {
            case 'strong':
                baseThreshold = 55; // Lower threshold for strong trends
                break;
            case 'moderate':
                baseThreshold = 65; // Standard threshold
                break;
            case 'weak':
                baseThreshold = 75; // Higher threshold for weak trends
                break;
        }

        // Further adjustment based on recent performance
        const recentPerformance = this.getRecentSignalPerformance();
        if (recentPerformance.winRate > 0.7) {
            baseThreshold -= 5; // More aggressive when performing well
        } else if (recentPerformance.winRate < 0.4) {
            baseThreshold += 10; // More conservative when performing poorly
        }

        return {
            bullish: baseThreshold,
            bearish: baseThreshold
        };
    }

    /**
     * Track recent signal performance for adaptive learning
     */
    private getRecentSignalPerformance(): { winRate: number; totalSignals: number } {
        // This would integrate with your transaction store to track win/loss
        // For now, return neutral performance
        return { winRate: 0.5, totalSignals: 0 };
    }

    

    /**
     * Detect sustained momentum for Higher/Lower trades
     */
    private detectSustainedMomentum(symbol: string, candles: any[]): {
        hasSustainedMomentum: boolean;
        direction: 'HIGHER' | 'LOWER' | 'NEUTRAL';
        strength: number;
        confidence: number;
        duration: number;
        factors: string[];
    } {
        if (candles.length < 15) {
            return {
                hasSustainedMomentum: false,
                direction: 'NEUTRAL',
                strength: 0,
                confidence: 0,
                duration: 0,
                factors: []
            };
        }

        const prices = candles.map(c => c.close);
        const highs = candles.map(c => c.high);
        const lows = candles.map(c => c.low);
        const volumes = candles.map(c => c.tickCount || 1); // Use tick count as volume proxy

        const factors: string[] = [];
        let strength = 0;
        let confidence = 0;
        let direction: 'HIGHER' | 'LOWER' | 'NEUTRAL' = 'NEUTRAL';

        // 1. Multi-timeframe ROC momentum alignment
        const shortROC = this.calculateROC(prices, 3);
        const mediumROC = this.calculateROC(prices, 7);
        const longROC = this.calculateROC(prices, 14);

        if (shortROC && mediumROC && longROC) {
            // Bullish momentum alignment
            if (shortROC > 0.1 && mediumROC > 0.05 && longROC > 0.02 && 
                shortROC > mediumROC && mediumROC > longROC) {
                direction = 'HIGHER';
                strength += 25;
                confidence += 20;
                factors.push('multi_timeframe_bullish_momentum');
            }
            // Bearish momentum alignment
            else if (shortROC < -0.1 && mediumROC < -0.05 && longROC < -0.02 && 
                     shortROC < mediumROC && mediumROC < longROC) {
                direction = 'LOWER';
                strength += 25;
                confidence += 20;
                factors.push('multi_timeframe_bearish_momentum');
            }
        }

        // 2. Consecutive candle direction (momentum persistence)
        const last5Candles = candles.slice(-5);
        const bullishCandles = last5Candles.filter(c => c.close > c.open).length;
        const bearishCandles = last5Candles.filter(c => c.close < c.open).length;

        if (bullishCandles >= 4) {
            if (direction === 'HIGHER') strength += 20;
            confidence += 15;
            factors.push('consecutive_bullish_candles');
        } else if (bearishCandles >= 4) {
            if (direction === 'LOWER') strength += 20;
            confidence += 15;
            factors.push('consecutive_bearish_candles');
        }

        // 3. Volume-weighted momentum (using tick count)
        const recentVolume = volumes.slice(-5).reduce((a, b) => a + b, 0);
        const olderVolume = volumes.slice(-10, -5).reduce((a, b) => a + b, 0);
        const volumeIncrease = (recentVolume - olderVolume) / olderVolume;

        if (volumeIncrease > 0.2) { // 20% volume increase
            strength += 15;
            confidence += 10;
            factors.push('increasing_volume');
        }

        // 4. Higher highs / Lower lows pattern
        const recentHighs = highs.slice(-5);
        const recentLows = lows.slice(-5);
        const olderHighs = highs.slice(-10, -5);
        const olderLows = lows.slice(-10, -5);

        const higherHighs = Math.max(...recentHighs) > Math.max(...olderHighs);
        const higherLows = Math.min(...recentLows) > Math.min(...olderLows);
        const lowerHighs = Math.max(...recentHighs) < Math.max(...olderHighs);
        const lowerLows = Math.min(...recentLows) < Math.min(...olderLows);

        if (higherHighs && higherLows && direction === 'HIGHER') {
            strength += 20;
            confidence += 15;
            factors.push('higher_highs_higher_lows');
        } else if (lowerHighs && lowerLows && direction === 'LOWER') {
            strength += 20;
            confidence += 15;
            factors.push('lower_highs_lower_lows');
        }

        