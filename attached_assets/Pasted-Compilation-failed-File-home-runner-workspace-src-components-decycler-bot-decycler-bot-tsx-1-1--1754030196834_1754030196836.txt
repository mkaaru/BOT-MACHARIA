Compilation failed

File: /home/runner/workspace/src/components/decycler-bot/decycler-bot.tsx:1:1
  × Module build failed:
  ╰─▶   ×   × the name `monitorContract` is defined multiple times
        │       ╭─[/home/runner/workspace/src/components/decycler-bot/decycler-bot.tsx:726:1]
        │   723 │     }, [config, addLog]);
        │   724 │
        │   725 │     // Monitor open contract
        │   726 │     const monitorContract = useCallback(async (contractId: string): Promise<void> => {
        │       ·           ───────┬───────
        │       ·                  ╰── previous definition of `monitorContract` here
        │   727 │         if (!api_base.api) return;
        │   728 │
        │   729 │         try {
        │   730 │             const request = {
        │   731 │                 proposal_open_contract: 1,
        │   732 │                 contract_id: contractId,
        │   733 │                 subscribe: 1
        │   734 │             };
        │   735 │
        │   736 │             const response = await api_base.api.send(request);
        │   737 │
        │   738 │             if (response.error) {
        │   739 │                 addLog(`❌ Contract monitoring error: ${response.error.message}`);
        │   740 │                 return;
        │   741 │             }
        │   742 │
        │   743 │             addLog(`👁️ Monitoring contract ${contractId}`);
        │   744 │         } catch (error) {
        │   745 │             addLog(`❌ Failed to monitor contract: ${error.message}`);
        │   746 │         }
        │   747 │     }, [addLog]);
        │   748 │
        │   749 │     // Main trading loop
        │   750 │     const tradingLoop = useCallback(async (): Promise<void> => {
        │   751 │         if (!botStatus.is_running) return;
        │   752 │
        │   753 │         try {
        │   754 │             addLog('🔄 Starting trading analysis cycle...');
        │   755 │
        │   756 │             // Analyze all timeframes
        │   757 │             const trends = await analyzeAllTimeframes();
        │   758 │
        │   759 │             if (trends.length === 0) {
        │   760 │                 addLog('⚠️ No trend data available - will retry next cycle');
        │   761 │                 setBotStatus(prev => ({
        │   762 │                     ...prev,
        │   763 │                     error_message: 'No trend data available',
        │   764 │                     last_update: Date.now()
        │   765 │                 }));
        │   766 │                 return;
        │   767 │             }
        │   768 │
        │   769 │             const alignment = checkAlignment(trends);
        │   770 │
        │   771 │             // Update bot status with new analysis
        │   772 │             setBotStatus(prev => ({
        │   773 │                 ...prev,
        │   774 │                 trends,
        │   775 │                 alignment_status: alignment,
        │   776 │                 last_update: Date.now(),
        │   777 │                 error_message: ''
        │   778 │             }));
        │   779 │
        │   780 │             addLog(`📊 Analysis complete - Alignment: ${alignment.toUpperCase()}`);
        │   781 │
        │   782 │             // Log individual timeframe results
        │   783 │             const bullishCount = trends.filter(t => t.trend === 'bullish').length;
        │   784 │             const bearishCount = trends.filter(t => t.trend === 'bearish').length;
        │   785 │             const neutralCount = trends.filter(t => t.trend === 'neutral').length;
        │   786 │
        │   787 │             addLog(`📈 Trends: ${bullishCount} Bullish, ${bearishCount} Bearish, ${neutralCount} Neutral`);
        │   788 │
        │   789 │             // Check if we should enter a trade
        │   790 │             if (!botStatus.current_contract && (alignment === 'aligned_bullish' || alignment === 'aligned_bearish')) {
        │   791 │                 const direction = alignment === 'aligned_bullish' ? 'UP' : 'DOWN';
        │   792 │
        │   793 │                 // Optional 10s confirmation
        │   794 │                 if (config.use_10s_filter) {
        │   795 │                     addLog('⏱️ Applying 10-second confirmation filter...');
        │   796 │                     // Add a small delay for confirmation
        │   797 │                     await new Promise(resolve => setTimeout(resolve, 1000));
        │   798 │                 }
        │   799 │
        │   800 │                 addLog(`🎯 Strong ${direction} alignment detected - Preparing trade execution!`);
        │   801 │                 await executeTrade(direction);
        │   802 │             } else if (!botStatus.current_contract) {
        │   803 │                 addLog('⏳ Waiting for trend alignment - No trade signal yet');
        │   804 │             } else {
        │   805 │                 addLog('📊 Active contract in progress - Monitoring...');
        │   806 │             }
        │   807 │
        │   808 │         } catch (error) {
        │   809 │             const errorMsg = `Trading analysis error: ${error.message}`;
        │   810 │             addLog(`❌ ${errorMsg}`);
        │   811 │             setBotStatus(prev => ({
        │   812 │                 ...prev,
        │   813 │                 error_message: errorMsg,
        │   814 │                 last_update: Date.now()
        │   815 │             }));
        │   816 │         }
        │   817 │     }, [botStatus.is_running, botStatus.current_contract, analyzeAllTimeframes, checkAlignment, config.use_10s_filter, executeTrade, addLog]);
        │   818 │
        │   819 │     // Start bot
        │   820 │     const startBot = useCallback(async (): Promise<void> => {
        │   821 │         try {
        │   822 │             addLog('🔄 Starting Decycler Bot...');
        │   823 │
        │   824 │             // Initialize API connection
        │   825 │             if (!api_base.api || api_base.api.connection.readyState !== 1) {
        │   826 │                 addLog('🔌 Connecting to Deriv API...');
        │   827 │                 await api_base.init();
        │   828 │
        │   829 │                 // Wait for connection to be ready
        │   830 │                 let retries = 0;
        │   831 │                 while ((!api_base.api || api_base.api.connection.readyState !== 1) && retries < 15) {
        │   832 │                     await new Promise(resolve => setTimeout(resolve, 1000));
        │   833 │                     retries++;
        │   834 │                     const readyState = api_base.api?.connection?.readyState || 'undefined';
        │   835 │                     addLog(`⏳ Waiting for WebSocket connection... (${retries}/15) - State: ${readyState}`);
        │   836 │                 }
        │   837 │
        │   838 │                 if (!api_base.api || api_base.api.connection.readyState !== 1) {
        │   839 │                     addLog('❌ Failed to establish WebSocket connection. Please check your internet connection and try again.');
        │   840 │                     return;
        │   841 │                 }
        │   842 │             }
        │   843 │
        │   844 │             // Check connection status
        │   845 │             const connectionStatus = api_base.getConnectionStatus();
        │   846 │             addLog(`📡 Connection Status: ${connectionStatus}`);
        │   847 │
        │   848 │             // Check if WebSocket is actually ready
        │   849 │             const isReady = api_base.api?.connection?.readyState === 1;
        │   850 │             addLog(`🔌 WebSocket Ready State: ${api_base.api?.connection?.readyState} (${isReady ? 'OPEN' : 'NOT READY'})`);
        │   851 │
        │   852 │             if (!isReady) {
        │   853 │                 addLog('❌ WebSocket connection not ready. Please wait and try again.');
        │   854 │                 return;
        │   855 │             }
        │   856 │
        │   857 │             setBotStatus(prev => ({ ...prev, is_running: true }));
        │   858 │             addLog('🚀 Decycler Multi-Timeframe Bot Started!');
        │   859 │             addLog(`📊 Monitoring ${timeframes.join(', ')} timeframes`);
        │   860 │             addLog(`🎯 Symbol: ${config.symbol} | Stake: $${config.stake}`);
        │   861 │             addLog(`⚙️ Contract Type: ${config.contract_type.toUpperCase()}`);
        │   862 │
        │   863 │             // Start trading loop
        │   864 │             intervalRef.current = setInterval(tradingLoop, config.monitor_interval * 1000);
        │   865 │
        │   866 │             // Run initial analysis
        │   867 │             await tradingLoop();
        │   868 │         } catch (error) {
        │   869 │             addLog(`❌ Error starting bot: ${error.message}`);
        │   870 │         }
        │   871 │     }, [config, timeframes, tradingLoop, addLog]);
        │   872 │
        │   873 │         // Stop bot
        │   874 │     const stopBot = useCallback((): void => {
        │   875 │         setBotStatus(prev => ({ ...prev, is_running: false }));
        │   876 │
        │   877 │         if (intervalRef.current) {
        │   878 │             clearInterval(intervalRef.current);
        │   879 │             intervalRef.current = null;
        │   880 │         }
        │   881 │
        │   882 │         if (monitorRef.current) {
        │   883 │             clearInterval(monitorRef.current);
        │   884 │             monitorRef.current = null;
        │   885 │         }
        │   886 │
        │   887 │         addLog('⏹️ Decycler Bot Stopped');
        │   888 │     }, [addLog]);
        │   889 │
        │   890 │     // Handle contract updates from API
        │   891 │     useEffect(() => {
        │   892 │         const handleApiResponse = (response: any) => {
        │   893 │             if (response && response.proposal_open_contract) {
        │   894 │                 const contract = response.proposal_open_contract;
        │   895 │
        │   896 │                 setBotStatus(prev => {
        │   897 │                     if (!prev.current_contract || prev.current_contract.id !== contract.contract_id) {
        │   898 │                         return prev;
        │   899 │                     }
        │   900 │
        │   901 │                     const updatedContract: ContractInfo = {
        │   902 │                         ...prev.current_contract,
        │   903 │                         current_price: contract.current_spot || prev.current_contract.current_price,
        │   904 │                         profit: contract.profit || 0,
        │   905 │                         status: contract.is_sold ? 'closed' : 'open'
        │   906 │                     };
        │   907 │
        │   908 │                     // Handle risk management
        │   909 │                     if (config.use_trailing_stop && contract.profit > 0) {
        │   910 │                         const newTrailingStop = prev.current_contract.entry_price + contract.profit - config.trailing_step;
        │   911 │                         if (newTrailingStop > updatedContract.trailing_stop) {
        │   912 │                             updatedContract.trailing_stop = newTrailingStop;
        │   913 │                             addLog(`📈 Trailing stop updated to ${newTrailingStop.toFixed(5)}`);
        │   914 │                         }
        │   915 │                     }
        │   916 │
        │   917 │                     // Handle breakeven
        │   918 │                     if (config.use_breakeven && !updatedContract.breakeven_active && contract.profit >= config.breakeven_trigger) {
        │   919 │                         updatedContract.stop_loss = prev.current_contract.entry_price;
        │   920 │                         updatedContract.breakeven_active = true;
        │   921 │                         addLog(`⚖️ Breakeven protection activated`);
        │   922 │                     }
        │   923 │
        │   924 │                     // Check if contract closed
        │   925 │                     if (contract.is_sold) {
        │   926 │                         const isWin = contract.profit > 0;
        │   927 │                         addLog(`${isWin ? '🎉' : '💔'} Contract closed: ${isWin ? 'WIN' : 'LOSS'} - P&L: ${contract.profit.toFixed(2)}`);
        │   928 │
        │   929 │                         return {
        │   930 │                             ...prev,
        │   931 │                             current_contract: null,
        │   932 │                             winning_trades: isWin ? prev.winning_trades + 1 : prev.winning_trades,
        │   933 │                             total_pnl: prev.total_pnl + contract.profit
        │   934 │                         };
        │   935 │                     }
        │   936 │
        │   937 │                     return {
        │   938 │                         ...prev,
        │   939 │                         current_contract: updatedContract
        │   940 │                     };
        │   941 │                 });
        │   942 │             }
        │   943 │         };
        │   944 │
        │   945 │         // Listen for API responses
        │   946 │         if (typeof window !== 'undefined' && (window as any).globalObserver) {
        │   947 │             const globalObserver = (window as any).globalObserver;
        │   948 │             globalObserver.register('api.response', handleApiResponse);
        │   949 │
        │   950 │             return () => {
        │   951 │                 globalObserver.unregister('api.response', handleApiResponse);
        │   952 │             };
        │   953 │         }
        │   954 │     }, [config, addLog]);
        │   955 │
        │   956 │     // Comprehensive API connection and data testing
        │   957 │     const testConnection = useCallback(async (): Promise<void> => {
        │   958 │         try {
        │   959 │             addLog('🔍 Starting comprehensive API connection test...');
        │   960 │
        │   961 │             // Step 1: Test WebSocket connection
        │   962 │             if (!api_base.api || api_base.api.connection.readyState !== 1) {
        │   963 │                 addLog('🔌 Initializing API connection...');
        │   964 │                 await api_base.init();
        │   965 │
        │   966 │                 let retries = 0;
        │   967 │                 while ((!api_base.api || api_base.api.connection.readyState !== 1) && retries < 15) {
        │   968 │                     await new Promise(resolve => setTimeout(resolve, 1000));
        │   969 │                     retries++;
        │   970 │                     if (retries % 3 === 0) {
        │   971 │                         addLog(`⏳ Waiting for connection... (${retries}/15)`);
        │   972 │                     }
        │   973 │                 }
        │   974 │             }
        │   975 │
        │   976 │             if (!api_base.api || api_base.api.connection.readyState !== 1) {
        │   977 │                 addLog('❌ Failed to establish WebSocket connection');
        │   978 │                 return;
        │   979 │             }
        │   980 │
        │   981 │             addLog(`✅ WebSocket connected (Ready State: ${api_base.api.connection.readyState})`);
        │   982 │
        │   983 │             // Step 2: Test basic API communication
        │   984 │             const timeResponse = await Promise.race([
        │   985 │                 api_base.api.send({ time: 1 }),
        │   986 │                 new Promise((_, reject) => setTimeout(() => reject(new Error('Time request timeout')), 5000))
        │   987 │             ]);
        │   988 │
        │   989 │             if (timeResponse?.time) {
        │   990 │                 addLog(`✅ API communication test successful. Server time: ${new Date(timeResponse.time * 1000).toLocaleString()}`);
        │   991 │             } else {
        │   992 │                 addLog('❌ API communication test failed - no server time received');
        │   993 │                 return;
        │   994 │             }
        │   995 │
        │   996 │             // Step3: Test symbol existence
        │   997 │             addLog(`🔍 Testing symbol availability: ${config.symbol}`);
        │   998 │
        │   999 │         try {
        │  1000 │                 const symbolTest = await Promise.race([
        │  1001 │                     api_base.api.send({
        │  1002 │                         active_symbols: 'brief',
        │  1003 │                         product_type: 'basic'
        │  1004 │                     }),
        │  1005 │                     new Promise((_, reject) => setTimeout(() => reject(new Error('Symbol test timeout')), 8000))
        │  1006 │                 ]);
        │  1007 │
        │  1008 │                 if (symbolTest?.active_symbols) {
        │  1009 │                     const symbolExists = symbolTest.active_symbols.some(s => s.symbol === config.symbol);
        │  1010 │                     if (symbolExists) {
        │  1011 │                         addLog(`✅ Symbol ${config.symbol} is available for trading`);
        │  1012 │                     } else {
        │  1013 │                         addLog(`⚠️ Symbol ${config.symbol} not found in active symbols list`);
        │  1014 │                     }
        │  1015 │                 }
        │  1016 │             } catch (symbolError) {
        │  1017 │                 addLog(`⚠️ Could not verify symbol availability: ${symbolError.message}`);
        │  1018 │             }
        │  1019 │
        │  1020 │             // Step 4: Test data retrieval for each timeframe
        │  1021 │             addLog('📊 Testing data retrieval for all timeframes...');
        │  1022 │
        │  1023 │             const testResults = {};
        │  1024 │             for (const tf of timeframes) {
        │  1025 │                 try {
        │  1026 │                     addLog(`🔄 Testing ${tf} data...`);
        │  1027 │                     const testData = await fetchOHLCData(tf);
        │  1028 │                     testResults[tf] = testData.length;
        │  1029 │
        │  1030 │                     if (testData.length > 0) {
        │  1031 │                         addLog(`✅ ${tf}: ${testData.length} data points retrieved`);
        │  1032 │                     } else {
        │  1033 │                         addLog(`❌ ${tf}: No data retrieved`);
        │  1034 │                     }
        │  1035 │
        │  1036 │                     // Small delay between requests to avoid rate limiting
        │  1037 │                     await new Promise(resolve => setTimeout(resolve, 200));
        │  1038 │                 } catch (tfError) {
        │  1039 │                     addLog(`❌ ${tf}: Error - ${tfError.message}`);
        │  1040 │                     testResults[tf] = 0;
        │  1041 │                 }
        │  1042 │             }
        │  1043 │
        │  1044 │             // Step 5: Summary
        │  1045 │             const successfulTimeframes = Object.values(testResults).filter(count => count > 0).length;
        │  1046 │             const totalTimeframes = timeframes.length;
        │  1047 │
        │  1048 │             addLog(`📋 Test Summary: ${successfulTimeframes}/${totalTimeframes} timeframes working`);
        │  1049 │
        │  1050 │             if (successfulTimeframes === 0) {
        │  1051 │                 addLog('❌ No timeframes working - try a different symbol or check API connection');
        │  1052 │             } else if (successfulTimeframes < totalTimeframes) {
        │  1053 │                 addLog(`⚠️ Partial success - ${totalTimeframes - successfulTimeframes} timeframes failed`);
        │  1054 │             } else {
        │  1055 │                 addLog('🎉 All timeframes working perfectly!');
        │  1056 │
        │  1057 │                 // If test was successful, run the analysis to populate the UI
        │  1058 │                 if (successfulTimeframes > 0) {
        │  1059 │                     addLog('🔄 Running multi-timeframe analysis...');
        │  1060 │                     await analyzeAllTimeframes();
        │  1061 │                 }
        │  1062 │             }
        │  1063 │
        │  1064 │         } catch (error) {
        │  1065 │             addLog(`❌ Connection test failed: ${error.message}`);
        │  1066 │             console.error('Detailed connection test error:', error);
        │  1067 │         }
        │  1068 │     }, [fetchOHLCData, config.symbol, addLog, timeframes]);
        │  1069 │
        │  1070 │     // Cleanup on unmount
        │  1071 │     useEffect(() => {
        │  1072 │         return () => {
        │  1073 │             if (intervalRef.current) clearInterval(intervalRef.current);
        │  1074 │             if (monitorRef.current) clearInterval(monitorRef.current);
        │  1075 │         };
        │  1076 │     }, []);
        │  1077 │
        │  1078 │     const getTrendColor = (trend: string): string => {
        │  1079 │         switch (trend) {
        │  1080 │             case 'bullish': return '#00ff88';
        │  1081 │             case 'bearish': return '#ff4757';
        │  1082 │             default: return '#ffa502';
        │  1083 │         }
        │  1084 │     };
        │  1085 │
        │  1086 │     const getAlignmentColor = (alignment: string): string => {
        │  1087 │         switch (alignment) {
        │  1088 │             case 'aligned_bullish': return '#00ff88';
        │  1089 │             case 'aligned_bearish': return '#ff4757';
        │  1090 │             case 'mixed': return '#ffa502';
        │  1091 │             default: return '#74b9ff';
        │  1092 │         }
        │  1093 │     };
        │  1094 │
        │  1095 │     // Define WebSocket and currentSymbol
        │  1096 │     const [ws, setWs] = useState<WebSocket | null>(null);
        │  1097 │     const [currentSymbol, setCurrentSymbol] = useState(config.symbol);
        │  1098 │     const [timeframeAnalysis, setTimeframeAnalysis] = useState<{ [key: string]: string }>({});
        │  1099 │     const [overallAnalysis, setOverallAnalysis] = useState('NEUTRAL');
        │  1100 │
        │  1101 │     useEffect(() => {
        │  1102 │         setCurrentSymbol(config.symbol); // Update currentSymbol when config.symbol changes
        │  1103 │     }, [config.symbol]);
        │  1104 │
        │  1105 │     // Establish WebSocket connection on component mount
        │  1106 │   const authorizeAPI = async (token: string) => {
        │  1107 │     try {
        │  1108 │       const ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=75771');
        │  1109 │
        │  1110 │       return new Promise((resolve, reject) => {
        │  1111 │         ws.onopen = () => {
        │  1112 │           ws.send(JSON.stringify({
        │  1113 │             authorize: token,
        │  1114 │             req_id: Date.now()
        │  1115 │           }));
        │  1116 │         };
        │  1117 │
        │  1118 │         ws.onmessage = (event) => {
        │  1119 │           const data = JSON.parse(event.data);
        │  1120 │           if (data.authorize) {
        │  1121 │             setIsAuthorized(true);
        │  1122 │             setAuthToken(token);
        │  1123 │             ws.close();
        │  1124 │             resolve(data);
        │  1125 │           } else if (data.error) {
        │  1126 │             ws.close();
        │  1127 │             reject(data.error);
        │  1128 │           }
        │  1129 │         };
        │  1130 │
        │  1131 │         ws.onerror = (error) => {
        │  1132 │           ws.close();
        │  1133 │           reject(error);
        │  1134 │         };
        │  1135 │       });
        │  1136 │     } catch (error) {
        │  1137 │       console.error('Authorization failed:', error);
        │  1138 │       throw error;
        │  1139 │     }
        │  1140 │   };
        │  1141 │
        │  1142 │   // Contract Purchase Function
        │  1143 │   const purchaseContract = async (direction: 'CALL' | 'PUT') => {
        │  1144 │     if (!isAuthorized || !authToken || currentContract) {
        │  1145 │       return;
        │  1146 │     }
        │  1147 │
        │  1148 │     try {
        │  1149 │       const ws = new WebSocket('wss://ws.derivws.com/websockets/v3?app_id=75771');
        │  1150 │
        │  1151 │       return new Promise((resolve, reject) => {
        │  1152 │         ws.onopen = () => {
        │  1153 │           // First get proposal
        │  1154 │           const proposalRequest = {
        │  1155 │             proposal: 1,
        │  1156 │             amount: parseFloat(config.stake),
        │  1157 │             basis: 'stake',
        │  1158 │             contract_type: direction,
        │  1159 │             currency: 'USD',
        │  1160 │             duration: parseInt(config.tick_count),
        │  1161 │             duration_unit: 't',
        │  1162 │             symbol: config.symbol,
        │  1163 │             req_id: Date.now()
        │  1164 │           };
        │  1165 │
        │  1166 │           ws.send(JSON.stringify(proposalRequest));
        │  1167 │         };
        │  1168 │
        │  1169 │         ws.onmessage = (event) => {
        │  1170 │           const data = JSON.parse(event.data);
        │  1171 │
        │  1172 │           if (data.proposal) {
        │  1173 │             // Purchase the contract
        │  1174 │             const buyRequest = {
        │  1175 │               buy: data.proposal.id,
        │  1176 │               price: parseFloat(config.stake),
        │  1177 │               req_id: Date.now() + 1
        │  1178 │             };
        │  1179 │
        │  1180 │             ws.send(JSON.stringify(buyRequest));
        │  1181 │           } else if (data.buy) {
        │  1182 │             setCurrentContract({
        │  1183 │               id: data.buy.contract_id,
        │  1184 │               type: direction,
        │  1185 │               stake: parseFloat(config.stake),
        │  1186 │               startTime: Date.now(),
        │  1187 │               payout: data.buy.payout
        │  1188 │             });
        │  1189 │
        │  1190 │             setLastSignal(`Contract purchased: ${direction} for $${config.stake}`);
        │  1191 │             ws.close();
        │  1192 │             resolve(data);
        │  1193 │           } else if (data.error) {
        │  1194 │             setLastSignal(`Purchase failed: ${data.error.message}`);
        │  1195 │             ws.close();
        │  1196 │             reject(data.error);
        │  1197 │           }
        │  1198 │         };
        │  1199 │
        │  1200 │         ws.onerror = (error) => {
        │  1201 │           ws.close();
        │  1202 │           reject(error);
        │  1203 │         };
        │  1204 │       });
        │  1205 │     } catch (error) {
        │  1206 │       console.error('Contract purchase failed:', error);
        │  1207 │       setLastSignal(`Purchase error: ${error}`);
        │  1208 │     }
        │  1209 │   };
        │  1210 │
        │  1211 │   // Monitor Contract Status
        │  1212 │   const monitorContract = async (contractId: string) => {
        │       ·         ───────┬───────
        │       ·                ╰── `monitorContract` redefined here
        │  1213 │     if (!contractId) return;
        │  1214 │
        │  1215 │     try {
        │       ╰────
        │
Fix error, click outside, or press Esc to close the overlay.

Disable overlay by setting Rsbuild's dev.client.overlay config to false.