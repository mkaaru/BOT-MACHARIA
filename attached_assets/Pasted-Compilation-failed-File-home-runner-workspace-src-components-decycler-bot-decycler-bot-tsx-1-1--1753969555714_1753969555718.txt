Compilation failed

File: /home/runner/workspace/src/components/decycler-bot/decycler-bot.tsx:1:1
  Ã— Module build failed:
  â•°â”€â–¶   Ã—   Ã— the name `convertTicksToCandles` is defined multiple times
        â”‚       â•­â”€[/home/runner/workspace/src/components/decycler-bot/decycler-bot.tsx:339:1]
        â”‚   336 â”‚     }, [config.symbol, addLog]);
        â”‚   337 â”‚
        â”‚   338 â”‚     // Helper function to convert tick data to candles
        â”‚   339 â”‚     const convertTicksToCandles = useCallback((prices: number[], times: number[], granularity: number): any[] => {
        â”‚       Â·           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        â”‚       Â·                     â•°â”€â”€ previous definition of `convertTicksToCandles` here
        â”‚   340 â”‚         if (!prices || !times || prices.length !== times.length || prices.length === 0) {
        â”‚   341 â”‚             addLog(`âš ï¸ Invalid tick data for candle conversion: prices=${prices?.length}, times=${times?.length}`);
        â”‚   342 â”‚             return [];
        â”‚   343 â”‚         }
        â”‚   344 â”‚
        â”‚   345 â”‚         const candles: any[] = [];
        â”‚   346 â”‚         let currentCandle: any = null;
        â”‚   347 â”‚         let tickCount = 0;
        â”‚   348 â”‚
        â”‚   349 â”‚         for (let i = 0; i < prices.length; i++) {
        â”‚   350 â”‚             const price = parseFloat(prices[i]);
        â”‚   351 â”‚             const time = times[i];
        â”‚   352 â”‚
        â”‚   353 â”‚             if (isNaN(price) || !time) {
        â”‚   354 â”‚                 continue; // Skip invalid data
        â”‚   355 â”‚             }
        â”‚   356 â”‚
        â”‚   357 â”‚             const candleTime = Math.floor(time / granularity) * granularity;
        â”‚   358 â”‚
        â”‚   359 â”‚             if (!currentCandle || currentCandle.epoch !== candleTime) {
        â”‚   360 â”‚                 // Start new candle
        â”‚   361 â”‚                 if (currentCandle && tickCount > 0) {
        â”‚   362 â”‚                     candles.push({
        â”‚   363 â”‚                         ...currentCandle,
        â”‚   364 â”‚                         timeframe: `${granularity}s`,
        â”‚   365 â”‚                         tickCount: tickCount
        â”‚   366 â”‚                     });
        â”‚   367 â”‚                 }
        â”‚   368 â”‚                 currentCandle = {
        â”‚   369 â”‚                     epoch: candleTime,
        â”‚   370 â”‚                     open: price,
        â”‚   371 â”‚                     high: price,
        â”‚   372 â”‚                     low: price,
        â”‚   373 â”‚                     close: price
        â”‚   374 â”‚                 };
        â”‚   375 â”‚                 tickCount = 1;
        â”‚   376 â”‚             } else {
        â”‚   377 â”‚                 // Update existing candle with proper OHLC calculation
        â”‚   378 â”‚                 currentCandle.high = Math.max(currentCandle.high, price);
        â”‚   379 â”‚                 currentCandle.low = Math.min(currentCandle.low, price);
        â”‚   380 â”‚                 currentCandle.close = price; // Last price becomes close
        â”‚   381 â”‚                 tickCount++;
        â”‚   382 â”‚             }
        â”‚   383 â”‚         }
        â”‚   384 â”‚
        â”‚   385 â”‚         // Add the last candle if it has data
        â”‚   386 â”‚         if (currentCandle && tickCount > 0) {
        â”‚   387 â”‚             candles.push({
        â”‚   388 â”‚                 ...currentCandle,
        â”‚   389 â”‚                 timeframe: `${granularity}s`,
        â”‚   390 â”‚                 tickCount: tickCount
        â”‚   391 â”‚             });
        â”‚   392 â”‚         }
        â”‚   393 â”‚
        â”‚   394 â”‚         // Log OHLC summary for debugging
        â”‚   395 â”‚         if (candles.length > 0) {
        â”‚   396 â”‚             const firstCandle = candles[0];
        â”‚   397 â”‚             const lastCandle = candles[candles.length - 1];
        â”‚   398 â”‚             addLog(`ğŸ“Š Candle conversion summary: ${candles.length} candles generated`);
        â”‚   399 â”‚             addLog(`ğŸ“Š First candle OHLC: O=${firstCandle.open}, H=${firstCandle.high}, L=${firstCandle.low}, C=${firstCandle.close}`);
        â”‚   400 â”‚             addLog(`ğŸ“Š Last candle OHLC: O=${lastCandle.open}, H=${lastCandle.high}, L=${lastCandle.low}, C=${lastCandle.close}`);
        â”‚   401 â”‚         }
        â”‚   402 â”‚
        â”‚   403 â”‚         return candles;
        â”‚   404 â”‚     }, [addLog]);
        â”‚   405 â”‚
        â”‚   406 â”‚     // Analyze all timeframes
        â”‚   407 â”‚     const analyzeAllTimeframes = useCallback(async (): Promise<TrendData[]> => {
        â”‚   408 â”‚         const trends: TrendData[] = [];
        â”‚   409 â”‚
        â”‚   410 â”‚         addLog('ğŸ“Š Starting multi-timeframe analysis...');
        â”‚   411 â”‚
        â”‚   412 â”‚         // Process timeframes sequentially to avoid overwhelming the API
        â”‚   413 â”‚         for (const timeframe of timeframes) {
        â”‚   414 â”‚             try {
        â”‚   415 â”‚                 addLog(`ğŸ”„ Analyzing ${timeframe} timeframe...`);
        â”‚   416 â”‚
        â”‚   417 â”‚                 const candles = await fetchOHLCData(timeframe);
        â”‚   418 â”‚                 if (candles.length === 0) {
        â”‚   419 â”‚                     addLog(`âš ï¸ No data received for ${timeframe} - skipping`);
        â”‚   420 â”‚                     // Add neutral trend for missing data
        â”‚   421 â”‚                     trends.push({
        â”‚   422 â”‚                         timeframe,
        â”‚   423 â”‚                         trend: 'neutral',
        â”‚   424 â”‚                         value: 0,
        â”‚   425 â”‚                         timestamp: Date.now()
        â”‚   426 â”‚                     });
        â”‚   427 â”‚                     continue;
        â”‚   428 â”‚                 }
        â”‚   429 â”‚
        â”‚   430 â”‚                 const closePrices = candles.map(candle => parseFloat(candle.close));
        â”‚   431 â”‚                 addLog(`ğŸ“ˆ Processing ${closePrices.length} prices for ${timeframe}`);
        â”‚   432 â”‚
        â”‚   433 â”‚                 if (closePrices.length < 3) {
        â”‚   434 â”‚                     addLog(`âš ï¸ Insufficient data for ${timeframe} (need 3+ prices, got ${closePrices.length})`);
        â”‚   435 â”‚                     trends.push({
        â”‚   436 â”‚                         timeframe,
        â”‚   437 â”‚                         trend: 'neutral',
        â”‚   438 â”‚                         value: 0,
        â”‚   439 â”‚                         timestamp: Date.now()
        â”‚   440 â”‚                     });
        â”‚   441 â”‚                     continue;
        â”‚   442 â”‚                 }
        â”‚   443 â”‚
        â”‚   444 â”‚                 const decyclerValues = calculateDecycler(closePrices, config.alpha);
        â”‚   445 â”‚                 if (decyclerValues.length === 0) {
        â”‚   446 â”‚                     addLog(`âš ï¸ Failed to calculate Decycler for ${timeframe}`);
        â”‚   447 â”‚                     trends.push({
        â”‚   448 â”‚                         timeframe,
        â”‚   449 â”‚                         trend: 'neutral',
        â”‚   450 â”‚                         value: 0,
        â”‚   451 â”‚                         timestamp: Date.now()
        â”‚   452 â”‚                     });
        â”‚   453 â”‚                     continue;
        â”‚   454 â”‚                 }
        â”‚   455 â”‚
        â”‚   456 â”‚                 const trend = getTrend(decyclerValues);
        â”‚   457 â”‚                 const currentValue = decyclerValues[decyclerValues.length - 1] || 0;
        â”‚   458 â”‚
        â”‚   459 â”‚                 trends.push({
        â”‚   460 â”‚                     timeframe,
        â”‚   461 â”‚                     trend,
        â”‚   462 â”‚                     value: currentValue,
        â”‚   463 â”‚                     timestamp: Date.now()
        â”‚   464 â”‚                 });
        â”‚   465 â”‚
        â”‚   466 â”‚                 addLog(`âœ… ${timeframe}: ${trend.toUpperCase()} (Value: ${currentValue.toFixed(5)})`);
        â”‚   467 â”‚
        â”‚   468 â”‚                 // Small delay between requests to prevent rate limiting
        â”‚   469 â”‚                 await new Promise(resolve => setTimeout(resolve, 200));
        â”‚   470 â”‚
        â”‚   471 â”‚             } catch (error) {
        â”‚   472 â”‚                 addLog(`âŒ Error analyzing ${timeframe}: ${error.message}`);
        â”‚   473 â”‚                 // Add neutral trend for error cases
        â”‚   474 â”‚                 trends.push({
        â”‚   475 â”‚                     timeframe,
        â”‚   476 â”‚                     trend: 'neutral',
        â”‚   477 â”‚                     value: 0,
        â”‚   478 â”‚                     timestamp: Date.now()
        â”‚   479 â”‚                 });
        â”‚   480 â”‚             }
        â”‚   481 â”‚         }
        â”‚   482 â”‚
        â”‚   483 â”‚         addLog(`ğŸ“‹ Multi-timeframe analysis complete: ${trends.length}/${timeframes.length} timeframes processed`);
        â”‚   484 â”‚         return trends;
        â”‚   485 â”‚     }, [timeframes, fetchOHLCData, calculateDecycler, getTrend, config.alpha, addLog]);
        â”‚   486 â”‚
        â”‚   487 â”‚     // Check trend alignment
        â”‚   488 â”‚     const checkAlignment = useCallback((trends: TrendData[]): 'aligned_bullish' | 'aligned_bearish' | 'mixed' | 'neutral' => {
        â”‚   489 â”‚         if (trends.length === 0) return 'neutral';
        â”‚   490 â”‚
        â”‚   491 â”‚         const bullishCount = trends.filter(t => t.trend === 'bullish').length;
        â”‚   492 â”‚         const bearishCount = trends.filter(t => t.trend === 'bearish').length;
        â”‚   493 â”‚         const neutralCount = trends.filter(t => t.trend === 'neutral').length;
        â”‚   494 â”‚
        â”‚   495 â”‚         if (bullishCount === trends.length) return 'aligned_bullish';
        â”‚   496 â”‚         if (bearishCount === trends.length) return 'aligned_bearish';
        â”‚   497 â”‚         if (bullishCount > bearishCount && bullishCount >= trends.length * 0.7) return 'aligned_bullish';
        â”‚   498 â”‚         if (bearishCount > bullishCount && bearishCount >= trends.length * 0.7) return 'aligned_bearish';
        â”‚   499 â”‚         return 'mixed';
        â”‚   500 â”‚     }, []);
        â”‚   501 â”‚
        â”‚   502 â”‚     // Execute trade
        â”‚   503 â”‚     const executeTrade = useCallback(async (direction: 'UP' | 'DOWN'): Promise<void> => {
        â”‚   504 â”‚         if (!api_base.api) {
        â”‚   505 â”‚             addLog('âŒ API not connected');
        â”‚   506 â”‚             return;
        â”‚   507 â”‚         }
        â”‚   508 â”‚
        â”‚   509 â”‚         try {
        â”‚   510 â”‚             const contractTypeMap = {
        â”‚   511 â”‚                 rise_fall: direction === 'UP' ? 'CALL' : 'PUT',
        â”‚   512 â”‚                 higher_lower: direction === 'UP' ? 'CALLE' : 'PUTE'
        â”‚   513 â”‚             };
        â”‚   514 â”‚
        â”‚   515 â”‚             const contractType = contractTypeMap[config.contract_type];
        â”‚   516 â”‚
        â”‚   517 â”‚             // Get proposal
        â”‚   518 â”‚             const proposalRequest = {
        â”‚   519 â”‚                 proposal: 1,
        â”‚   520 â”‚                 amount: config.stake,
        â”‚   521 â”‚                 basis: 'stake',
        â”‚   522 â”‚                 contract_type: contractType,
        â”‚   523 â”‚                 currency: 'USD',
        â”‚   524 â”‚                 duration: config.tick_count,
        â”‚   525 â”‚                 duration_unit: 't',
        â”‚   526 â”‚                 symbol: config.symbol
        â”‚   527 â”‚             };
        â”‚   528 â”‚
        â”‚   529 â”‚             addLog(`ğŸ”„ Getting proposal for ${contractType} on ${config.symbol}...`);
        â”‚   530 â”‚             const proposalResponse = await api_base.api.send(proposalRequest);
        â”‚   531 â”‚
        â”‚   532 â”‚             if (proposalResponse.error) {
        â”‚   533 â”‚                 addLog(`âŒ Proposal error: ${proposalResponse.error.message}`);
        â”‚   534 â”‚                 return;
        â”‚   535 â”‚             }
        â”‚   536 â”‚
        â”‚   537 â”‚             const proposalId = proposalResponse.proposal.id;
        â”‚   538 â”‚             const entrySpot = proposalResponse.proposal.spot;
        â”‚   539 â”‚
        â”‚   540 â”‚             // Purchase contract
        â”‚   541 â”‚             const buyRequest = {
        â”‚   542 â”‚                 buy: proposalId,
        â”‚   543 â”‚                 price: config.stake
        â”‚   544 â”‚             };
        â”‚   545 â”‚
        â”‚   546 â”‚             addLog(`ğŸ’° Purchasing contract ${proposalId}...`);
        â”‚   547 â”‚             const buyResponse = await api_base.api.send(buyRequest);
        â”‚   548 â”‚
        â”‚   549 â”‚             if (buyResponse.error) {
        â”‚   550 â”‚                 addLog(`âŒ Purchase error: ${buyResponse.error.message}`);
        â”‚   551 â”‚                 return;
        â”‚   552 â”‚             }
        â”‚   553 â”‚
        â”‚   554 â”‚             const contractId = buyResponse.buy.contract_id;
        â”‚   555 â”‚             addLog(`âœ… Contract purchased: ${contractId}`);
        â”‚   556 â”‚
        â”‚   557 â”‚             // Update contract info
        â”‚   558 â”‚             const newContract: ContractInfo = {
        â”‚   559 â”‚                 id: contractId,
        â”‚   560 â”‚                 type: contractType,
        â”‚   561 â”‚                 entry_price: entrySpot,
        â”‚   562 â”‚                 current_price: entrySpot,
        â”‚   563 â”‚                 profit: 0,
        â”‚   564 â”‚                 status: 'open',
        â”‚   565 â”‚                 entry_time: Date.now(),
        â”‚   566 â”‚                 direction,
        â”‚   567 â”‚                 stop_loss: entrySpot + config.stop_loss,
        â”‚   568 â”‚                 take_profit: entrySpot + config.take_profit,
        â”‚   569 â”‚                 trailing_stop: config.use_trailing_stop ? entrySpot + config.stop_loss : 0,
        â”‚   570 â”‚                 breakeven_active: false
        â”‚   571 â”‚             };
        â”‚   572 â”‚
        â”‚   573 â”‚             setBotStatus(prev => ({
        â”‚   574 â”‚                 ...prev,
        â”‚   575 â”‚                 current_contract: newContract,
        â”‚   576 â”‚                 total_trades: prev.total_trades + 1
        â”‚   577 â”‚             }));
        â”‚   578 â”‚
        â”‚   579 â”‚             // Start monitoring the contract
        â”‚   580 â”‚             monitorContract(contractId);
        â”‚   581 â”‚
        â”‚   582 â”‚         } catch (error) {
        â”‚   583 â”‚             addLog(`âŒ Trade execution failed: ${error.message}`);
        â”‚   584 â”‚         }
        â”‚   585 â”‚     }, [config, addLog]);
        â”‚   586 â”‚
        â”‚   587 â”‚     // Monitor open contract
        â”‚   588 â”‚     const monitorContract = useCallback(async (contractId: string): Promise<void> => {
        â”‚   589 â”‚         if (!api_base.api) return;
        â”‚   590 â”‚
        â”‚   591 â”‚         try {
        â”‚   592 â”‚             const request = {
        â”‚   593 â”‚                 proposal_open_contract: 1,
        â”‚   594 â”‚                 contract_id: contractId,
        â”‚   595 â”‚                 subscribe: 1
        â”‚   596 â”‚             };
        â”‚   597 â”‚
        â”‚   598 â”‚             const response = await api_base.api.send(request);
        â”‚   599 â”‚
        â”‚   600 â”‚             if (response.error) {
        â”‚   601 â”‚                 addLog(`âŒ Contract monitoring error: ${response.error.message}`);
        â”‚   602 â”‚                 return;
        â”‚   603 â”‚             }
        â”‚   604 â”‚
        â”‚   605 â”‚             addLog(`ğŸ‘ï¸ Monitoring contract ${contractId}`);
        â”‚   606 â”‚         } catch (error) {
        â”‚   607 â”‚             addLog(`âŒ Failed to monitor contract: ${error.message}`);
        â”‚   608 â”‚         }
        â”‚   609 â”‚     }, [addLog]);
        â”‚   610 â”‚
        â”‚   611 â”‚     // Main trading loop
        â”‚   612 â”‚     const tradingLoop = useCallback(async (): Promise<void> => {
        â”‚   613 â”‚         if (!botStatus.is_running) return;
        â”‚   614 â”‚
        â”‚   615 â”‚         try {
        â”‚   616 â”‚             addLog('ğŸ”„ Starting trading analysis cycle...');
        â”‚   617 â”‚
        â”‚   618 â”‚             // Analyze all timeframes
        â”‚   619 â”‚             const trends = await analyzeAllTimeframes();
        â”‚   620 â”‚
        â”‚   621 â”‚             if (trends.length === 0) {
        â”‚   622 â”‚                 addLog('âš ï¸ No trend data available - will retry next cycle');
        â”‚   623 â”‚                 setBotStatus(prev => ({
        â”‚   624 â”‚                     ...prev,
        â”‚   625 â”‚                     error_message: 'No trend data available',
        â”‚   626 â”‚                     last_update: Date.now()
        â”‚   627 â”‚                 }));
        â”‚   628 â”‚                 return;
        â”‚   629 â”‚             }
        â”‚   630 â”‚
        â”‚   631 â”‚             const alignment = checkAlignment(trends);
        â”‚   632 â”‚
        â”‚   633 â”‚             // Update bot status with new analysis
        â”‚   634 â”‚             setBotStatus(prev => ({
        â”‚   635 â”‚                 ...prev,
        â”‚   636 â”‚                 trends,
        â”‚   637 â”‚                 alignment_status: alignment,
        â”‚   638 â”‚                 last_update: Date.now(),
        â”‚   639 â”‚                 error_message: ''
        â”‚   640 â”‚             }));
        â”‚   641 â”‚
        â”‚   642 â”‚             addLog(`ğŸ“Š Analysis complete - Alignment: ${alignment.toUpperCase()}`);
        â”‚   643 â”‚
        â”‚   644 â”‚             // Log individual timeframe results
        â”‚   645 â”‚             const bullishCount = trends.filter(t => t.trend === 'bullish').length;
        â”‚   646 â”‚             const bearishCount = trends.filter(t => t.trend === 'bearish').length;
        â”‚   647 â”‚             const neutralCount = trends.filter(t => t.trend === 'neutral').length;
        â”‚   648 â”‚
        â”‚   649 â”‚             addLog(`ğŸ“ˆ Trends: ${bullishCount} Bullish, ${bearishCount} Bearish, ${neutralCount} Neutral`);
        â”‚   650 â”‚
        â”‚   651 â”‚             // Check if we should enter a trade
        â”‚   652 â”‚             if (!botStatus.current_contract && (alignment === 'aligned_bullish' || alignment === 'aligned_bearish')) {
        â”‚   653 â”‚                 const direction = alignment === 'aligned_bullish' ? 'UP' : 'DOWN';
        â”‚   654 â”‚
        â”‚   655 â”‚                 // Optional 10s confirmation
        â”‚   656 â”‚                 if (config.use_10s_filter) {
        â”‚   657 â”‚                     addLog('â±ï¸ Applying 10-second confirmation filter...');
        â”‚   658 â”‚                     // Add a small delay for confirmation
        â”‚   659 â”‚                     await new Promise(resolve => setTimeout(resolve, 1000));
        â”‚   660 â”‚                 }
        â”‚   661 â”‚
        â”‚   662 â”‚                 addLog(`ğŸ¯ Strong ${direction} alignment detected - Preparing trade execution!`);
        â”‚   663 â”‚                 await executeTrade(direction);
        â”‚   664 â”‚             } else if (!botStatus.current_contract) {
        â”‚   665 â”‚                 addLog('â³ Waiting for trend alignment - No trade signal yet');
        â”‚   666 â”‚             } else {
        â”‚   667 â”‚                 addLog('ğŸ“Š Active contract in progress - Monitoring...');
        â”‚   668 â”‚             }
        â”‚   669 â”‚
        â”‚   670 â”‚         } catch (error) {
        â”‚   671 â”‚             const errorMsg = `Trading analysis error: ${error.message}`;
        â”‚   672 â”‚             addLog(`âŒ ${errorMsg}`);
        â”‚   673 â”‚             setBotStatus(prev => ({
        â”‚   674 â”‚                 ...prev,
        â”‚   675 â”‚                 error_message: errorMsg,
        â”‚   676 â”‚                 last_update: Date.now()
        â”‚   677 â”‚             }));
        â”‚   678 â”‚         }
        â”‚   679 â”‚     }, [botStatus.is_running, botStatus.current_contract, analyzeAllTimeframes, checkAlignment, config.use_10s_filter, executeTrade, addLog]);
        â”‚   680 â”‚
        â”‚   681 â”‚     // Start bot
        â”‚   682 â”‚     const startBot = useCallback(async (): Promise<void> => {
        â”‚   683 â”‚         try {
        â”‚   684 â”‚             addLog('ğŸ”„ Starting Decycler Bot...');
        â”‚   685 â”‚
        â”‚   686 â”‚             // Initialize API connection
        â”‚   687 â”‚             if (!api_base.api || api_base.api.connection.readyState !== 1) {
        â”‚   688 â”‚                 addLog('ğŸ”Œ Connecting to Deriv API...');
        â”‚   689 â”‚                 await api_base.init();
        â”‚   690 â”‚
        â”‚   691 â”‚                 // Wait for connection to be ready
        â”‚   692 â”‚                 let retries = 0;
        â”‚   693 â”‚                 while ((!api_base.api || api_base.api.connection.readyState !== 1) && retries < 15) {
        â”‚   694 â”‚                     await new Promise(resolve => setTimeout(resolve, 1000));
        â”‚   695 â”‚                     retries++;
        â”‚   696 â”‚                     const readyState = api_base.api?.connection?.readyState || 'undefined';
        â”‚   697 â”‚                     addLog(`â³ Waiting for WebSocket connection... (${retries}/15) - State: ${readyState}`);
        â”‚   698 â”‚                 }
        â”‚   699 â”‚
        â”‚   700 â”‚                 if (!api_base.api || api_base.api.connection.readyState !== 1) {
        â”‚   701 â”‚                     addLog('âŒ Failed to establish WebSocket connection. Please check your internet connection and try again.');
        â”‚   702 â”‚                     return;
        â”‚   703 â”‚                 }
        â”‚   704 â”‚             }
        â”‚   705 â”‚
        â”‚   706 â”‚             // Check connection status
        â”‚   707 â”‚             const connectionStatus = api_base.getConnectionStatus();
        â”‚   708 â”‚             addLog(`ğŸ“¡ Connection Status: ${connectionStatus}`);
        â”‚   709 â”‚
        â”‚   710 â”‚             // Check if WebSocket is actually ready
        â”‚   711 â”‚             const isReady = api_base.api?.connection?.readyState === 1;
        â”‚   712 â”‚             addLog(`ğŸ”Œ WebSocket Ready State: ${api_base.api?.connection?.readyState} (${isReady ? 'OPEN' : 'NOT READY'})`);
        â”‚   713 â”‚
        â”‚   714 â”‚             if (!isReady) {
        â”‚   715 â”‚                 addLog('âŒ WebSocket connection not ready. Please wait and try again.');
        â”‚   716 â”‚                 return;
        â”‚   717 â”‚             }
        â”‚   718 â”‚
        â”‚   719 â”‚             setBotStatus(prev => ({ ...prev, is_running: true }));
        â”‚   720 â”‚             addLog('ğŸš€ Decycler Multi-Timeframe Bot Started!');
        â”‚   721 â”‚             addLog(`ğŸ“Š Monitoring ${timeframes.join(', ')} timeframes`);
        â”‚   722 â”‚             addLog(`ğŸ¯ Symbol: ${config.symbol} | Stake: $${config.stake}`);
        â”‚   723 â”‚             addLog(`âš™ï¸ Contract Type: ${config.contract_type.toUpperCase()}`);
        â”‚   724 â”‚
        â”‚   725 â”‚             // Start trading loop
        â”‚   726 â”‚             intervalRef.current = setInterval(tradingLoop, config.monitor_interval * 1000);
        â”‚   727 â”‚
        â”‚   728 â”‚             // Run initial analysis
        â”‚   729 â”‚             await tradingLoop();
        â”‚   730 â”‚         } catch (error) {
        â”‚   731 â”‚             addLog(`âŒ Error starting bot: ${error.message}`);
        â”‚   732 â”‚         }
        â”‚   733 â”‚     }, [config, timeframes, tradingLoop, addLog]);
        â”‚   734 â”‚
        â”‚   735 â”‚     // Stop bot
        â”‚   736 â”‚     const stopBot = useCallback((): void => {
        â”‚   737 â”‚         setBotStatus(prev => ({ ...prev, is_running: false }));
        â”‚   738 â”‚
        â”‚   739 â”‚         if (intervalRef.current) {
        â”‚   740 â”‚             clearInterval(intervalRef.current);
        â”‚   741 â”‚             intervalRef.current = null;
        â”‚   742 â”‚         }
        â”‚   743 â”‚
        â”‚   744 â”‚         if (monitorRef.current) {
        â”‚   745 â”‚             clearInterval(monitorRef.current);
        â”‚   746 â”‚             monitorRef.current = null;
        â”‚   747 â”‚         }
        â”‚   748 â”‚
        â”‚   749 â”‚         addLog('â¹ï¸ Decycler Bot Stopped');
        â”‚   750 â”‚     }, [addLog]);
        â”‚   751 â”‚
        â”‚   752 â”‚     // Handle contract updates from API
        â”‚   753 â”‚     useEffect(() => {
        â”‚   754 â”‚         const handleApiResponse = (response: any) => {
        â”‚   755 â”‚             if (response && response.proposal_open_contract) {
        â”‚   756 â”‚                 const contract = response.proposal_open_contract;
        â”‚   757 â”‚
        â”‚   758 â”‚                 setBotStatus(prev => {
        â”‚   759 â”‚                     if (!prev.current_contract || prev.current_contract.id !== contract.contract_id) {
        â”‚   760 â”‚                         return prev;
        â”‚   761 â”‚                     }
        â”‚   762 â”‚
        â”‚   763 â”‚                     const updatedContract: ContractInfo = {
        â”‚   764 â”‚                         ...prev.current_contract,
        â”‚   765 â”‚                         current_price: contract.current_spot || prev.current_contract.current_price,
        â”‚   766 â”‚                         profit: contract.profit || 0,
        â”‚   767 â”‚                         status: contract.is_sold ? 'closed' : 'open'
        â”‚   768 â”‚                     };
        â”‚   769 â”‚
        â”‚   770 â”‚                     // Handle risk management
        â”‚   771 â”‚                     if (config.use_trailing_stop && contract.profit > 0) {
        â”‚   772 â”‚                         const newTrailingStop = prev.current_contract.entry_price + contract.profit - config.trailing_step;
        â”‚   773 â”‚                         if (newTrailingStop > updatedContract.trailing_stop) {
        â”‚   774 â”‚                             updatedContract.trailing_stop = newTrailingStop;
        â”‚   775 â”‚                             addLog(`ğŸ“ˆ Trailing stop updated to ${newTrailingStop.toFixed(5)}`);
        â”‚   776 â”‚                         }
        â”‚   777 â”‚                     }
        â”‚   778 â”‚
        â”‚   779 â”‚                     // Handle breakeven
        â”‚   780 â”‚                     if (config.use_breakeven && !updatedContract.breakeven_active && contract.profit >= config.breakeven_trigger) {
        â”‚   781 â”‚                         updatedContract.stop_loss = prev.current_contract.entry_price;
        â”‚   782 â”‚                         updatedContract.breakeven_active = true;
        â”‚   783 â”‚                         addLog(`âš–ï¸ Breakeven protection activated`);
        â”‚   784 â”‚                     }
        â”‚   785 â”‚
        â”‚   786 â”‚                     // Check if contract closed
        â”‚   787 â”‚                     if (contract.is_sold) {
        â”‚   788 â”‚                         const isWin = contract.profit > 0;
        â”‚   789 â”‚                         addLog(`${isWin ? 'ğŸ‰' : 'ğŸ’”'} Contract closed: ${isWin ? 'WIN' : 'LOSS'} - P&L: ${contract.profit.toFixed(2)}`);
        â”‚   790 â”‚
        â”‚   791 â”‚                         return {
        â”‚   792 â”‚                             ...prev,
        â”‚   793 â”‚                             current_contract: null,
        â”‚   794 â”‚                             winning_trades: isWin ? prev.winning_trades + 1 : prev.winning_trades,
        â”‚   795 â”‚                             total_pnl: prev.total_pnl + contract.profit
        â”‚   796 â”‚                         };
        â”‚   797 â”‚                     }
        â”‚   798 â”‚
        â”‚   799 â”‚                     return {
        â”‚   800 â”‚                         ...prev,
        â”‚   801 â”‚                         current_contract: updatedContract
        â”‚   802 â”‚                     };
        â”‚   803 â”‚                 });
        â”‚   804 â”‚             }
        â”‚   805 â”‚         };
        â”‚   806 â”‚
        â”‚   807 â”‚         // Listen for API responses
        â”‚   808 â”‚         if (typeof window !== 'undefined' && (window as any).globalObserver) {
        â”‚   809 â”‚             const globalObserver = (window as any).globalObserver;
        â”‚   810 â”‚             globalObserver.register('api.response', handleApiResponse);
        â”‚   811 â”‚
        â”‚   812 â”‚             return () => {
        â”‚   813 â”‚                 globalObserver.unregister('api.response', handleApiResponse);
        â”‚   814 â”‚             };
        â”‚   815 â”‚         }
        â”‚   816 â”‚     }, [config, addLog]);
        â”‚   817 â”‚
        â”‚   818 â”‚     // Comprehensive API connection and data testing
        â”‚   819 â”‚     const testConnection = useCallback(async (): Promise<void> => {
        â”‚   820 â”‚         try {
        â”‚   821 â”‚             addLog('ğŸ” Starting comprehensive API connection test...');
        â”‚   822 â”‚
        â”‚   823 â”‚             // Step 1: Test WebSocket connection
        â”‚   824 â”‚             if (!api_base.api || api_base.api.connection.readyState !== 1) {
        â”‚   825 â”‚                 addLog('ğŸ”Œ Initializing API connection...');
        â”‚   826 â”‚                 await api_base.init();
        â”‚   827 â”‚
        â”‚   828 â”‚                 let retries = 0;
        â”‚   829 â”‚                 while ((!api_base.api || api_base.api.connection.readyState !== 1) && retries < 15) {
        â”‚   830 â”‚                     await new Promise(resolve => setTimeout(resolve, 1000));
        â”‚   831 â”‚                     retries++;
        â”‚   832 â”‚                     if (retries % 3 === 0) {
        â”‚   833 â”‚                         addLog(`â³ Waiting for connection... (${retries}/15)`);
        â”‚   834 â”‚                     }
        â”‚   835 â”‚                 }
        â”‚   836 â”‚             }
        â”‚   837 â”‚
        â”‚   838 â”‚             if (!api_base.api || api_base.api.connection.readyState !== 1) {
        â”‚   839 â”‚                 addLog('âŒ Failed to establish WebSocket connection');
        â”‚   840 â”‚                 return;
        â”‚   841 â”‚             }
        â”‚   842 â”‚
        â”‚   843 â”‚             addLog(`âœ… WebSocket connected (Ready State: ${api_base.api.connection.readyState})`);
        â”‚   844 â”‚
        â”‚   845 â”‚             // Step 2: Test basic API communication
        â”‚   846 â”‚             const timeResponse = await Promise.race([
        â”‚   847 â”‚                 api_base.api.send({ time: 1 }),
        â”‚   848 â”‚                 new Promise((_, reject) => setTimeout(() => reject(new Error('Time request timeout')), 5000))
        â”‚   849 â”‚             ]);
        â”‚   850 â”‚
        â”‚   851 â”‚             if (timeResponse?.time) {
        â”‚   852 â”‚                 addLog(`âœ… API communication test successful. Server time: ${new Date(timeResponse.time * 1000).toLocaleString()}`);
        â”‚   853 â”‚             } else {
        â”‚   854 â”‚                 addLog('âŒ API communication test failed - no server time received');
        â”‚   855 â”‚                 return;
        â”‚   856 â”‚             }
        â”‚   857 â”‚
        â”‚   858 â”‚             // Step3: Test symbol existence
        â”‚   859 â”‚             addLog(`ğŸ” Testing symbol availability: ${config.symbol}`);
        â”‚   860 â”‚
        â”‚   861 â”‚             try {
        â”‚   862 â”‚                 const symbolTest = await Promise.race([
        â”‚   863 â”‚                     api_base.api.send({
        â”‚   864 â”‚                         active_symbols: 'brief',
        â”‚   865 â”‚                         product_type: 'basic'
        â”‚   866 â”‚                     }),
        â”‚   867 â”‚                     new Promise((_, reject) => setTimeout(() => reject(new Error('Symbol test timeout')), 8000))
        â”‚   868 â”‚                 ]);
        â”‚   869 â”‚
        â”‚   870 â”‚                 if (symbolTest?.active_symbols) {
        â”‚   871 â”‚                     const symbolExists = symbolTest.active_symbols.some(s => s.symbol === config.symbol);
        â”‚   872 â”‚                     if (symbolExists) {
        â”‚   873 â”‚                         addLog(`âœ… Symbol ${config.symbol} is available for trading`);
        â”‚   874 â”‚                     } else {
        â”‚   875 â”‚                         addLog(`âš ï¸ Symbol ${config.symbol} not found in active symbols list`);
        â”‚   876 â”‚                     }
        â”‚   877 â”‚                 }
        â”‚   878 â”‚             } catch (symbolError) {
        â”‚   879 â”‚                 addLog(`âš ï¸ Could not verify symbol availability: ${symbolError.message}`);
        â”‚   880 â”‚             }
        â”‚   881 â”‚
        â”‚   882 â”‚             // Step 4: Test data retrieval for each timeframe
        â”‚   883 â”‚             addLog('ğŸ“Š Testing data retrieval for all timeframes...');
        â”‚   884 â”‚
        â”‚   885 â”‚             const testResults = {};
        â”‚   886 â”‚             for (const tf of timeframes) {
        â”‚   887 â”‚                 try {
        â”‚   888 â”‚                     addLog(`ğŸ”„ Testing ${tf} data...`);
        â”‚   889 â”‚                     const testData = await fetchOHLCData(tf);
        â”‚   890 â”‚                     testResults[tf] = testData.length;
        â”‚   891 â”‚
        â”‚   892 â”‚                     if (testData.length > 0) {
        â”‚   893 â”‚                         addLog(`âœ… ${tf}: ${testData.length} data points retrieved`);
        â”‚   894 â”‚                     } else {
        â”‚   895 â”‚                         addLog(`âŒ ${tf}: No data retrieved`);
        â”‚   896 â”‚                     }
        â”‚   897 â”‚
        â”‚   898 â”‚                     // Small delay between requests to avoid rate limiting
        â”‚   899 â”‚                     await new Promise(resolve => setTimeout(resolve, 200));
        â”‚   900 â”‚                 } catch (tfError) {
        â”‚   901 â”‚                     addLog(`âŒ ${tf}: Error - ${tfError.message}`);
        â”‚   902 â”‚                     testResults[tf] = 0;
        â”‚   903 â”‚                 }
        â”‚   904 â”‚             }
        â”‚   905 â”‚
        â”‚   906 â”‚             // Step 5: Summary
        â”‚   907 â”‚             const successfulTimeframes = Object.values(testResults).filter(count => count > 0).length;
        â”‚   908 â”‚             const totalTimeframes = timeframes.length;
        â”‚   909 â”‚
        â”‚   910 â”‚             addLog(`ğŸ“‹ Test Summary: ${successfulTimeframes}/${totalTimeframes} timeframes working`);
        â”‚   911 â”‚
        â”‚   912 â”‚             if (successfulTimeframes === 0) {
        â”‚   913 â”‚                 addLog('âŒ No timeframes working - try a different symbol or check API connection');
        â”‚   914 â”‚             } else if (successfulTimeframes < totalTimeframes) {
        â”‚   915 â”‚                 addLog(`âš ï¸ Partial success - ${totalTimeframes - successfulTimeframes} timeframes failed`);
        â”‚   916 â”‚             } else {
        â”‚   917 â”‚                 addLog('ğŸ‰ All timeframes working perfectly!');
        â”‚   918 â”‚             }
        â”‚   919 â”‚
        â”‚   920 â”‚         } catch (error) {
        â”‚   921 â”‚             addLog(`âŒ Connection test failed: ${error.message}`);
        â”‚   922 â”‚             console.error('Detailed connection test error:', error);
        â”‚   923 â”‚         }
        â”‚   924 â”‚     }, [fetchOHLCData, config.symbol, addLog, timeframes]);
        â”‚   925 â”‚
        â”‚   926 â”‚     // Cleanup on unmount
        â”‚   927 â”‚     useEffect(() => {
        â”‚   928 â”‚         return () => {
        â”‚   929 â”‚             if (intervalRef.current) clearInterval(intervalRef.current);
        â”‚   930 â”‚             if (monitorRef.current) clearInterval(monitorRef.current);
        â”‚   931 â”‚         };
        â”‚   932 â”‚     }, []);
        â”‚   933 â”‚
        â”‚   934 â”‚     const getTrendColor = (trend: string): string => {
        â”‚   935 â”‚         switch (trend) {
        â”‚   936 â”‚             case 'bullish': return '#00ff88';
        â”‚   937 â”‚             case 'bearish': return '#ff4757';
        â”‚   938 â”‚             default: return '#ffa502';
        â”‚   939 â”‚         }
        â”‚   940 â”‚     };
        â”‚   941 â”‚
        â”‚   942 â”‚     const getAlignmentColor = (alignment: string): string => {
        â”‚   943 â”‚         switch (alignment) {
        â”‚   944 â”‚             case 'aligned_bullish': return '#00ff88';
        â”‚   945 â”‚             case 'aligned_bearish': return '#ff4757';
        â”‚   946 â”‚             case 'mixed': return '#ffa502';
        â”‚   947 â”‚             default: return '#74b9ff';
        â”‚   948 â”‚         }
        â”‚   949 â”‚     };
        â”‚   950 â”‚
        â”‚   951 â”‚     // Define WebSocket and currentSymbol
        â”‚   952 â”‚     const [ws, setWs] = useState<WebSocket | null>(null);
        â”‚   953 â”‚     const [currentSymbol, setCurrentSymbol] = useState(config.symbol);
        â”‚   954 â”‚     const [timeframeAnalysis, setTimeframeAnalysis] = useState<{ [key: string]: string }>({});
        â”‚   955 â”‚     const [overallAnalysis, setOverallAnalysis] = useState('NEUTRAL');
        â”‚   956 â”‚
        â”‚   957 â”‚     useEffect(() => {
        â”‚   958 â”‚         setCurrentSymbol(config.symbol); // Update currentSymbol when config.symbol changes
        â”‚   959 â”‚     }, [config.symbol]);
        â”‚   960 â”‚
        â”‚   961 â”‚     // Establish WebSocket connection on component mount
        â”‚   962 â”‚     useEffect(() => {
        â”‚   963 â”‚         const connectWebSocket = () => {
        â”‚   964 â”‚             const newWs = new WebSocket("wss://ws.binaryws.com/websockets/v3?app_id=75771");
        â”‚   965 â”‚
        â”‚   966 â”‚             newWs.onopen = () => {
        â”‚   967 â”‚                 console.log('âœ… WebSocket connected');
        â”‚   968 â”‚                 setWs(newWs);
        â”‚   969 â”‚             };
        â”‚   970 â”‚
        â”‚   971 â”‚             newWs.onclose = () => {
        â”‚   972 â”‚                 console.log('âŒ WebSocket disconnected');
        â”‚   973 â”‚                 setWs(null);
        â”‚   974 â”‚                 // Reconnect after 5 seconds
        â”‚   975 â”‚                 setTimeout(connectWebSocket, 5000);
        â”‚   976 â”‚             };
        â”‚   977 â”‚
        â”‚   978 â”‚             newWs.onerror = (error) => {
        â”‚   979 â”‚                 console.log('âŒ WebSocket error:', error);
        â”‚   980 â”‚                 setWs(null);
        â”‚   981 â”‚             };
        â”‚   982 â”‚         };
        â”‚   983 â”‚
        â”‚   984 â”‚         connectWebSocket();
        â”‚   985 â”‚
        â”‚   986 â”‚         return () => {
        â”‚   987 â”‚             if (ws) {
        â”‚   988 â”‚                 ws.close();
        â”‚   989 â”‚             }
        â”‚   990 â”‚         };
        â”‚   991 â”‚     }, []);
        â”‚   992 â”‚
        â”‚   993 â”‚     // Fetch market data for all timeframes when component mounts and when symbol changes
        â”‚   994 â”‚     useEffect(() => {
        â”‚   995 â”‚         if (ws && ws.readyState === WebSocket.OPEN) {
        â”‚   996 â”‚             fetchAllTimeframeData();
        â”‚   997 â”‚         } else {
        â”‚   998 â”‚             console.log('âš ï¸ WebSocket not ready to fetch data');
        â”‚   999 â”‚         }
        â”‚  1000 â”‚     }, [ws, currentSymbol]);
        â”‚  1001 â”‚
        â”‚  1002 â”‚     const fetchMarketData = async (symbol: string, timeframe: string) => {
        â”‚  1003 â”‚         if (!ws || ws.readyState !== WebSocket.OPEN) {
        â”‚  1004 â”‚           console.log('âŒ WebSocket not ready for data fetch');
        â”‚  1005 â”‚           return null;
        â”‚  1006 â”‚         }
        â”‚  1007 â”‚
        â”‚  1008 â”‚         return new Promise((resolve, reject) => {
        â”‚  1009 â”‚           const reqId = `candles_${timeframe}_${Date.now()}`;
        â”‚  1010 â”‚
        â”‚  1011 â”‚           // Handle response
        â”‚  1012 â”‚           const handleMessage = (event: MessageEvent) => {
        â”‚  1013 â”‚             try {
        â”‚  1014 â”‚               const data = JSON.parse(event.data);
        â”‚  1015 â”‚               if (data.req_id === reqId) {
        â”‚  1016 â”‚                 ws.removeEventListener('message', handleMessage);
        â”‚  1017 â”‚                 if (data.error) {
        â”‚  1018 â”‚                   console.log(`âŒ Error fetching ${timeframe} data:`, data.error.message);
        â”‚  1019 â”‚                   reject(data.error);
        â”‚  1020 â”‚                 } else if (data.candles) {
        â”‚  1021 â”‚                   console.log(`âœ… Received ${data.candles.length} candles for ${timeframe}`);
        â”‚  1022 â”‚                   console.log(`ğŸ“Š Sample candle:`, data.candles[data.candles.length - 1]);
        â”‚  1023 â”‚                   resolve(data.candles);
        â”‚  1024 â”‚                 } else if (data.history && data.history.prices) {
        â”‚  1025 â”‚                   // Convert tick data to candles for 1HZ symbols
        â”‚  1026 â”‚                   console.log(`ğŸ“ˆ Converting ${data.history.prices.length} ticks to ${timeframe} candles`);
        â”‚  1027 â”‚                   const candles = convertTicksToCandles(data.history.prices, data.history.times, timeframe);
        â”‚  1028 â”‚                   console.log(`âœ… Generated ${candles.length} candles from ticks`);
        â”‚  1029 â”‚                   resolve(candles);
        â”‚  1030 â”‚                 } else {
        â”‚  1031 â”‚                   console.log(`âš ï¸ No candles or tick data in response for ${timeframe}`);
        â”‚  1032 â”‚                   resolve([]);
        â”‚  1033 â”‚                 }
        â”‚  1034 â”‚               }
        â”‚  1035 â”‚             } catch (error) {
        â”‚  1036 â”‚               ws.removeEventListener('message', handleMessage);
        â”‚  1037 â”‚               console.log(`âŒ Exception processing ${timeframe} data:`, error);
        â”‚  1038 â”‚               reject(error);
        â”‚  1039 â”‚             }
        â”‚  1040 â”‚           };
        â”‚  1041 â”‚
        â”‚  1042 â”‚           ws.addEventListener('message', handleMessage);
        â”‚  1043 â”‚
        â”‚  1044 â”‚           // Determine granularity based on timeframe
        â”‚  1045 â”‚           const granularityMap: { [key: string]: number } = {
        â”‚  1046 â”‚             '1m': 60,
        â”‚  1047 â”‚             '5m': 300,
        â”‚  1048 â”‚             '15m': 900,
        â”‚  1049 â”‚             '30m': 1800,
        â”‚  1050 â”‚             '1h': 3600,
        â”‚  1051 â”‚             '4h': 14400
        â”‚  1052 â”‚           };
        â”‚  1053 â”‚
        â”‚  1054 â”‚           const granularity = granularityMap[timeframe] || 60;
        â”‚  1055 â”‚
        â”‚  1056 â”‚           // Check if symbol is 1HZ type and needs special handling
        â”‚  1057 â”‚           if (symbol.startsWith('1HZ')) {
        â”‚  1058 â”‚             console.log(`ğŸ“ Detected 1HZ symbol ${symbol} - requesting tick data for conversion`);
        â”‚  1059 â”‚
        â”‚  1060 â”‚             // For 1HZ symbols, we need to request more ticks to convert to candles
        â”‚  1061 â”‚             const tickCount = Math.max(granularity * 200, 12000); // Ensure enough ticks
        â”‚  1062 â”‚
        â”‚  1063 â”‚             const tickRequest = {
        â”‚  1064 â”‚               ticks_history: symbol,
        â”‚  1065 â”‚               count: tickCount,
        â”‚  1066 â”‚               end: "latest",
        â”‚  1067 â”‚               style: "ticks",
        â”‚  1068 â”‚               req_id: reqId
        â”‚  1069 â”‚             };
        â”‚  1070 â”‚
        â”‚  1071 â”‚             console.log(`ğŸ“¡ Requesting ${timeframe} tick data:`, JSON.stringify(tickRequest));
        â”‚  1072 â”‚             ws.send(JSON.stringify(tickRequest));
        â”‚  1073 â”‚           } else {
        â”‚  1074 â”‚             // For regular symbols, request candles directly
        â”‚  1075 â”‚             const candleRequest = {
        â”‚  1076 â”‚               ticks_history: symbol,
        â”‚  1077 â”‚               style: "candles",
        â”‚  1078 â”‚               adjust_start_time: 1,
        â”‚  1079 â”‚               count: 100,
        â”‚  1080 â”‚               end: "latest",
        â”‚  1081 â”‚               granularity: granularity,
        â”‚  1082 â”‚               req_id: reqId
        â”‚  1083 â”‚             };
        â”‚  1084 â”‚
        â”‚  1085 â”‚             console.log(`ğŸ“¡ Requesting ${timeframe} candles:`, JSON.stringify(candleRequest));
        â”‚  1086 â”‚             ws.send(JSON.stringify(candleRequest));
        â”‚  1087 â”‚           }
        â”‚  1088 â”‚
        â”‚  1089 â”‚           // Timeout after 15 seconds
        â”‚  1090 â”‚           setTimeout(() => {
        â”‚  1091 â”‚             ws.removeEventListener('message', handleMessage);
        â”‚  1092 â”‚             reject(new Error(`Timeout fetching ${timeframe} data`));
        â”‚  1093 â”‚           }, 15000);
        â”‚  1094 â”‚         });
        â”‚  1095 â”‚       };
        â”‚  1096 â”‚
        â”‚  1097 â”‚       // Helper function to convert tick data to OHLC candles
        â”‚  1098 â”‚       const convertTicksToCandles = (prices: number[], times: number[], timeframe: string) => {
        â”‚       Â·             â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        â”‚       Â·                       â•°â”€â”€ `convertTicksToCandles` redefined here
        â”‚  1099 â”‚         if (!prices || !times || prices.length === 0) return [];
        â”‚  1100 â”‚
        â”‚  1101 â”‚         const granularityMap: { [key: string]: number } = {
        â”‚       â•°â”€â”€â”€â”€
        â”‚
Fix error, click outside, or press Esc to close the overlay.

Disable overlay by setting Rsbuild's dev.client.overlay config to false.