Compilation failed

File: /home/runner/workspace/src/components/decycler-bot/decycler-bot.tsx:1:1
  × Module build failed:
  ╰─▶   ×   × the name `convertTicksToCandles` is defined multiple times
        │       ╭─[/home/runner/workspace/src/components/decycler-bot/decycler-bot.tsx:339:1]
        │   336 │     }, [config.symbol, addLog]);
        │   337 │
        │   338 │     // Helper function to convert tick data to candles
        │   339 │     const convertTicksToCandles = useCallback((prices: number[], times: number[], granularity: number): any[] => {
        │       ·           ──────────┬──────────
        │       ·                     ╰── previous definition of `convertTicksToCandles` here
        │   340 │         if (!prices || !times || prices.length !== times.length || prices.length === 0) {
        │   341 │             addLog(`⚠️ Invalid tick data for candle conversion: prices=${prices?.length}, times=${times?.length}`);
        │   342 │             return [];
        │   343 │         }
        │   344 │
        │   345 │         const candles: any[] = [];
        │   346 │         let currentCandle: any = null;
        │   347 │         let tickCount = 0;
        │   348 │
        │   349 │         for (let i = 0; i < prices.length; i++) {
        │   350 │             const price = parseFloat(prices[i]);
        │   351 │             const time = times[i];
        │   352 │
        │   353 │             if (isNaN(price) || !time) {
        │   354 │                 continue; // Skip invalid data
        │   355 │             }
        │   356 │
        │   357 │             const candleTime = Math.floor(time / granularity) * granularity;
        │   358 │
        │   359 │             if (!currentCandle || currentCandle.epoch !== candleTime) {
        │   360 │                 // Start new candle
        │   361 │                 if (currentCandle && tickCount > 0) {
        │   362 │                     candles.push({
        │   363 │                         ...currentCandle,
        │   364 │                         timeframe: `${granularity}s`,
        │   365 │                         tickCount: tickCount
        │   366 │                     });
        │   367 │                 }
        │   368 │                 currentCandle = {
        │   369 │                     epoch: candleTime,
        │   370 │                     open: price,
        │   371 │                     high: price,
        │   372 │                     low: price,
        │   373 │                     close: price
        │   374 │                 };
        │   375 │                 tickCount = 1;
        │   376 │             } else {
        │   377 │                 // Update existing candle with proper OHLC calculation
        │   378 │                 currentCandle.high = Math.max(currentCandle.high, price);
        │   379 │                 currentCandle.low = Math.min(currentCandle.low, price);
        │   380 │                 currentCandle.close = price; // Last price becomes close
        │   381 │                 tickCount++;
        │   382 │             }
        │   383 │         }
        │   384 │
        │   385 │         // Add the last candle if it has data
        │   386 │         if (currentCandle && tickCount > 0) {
        │   387 │             candles.push({
        │   388 │                 ...currentCandle,
        │   389 │                 timeframe: `${granularity}s`,
        │   390 │                 tickCount: tickCount
        │   391 │             });
        │   392 │         }
        │   393 │
        │   394 │         // Log OHLC summary for debugging
        │   395 │         if (candles.length > 0) {
        │   396 │             const firstCandle = candles[0];
        │   397 │             const lastCandle = candles[candles.length - 1];
        │   398 │             addLog(`📊 Candle conversion summary: ${candles.length} candles generated`);
        │   399 │             addLog(`📊 First candle OHLC: O=${firstCandle.open}, H=${firstCandle.high}, L=${firstCandle.low}, C=${firstCandle.close}`);
        │   400 │             addLog(`📊 Last candle OHLC: O=${lastCandle.open}, H=${lastCandle.high}, L=${lastCandle.low}, C=${lastCandle.close}`);
        │   401 │         }
        │   402 │
        │   403 │         return candles;
        │   404 │     }, [addLog]);
        │   405 │
        │   406 │     // Analyze all timeframes
        │   407 │     const analyzeAllTimeframes = useCallback(async (): Promise<TrendData[]> => {
        │   408 │         const trends: TrendData[] = [];
        │   409 │
        │   410 │         addLog('📊 Starting multi-timeframe analysis...');
        │   411 │
        │   412 │         // Process timeframes sequentially to avoid overwhelming the API
        │   413 │         for (const timeframe of timeframes) {
        │   414 │             try {
        │   415 │                 addLog(`🔄 Analyzing ${timeframe} timeframe...`);
        │   416 │
        │   417 │                 const candles = await fetchOHLCData(timeframe);
        │   418 │                 if (candles.length === 0) {
        │   419 │                     addLog(`⚠️ No data received for ${timeframe} - skipping`);
        │   420 │                     // Add neutral trend for missing data
        │   421 │                     trends.push({
        │   422 │                         timeframe,
        │   423 │                         trend: 'neutral',
        │   424 │                         value: 0,
        │   425 │                         timestamp: Date.now()
        │   426 │                     });
        │   427 │                     continue;
        │   428 │                 }
        │   429 │
        │   430 │                 const closePrices = candles.map(candle => parseFloat(candle.close));
        │   431 │                 addLog(`📈 Processing ${closePrices.length} prices for ${timeframe}`);
        │   432 │
        │   433 │                 if (closePrices.length < 3) {
        │   434 │                     addLog(`⚠️ Insufficient data for ${timeframe} (need 3+ prices, got ${closePrices.length})`);
        │   435 │                     trends.push({
        │   436 │                         timeframe,
        │   437 │                         trend: 'neutral',
        │   438 │                         value: 0,
        │   439 │                         timestamp: Date.now()
        │   440 │                     });
        │   441 │                     continue;
        │   442 │                 }
        │   443 │
        │   444 │                 const decyclerValues = calculateDecycler(closePrices, config.alpha);
        │   445 │                 if (decyclerValues.length === 0) {
        │   446 │                     addLog(`⚠️ Failed to calculate Decycler for ${timeframe}`);
        │   447 │                     trends.push({
        │   448 │                         timeframe,
        │   449 │                         trend: 'neutral',
        │   450 │                         value: 0,
        │   451 │                         timestamp: Date.now()
        │   452 │                     });
        │   453 │                     continue;
        │   454 │                 }
        │   455 │
        │   456 │                 const trend = getTrend(decyclerValues);
        │   457 │                 const currentValue = decyclerValues[decyclerValues.length - 1] || 0;
        │   458 │
        │   459 │                 trends.push({
        │   460 │                     timeframe,
        │   461 │                     trend,
        │   462 │                     value: currentValue,
        │   463 │                     timestamp: Date.now()
        │   464 │                 });
        │   465 │
        │   466 │                 addLog(`✅ ${timeframe}: ${trend.toUpperCase()} (Value: ${currentValue.toFixed(5)})`);
        │   467 │
        │   468 │                 // Small delay between requests to prevent rate limiting
        │   469 │                 await new Promise(resolve => setTimeout(resolve, 200));
        │   470 │
        │   471 │             } catch (error) {
        │   472 │                 addLog(`❌ Error analyzing ${timeframe}: ${error.message}`);
        │   473 │                 // Add neutral trend for error cases
        │   474 │                 trends.push({
        │   475 │                     timeframe,
        │   476 │                     trend: 'neutral',
        │   477 │                     value: 0,
        │   478 │                     timestamp: Date.now()
        │   479 │                 });
        │   480 │             }
        │   481 │         }
        │   482 │
        │   483 │         addLog(`📋 Multi-timeframe analysis complete: ${trends.length}/${timeframes.length} timeframes processed`);
        │   484 │         return trends;
        │   485 │     }, [timeframes, fetchOHLCData, calculateDecycler, getTrend, config.alpha, addLog]);
        │   486 │
        │   487 │     // Check trend alignment
        │   488 │     const checkAlignment = useCallback((trends: TrendData[]): 'aligned_bullish' | 'aligned_bearish' | 'mixed' | 'neutral' => {
        │   489 │         if (trends.length === 0) return 'neutral';
        │   490 │
        │   491 │         const bullishCount = trends.filter(t => t.trend === 'bullish').length;
        │   492 │         const bearishCount = trends.filter(t => t.trend === 'bearish').length;
        │   493 │         const neutralCount = trends.filter(t => t.trend === 'neutral').length;
        │   494 │
        │   495 │         if (bullishCount === trends.length) return 'aligned_bullish';
        │   496 │         if (bearishCount === trends.length) return 'aligned_bearish';
        │   497 │         if (bullishCount > bearishCount && bullishCount >= trends.length * 0.7) return 'aligned_bullish';
        │   498 │         if (bearishCount > bullishCount && bearishCount >= trends.length * 0.7) return 'aligned_bearish';
        │   499 │         return 'mixed';
        │   500 │     }, []);
        │   501 │
        │   502 │     // Execute trade
        │   503 │     const executeTrade = useCallback(async (direction: 'UP' | 'DOWN'): Promise<void> => {
        │   504 │         if (!api_base.api) {
        │   505 │             addLog('❌ API not connected');
        │   506 │             return;
        │   507 │         }
        │   508 │
        │   509 │         try {
        │   510 │             const contractTypeMap = {
        │   511 │                 rise_fall: direction === 'UP' ? 'CALL' : 'PUT',
        │   512 │                 higher_lower: direction === 'UP' ? 'CALLE' : 'PUTE'
        │   513 │             };
        │   514 │
        │   515 │             const contractType = contractTypeMap[config.contract_type];
        │   516 │
        │   517 │             // Get proposal
        │   518 │             const proposalRequest = {
        │   519 │                 proposal: 1,
        │   520 │                 amount: config.stake,
        │   521 │                 basis: 'stake',
        │   522 │                 contract_type: contractType,
        │   523 │                 currency: 'USD',
        │   524 │                 duration: config.tick_count,
        │   525 │                 duration_unit: 't',
        │   526 │                 symbol: config.symbol
        │   527 │             };
        │   528 │
        │   529 │             addLog(`🔄 Getting proposal for ${contractType} on ${config.symbol}...`);
        │   530 │             const proposalResponse = await api_base.api.send(proposalRequest);
        │   531 │
        │   532 │             if (proposalResponse.error) {
        │   533 │                 addLog(`❌ Proposal error: ${proposalResponse.error.message}`);
        │   534 │                 return;
        │   535 │             }
        │   536 │
        │   537 │             const proposalId = proposalResponse.proposal.id;
        │   538 │             const entrySpot = proposalResponse.proposal.spot;
        │   539 │
        │   540 │             // Purchase contract
        │   541 │             const buyRequest = {
        │   542 │                 buy: proposalId,
        │   543 │                 price: config.stake
        │   544 │             };
        │   545 │
        │   546 │             addLog(`💰 Purchasing contract ${proposalId}...`);
        │   547 │             const buyResponse = await api_base.api.send(buyRequest);
        │   548 │
        │   549 │             if (buyResponse.error) {
        │   550 │                 addLog(`❌ Purchase error: ${buyResponse.error.message}`);
        │   551 │                 return;
        │   552 │             }
        │   553 │
        │   554 │             const contractId = buyResponse.buy.contract_id;
        │   555 │             addLog(`✅ Contract purchased: ${contractId}`);
        │   556 │
        │   557 │             // Update contract info
        │   558 │             const newContract: ContractInfo = {
        │   559 │                 id: contractId,
        │   560 │                 type: contractType,
        │   561 │                 entry_price: entrySpot,
        │   562 │                 current_price: entrySpot,
        │   563 │                 profit: 0,
        │   564 │                 status: 'open',
        │   565 │                 entry_time: Date.now(),
        │   566 │                 direction,
        │   567 │                 stop_loss: entrySpot + config.stop_loss,
        │   568 │                 take_profit: entrySpot + config.take_profit,
        │   569 │                 trailing_stop: config.use_trailing_stop ? entrySpot + config.stop_loss : 0,
        │   570 │                 breakeven_active: false
        │   571 │             };
        │   572 │
        │   573 │             setBotStatus(prev => ({
        │   574 │                 ...prev,
        │   575 │                 current_contract: newContract,
        │   576 │                 total_trades: prev.total_trades + 1
        │   577 │             }));
        │   578 │
        │   579 │             // Start monitoring the contract
        │   580 │             monitorContract(contractId);
        │   581 │
        │   582 │         } catch (error) {
        │   583 │             addLog(`❌ Trade execution failed: ${error.message}`);
        │   584 │         }
        │   585 │     }, [config, addLog]);
        │   586 │
        │   587 │     // Monitor open contract
        │   588 │     const monitorContract = useCallback(async (contractId: string): Promise<void> => {
        │   589 │         if (!api_base.api) return;
        │   590 │
        │   591 │         try {
        │   592 │             const request = {
        │   593 │                 proposal_open_contract: 1,
        │   594 │                 contract_id: contractId,
        │   595 │                 subscribe: 1
        │   596 │             };
        │   597 │
        │   598 │             const response = await api_base.api.send(request);
        │   599 │
        │   600 │             if (response.error) {
        │   601 │                 addLog(`❌ Contract monitoring error: ${response.error.message}`);
        │   602 │                 return;
        │   603 │             }
        │   604 │
        │   605 │             addLog(`👁️ Monitoring contract ${contractId}`);
        │   606 │         } catch (error) {
        │   607 │             addLog(`❌ Failed to monitor contract: ${error.message}`);
        │   608 │         }
        │   609 │     }, [addLog]);
        │   610 │
        │   611 │     // Main trading loop
        │   612 │     const tradingLoop = useCallback(async (): Promise<void> => {
        │   613 │         if (!botStatus.is_running) return;
        │   614 │
        │   615 │         try {
        │   616 │             addLog('🔄 Starting trading analysis cycle...');
        │   617 │
        │   618 │             // Analyze all timeframes
        │   619 │             const trends = await analyzeAllTimeframes();
        │   620 │
        │   621 │             if (trends.length === 0) {
        │   622 │                 addLog('⚠️ No trend data available - will retry next cycle');
        │   623 │                 setBotStatus(prev => ({
        │   624 │                     ...prev,
        │   625 │                     error_message: 'No trend data available',
        │   626 │                     last_update: Date.now()
        │   627 │                 }));
        │   628 │                 return;
        │   629 │             }
        │   630 │
        │   631 │             const alignment = checkAlignment(trends);
        │   632 │
        │   633 │             // Update bot status with new analysis
        │   634 │             setBotStatus(prev => ({
        │   635 │                 ...prev,
        │   636 │                 trends,
        │   637 │                 alignment_status: alignment,
        │   638 │                 last_update: Date.now(),
        │   639 │                 error_message: ''
        │   640 │             }));
        │   641 │
        │   642 │             addLog(`📊 Analysis complete - Alignment: ${alignment.toUpperCase()}`);
        │   643 │
        │   644 │             // Log individual timeframe results
        │   645 │             const bullishCount = trends.filter(t => t.trend === 'bullish').length;
        │   646 │             const bearishCount = trends.filter(t => t.trend === 'bearish').length;
        │   647 │             const neutralCount = trends.filter(t => t.trend === 'neutral').length;
        │   648 │
        │   649 │             addLog(`📈 Trends: ${bullishCount} Bullish, ${bearishCount} Bearish, ${neutralCount} Neutral`);
        │   650 │
        │   651 │             // Check if we should enter a trade
        │   652 │             if (!botStatus.current_contract && (alignment === 'aligned_bullish' || alignment === 'aligned_bearish')) {
        │   653 │                 const direction = alignment === 'aligned_bullish' ? 'UP' : 'DOWN';
        │   654 │
        │   655 │                 // Optional 10s confirmation
        │   656 │                 if (config.use_10s_filter) {
        │   657 │                     addLog('⏱️ Applying 10-second confirmation filter...');
        │   658 │                     // Add a small delay for confirmation
        │   659 │                     await new Promise(resolve => setTimeout(resolve, 1000));
        │   660 │                 }
        │   661 │
        │   662 │                 addLog(`🎯 Strong ${direction} alignment detected - Preparing trade execution!`);
        │   663 │                 await executeTrade(direction);
        │   664 │             } else if (!botStatus.current_contract) {
        │   665 │                 addLog('⏳ Waiting for trend alignment - No trade signal yet');
        │   666 │             } else {
        │   667 │                 addLog('📊 Active contract in progress - Monitoring...');
        │   668 │             }
        │   669 │
        │   670 │         } catch (error) {
        │   671 │             const errorMsg = `Trading analysis error: ${error.message}`;
        │   672 │             addLog(`❌ ${errorMsg}`);
        │   673 │             setBotStatus(prev => ({
        │   674 │                 ...prev,
        │   675 │                 error_message: errorMsg,
        │   676 │                 last_update: Date.now()
        │   677 │             }));
        │   678 │         }
        │   679 │     }, [botStatus.is_running, botStatus.current_contract, analyzeAllTimeframes, checkAlignment, config.use_10s_filter, executeTrade, addLog]);
        │   680 │
        │   681 │     // Start bot
        │   682 │     const startBot = useCallback(async (): Promise<void> => {
        │   683 │         try {
        │   684 │             addLog('🔄 Starting Decycler Bot...');
        │   685 │
        │   686 │             // Initialize API connection
        │   687 │             if (!api_base.api || api_base.api.connection.readyState !== 1) {
        │   688 │                 addLog('🔌 Connecting to Deriv API...');
        │   689 │                 await api_base.init();
        │   690 │
        │   691 │                 // Wait for connection to be ready
        │   692 │                 let retries = 0;
        │   693 │                 while ((!api_base.api || api_base.api.connection.readyState !== 1) && retries < 15) {
        │   694 │                     await new Promise(resolve => setTimeout(resolve, 1000));
        │   695 │                     retries++;
        │   696 │                     const readyState = api_base.api?.connection?.readyState || 'undefined';
        │   697 │                     addLog(`⏳ Waiting for WebSocket connection... (${retries}/15) - State: ${readyState}`);
        │   698 │                 }
        │   699 │
        │   700 │                 if (!api_base.api || api_base.api.connection.readyState !== 1) {
        │   701 │                     addLog('❌ Failed to establish WebSocket connection. Please check your internet connection and try again.');
        │   702 │                     return;
        │   703 │                 }
        │   704 │             }
        │   705 │
        │   706 │             // Check connection status
        │   707 │             const connectionStatus = api_base.getConnectionStatus();
        │   708 │             addLog(`📡 Connection Status: ${connectionStatus}`);
        │   709 │
        │   710 │             // Check if WebSocket is actually ready
        │   711 │             const isReady = api_base.api?.connection?.readyState === 1;
        │   712 │             addLog(`🔌 WebSocket Ready State: ${api_base.api?.connection?.readyState} (${isReady ? 'OPEN' : 'NOT READY'})`);
        │   713 │
        │   714 │             if (!isReady) {
        │   715 │                 addLog('❌ WebSocket connection not ready. Please wait and try again.');
        │   716 │                 return;
        │   717 │             }
        │   718 │
        │   719 │             setBotStatus(prev => ({ ...prev, is_running: true }));
        │   720 │             addLog('🚀 Decycler Multi-Timeframe Bot Started!');
        │   721 │             addLog(`📊 Monitoring ${timeframes.join(', ')} timeframes`);
        │   722 │             addLog(`🎯 Symbol: ${config.symbol} | Stake: $${config.stake}`);
        │   723 │             addLog(`⚙️ Contract Type: ${config.contract_type.toUpperCase()}`);
        │   724 │
        │   725 │             // Start trading loop
        │   726 │             intervalRef.current = setInterval(tradingLoop, config.monitor_interval * 1000);
        │   727 │
        │   728 │             // Run initial analysis
        │   729 │             await tradingLoop();
        │   730 │         } catch (error) {
        │   731 │             addLog(`❌ Error starting bot: ${error.message}`);
        │   732 │         }
        │   733 │     }, [config, timeframes, tradingLoop, addLog]);
        │   734 │
        │   735 │     // Stop bot
        │   736 │     const stopBot = useCallback((): void => {
        │   737 │         setBotStatus(prev => ({ ...prev, is_running: false }));
        │   738 │
        │   739 │         if (intervalRef.current) {
        │   740 │             clearInterval(intervalRef.current);
        │   741 │             intervalRef.current = null;
        │   742 │         }
        │   743 │
        │   744 │         if (monitorRef.current) {
        │   745 │             clearInterval(monitorRef.current);
        │   746 │             monitorRef.current = null;
        │   747 │         }
        │   748 │
        │   749 │         addLog('⏹️ Decycler Bot Stopped');
        │   750 │     }, [addLog]);
        │   751 │
        │   752 │     // Handle contract updates from API
        │   753 │     useEffect(() => {
        │   754 │         const handleApiResponse = (response: any) => {
        │   755 │             if (response && response.proposal_open_contract) {
        │   756 │                 const contract = response.proposal_open_contract;
        │   757 │
        │   758 │                 setBotStatus(prev => {
        │   759 │                     if (!prev.current_contract || prev.current_contract.id !== contract.contract_id) {
        │   760 │                         return prev;
        │   761 │                     }
        │   762 │
        │   763 │                     const updatedContract: ContractInfo = {
        │   764 │                         ...prev.current_contract,
        │   765 │                         current_price: contract.current_spot || prev.current_contract.current_price,
        │   766 │                         profit: contract.profit || 0,
        │   767 │                         status: contract.is_sold ? 'closed' : 'open'
        │   768 │                     };
        │   769 │
        │   770 │                     // Handle risk management
        │   771 │                     if (config.use_trailing_stop && contract.profit > 0) {
        │   772 │                         const newTrailingStop = prev.current_contract.entry_price + contract.profit - config.trailing_step;
        │   773 │                         if (newTrailingStop > updatedContract.trailing_stop) {
        │   774 │                             updatedContract.trailing_stop = newTrailingStop;
        │   775 │                             addLog(`📈 Trailing stop updated to ${newTrailingStop.toFixed(5)}`);
        │   776 │                         }
        │   777 │                     }
        │   778 │
        │   779 │                     // Handle breakeven
        │   780 │                     if (config.use_breakeven && !updatedContract.breakeven_active && contract.profit >= config.breakeven_trigger) {
        │   781 │                         updatedContract.stop_loss = prev.current_contract.entry_price;
        │   782 │                         updatedContract.breakeven_active = true;
        │   783 │                         addLog(`⚖️ Breakeven protection activated`);
        │   784 │                     }
        │   785 │
        │   786 │                     // Check if contract closed
        │   787 │                     if (contract.is_sold) {
        │   788 │                         const isWin = contract.profit > 0;
        │   789 │                         addLog(`${isWin ? '🎉' : '💔'} Contract closed: ${isWin ? 'WIN' : 'LOSS'} - P&L: ${contract.profit.toFixed(2)}`);
        │   790 │
        │   791 │                         return {
        │   792 │                             ...prev,
        │   793 │                             current_contract: null,
        │   794 │                             winning_trades: isWin ? prev.winning_trades + 1 : prev.winning_trades,
        │   795 │                             total_pnl: prev.total_pnl + contract.profit
        │   796 │                         };
        │   797 │                     }
        │   798 │
        │   799 │                     return {
        │   800 │                         ...prev,
        │   801 │                         current_contract: updatedContract
        │   802 │                     };
        │   803 │                 });
        │   804 │             }
        │   805 │         };
        │   806 │
        │   807 │         // Listen for API responses
        │   808 │         if (typeof window !== 'undefined' && (window as any).globalObserver) {
        │   809 │             const globalObserver = (window as any).globalObserver;
        │   810 │             globalObserver.register('api.response', handleApiResponse);
        │   811 │
        │   812 │             return () => {
        │   813 │                 globalObserver.unregister('api.response', handleApiResponse);
        │   814 │             };
        │   815 │         }
        │   816 │     }, [config, addLog]);
        │   817 │
        │   818 │     // Comprehensive API connection and data testing
        │   819 │     const testConnection = useCallback(async (): Promise<void> => {
        │   820 │         try {
        │   821 │             addLog('🔍 Starting comprehensive API connection test...');
        │   822 │
        │   823 │             // Step 1: Test WebSocket connection
        │   824 │             if (!api_base.api || api_base.api.connection.readyState !== 1) {
        │   825 │                 addLog('🔌 Initializing API connection...');
        │   826 │                 await api_base.init();
        │   827 │
        │   828 │                 let retries = 0;
        │   829 │                 while ((!api_base.api || api_base.api.connection.readyState !== 1) && retries < 15) {
        │   830 │                     await new Promise(resolve => setTimeout(resolve, 1000));
        │   831 │                     retries++;
        │   832 │                     if (retries % 3 === 0) {
        │   833 │                         addLog(`⏳ Waiting for connection... (${retries}/15)`);
        │   834 │                     }
        │   835 │                 }
        │   836 │             }
        │   837 │
        │   838 │             if (!api_base.api || api_base.api.connection.readyState !== 1) {
        │   839 │                 addLog('❌ Failed to establish WebSocket connection');
        │   840 │                 return;
        │   841 │             }
        │   842 │
        │   843 │             addLog(`✅ WebSocket connected (Ready State: ${api_base.api.connection.readyState})`);
        │   844 │
        │   845 │             // Step 2: Test basic API communication
        │   846 │             const timeResponse = await Promise.race([
        │   847 │                 api_base.api.send({ time: 1 }),
        │   848 │                 new Promise((_, reject) => setTimeout(() => reject(new Error('Time request timeout')), 5000))
        │   849 │             ]);
        │   850 │
        │   851 │             if (timeResponse?.time) {
        │   852 │                 addLog(`✅ API communication test successful. Server time: ${new Date(timeResponse.time * 1000).toLocaleString()}`);
        │   853 │             } else {
        │   854 │                 addLog('❌ API communication test failed - no server time received');
        │   855 │                 return;
        │   856 │             }
        │   857 │
        │   858 │             // Step3: Test symbol existence
        │   859 │             addLog(`🔍 Testing symbol availability: ${config.symbol}`);
        │   860 │
        │   861 │             try {
        │   862 │                 const symbolTest = await Promise.race([
        │   863 │                     api_base.api.send({
        │   864 │                         active_symbols: 'brief',
        │   865 │                         product_type: 'basic'
        │   866 │                     }),
        │   867 │                     new Promise((_, reject) => setTimeout(() => reject(new Error('Symbol test timeout')), 8000))
        │   868 │                 ]);
        │   869 │
        │   870 │                 if (symbolTest?.active_symbols) {
        │   871 │                     const symbolExists = symbolTest.active_symbols.some(s => s.symbol === config.symbol);
        │   872 │                     if (symbolExists) {
        │   873 │                         addLog(`✅ Symbol ${config.symbol} is available for trading`);
        │   874 │                     } else {
        │   875 │                         addLog(`⚠️ Symbol ${config.symbol} not found in active symbols list`);
        │   876 │                     }
        │   877 │                 }
        │   878 │             } catch (symbolError) {
        │   879 │                 addLog(`⚠️ Could not verify symbol availability: ${symbolError.message}`);
        │   880 │             }
        │   881 │
        │   882 │             // Step 4: Test data retrieval for each timeframe
        │   883 │             addLog('📊 Testing data retrieval for all timeframes...');
        │   884 │
        │   885 │             const testResults = {};
        │   886 │             for (const tf of timeframes) {
        │   887 │                 try {
        │   888 │                     addLog(`🔄 Testing ${tf} data...`);
        │   889 │                     const testData = await fetchOHLCData(tf);
        │   890 │                     testResults[tf] = testData.length;
        │   891 │
        │   892 │                     if (testData.length > 0) {
        │   893 │                         addLog(`✅ ${tf}: ${testData.length} data points retrieved`);
        │   894 │                     } else {
        │   895 │                         addLog(`❌ ${tf}: No data retrieved`);
        │   896 │                     }
        │   897 │
        │   898 │                     // Small delay between requests to avoid rate limiting
        │   899 │                     await new Promise(resolve => setTimeout(resolve, 200));
        │   900 │                 } catch (tfError) {
        │   901 │                     addLog(`❌ ${tf}: Error - ${tfError.message}`);
        │   902 │                     testResults[tf] = 0;
        │   903 │                 }
        │   904 │             }
        │   905 │
        │   906 │             // Step 5: Summary
        │   907 │             const successfulTimeframes = Object.values(testResults).filter(count => count > 0).length;
        │   908 │             const totalTimeframes = timeframes.length;
        │   909 │
        │   910 │             addLog(`📋 Test Summary: ${successfulTimeframes}/${totalTimeframes} timeframes working`);
        │   911 │
        │   912 │             if (successfulTimeframes === 0) {
        │   913 │                 addLog('❌ No timeframes working - try a different symbol or check API connection');
        │   914 │             } else if (successfulTimeframes < totalTimeframes) {
        │   915 │                 addLog(`⚠️ Partial success - ${totalTimeframes - successfulTimeframes} timeframes failed`);
        │   916 │             } else {
        │   917 │                 addLog('🎉 All timeframes working perfectly!');
        │   918 │             }
        │   919 │
        │   920 │         } catch (error) {
        │   921 │             addLog(`❌ Connection test failed: ${error.message}`);
        │   922 │             console.error('Detailed connection test error:', error);
        │   923 │         }
        │   924 │     }, [fetchOHLCData, config.symbol, addLog, timeframes]);
        │   925 │
        │   926 │     // Cleanup on unmount
        │   927 │     useEffect(() => {
        │   928 │         return () => {
        │   929 │             if (intervalRef.current) clearInterval(intervalRef.current);
        │   930 │             if (monitorRef.current) clearInterval(monitorRef.current);
        │   931 │         };
        │   932 │     }, []);
        │   933 │
        │   934 │     const getTrendColor = (trend: string): string => {
        │   935 │         switch (trend) {
        │   936 │             case 'bullish': return '#00ff88';
        │   937 │             case 'bearish': return '#ff4757';
        │   938 │             default: return '#ffa502';
        │   939 │         }
        │   940 │     };
        │   941 │
        │   942 │     const getAlignmentColor = (alignment: string): string => {
        │   943 │         switch (alignment) {
        │   944 │             case 'aligned_bullish': return '#00ff88';
        │   945 │             case 'aligned_bearish': return '#ff4757';
        │   946 │             case 'mixed': return '#ffa502';
        │   947 │             default: return '#74b9ff';
        │   948 │         }
        │   949 │     };
        │   950 │
        │   951 │     // Define WebSocket and currentSymbol
        │   952 │     const [ws, setWs] = useState<WebSocket | null>(null);
        │   953 │     const [currentSymbol, setCurrentSymbol] = useState(config.symbol);
        │   954 │     const [timeframeAnalysis, setTimeframeAnalysis] = useState<{ [key: string]: string }>({});
        │   955 │     const [overallAnalysis, setOverallAnalysis] = useState('NEUTRAL');
        │   956 │
        │   957 │     useEffect(() => {
        │   958 │         setCurrentSymbol(config.symbol); // Update currentSymbol when config.symbol changes
        │   959 │     }, [config.symbol]);
        │   960 │
        │   961 │     // Establish WebSocket connection on component mount
        │   962 │     useEffect(() => {
        │   963 │         const connectWebSocket = () => {
        │   964 │             const newWs = new WebSocket("wss://ws.binaryws.com/websockets/v3?app_id=75771");
        │   965 │
        │   966 │             newWs.onopen = () => {
        │   967 │                 console.log('✅ WebSocket connected');
        │   968 │                 setWs(newWs);
        │   969 │             };
        │   970 │
        │   971 │             newWs.onclose = () => {
        │   972 │                 console.log('❌ WebSocket disconnected');
        │   973 │                 setWs(null);
        │   974 │                 // Reconnect after 5 seconds
        │   975 │                 setTimeout(connectWebSocket, 5000);
        │   976 │             };
        │   977 │
        │   978 │             newWs.onerror = (error) => {
        │   979 │                 console.log('❌ WebSocket error:', error);
        │   980 │                 setWs(null);
        │   981 │             };
        │   982 │         };
        │   983 │
        │   984 │         connectWebSocket();
        │   985 │
        │   986 │         return () => {
        │   987 │             if (ws) {
        │   988 │                 ws.close();
        │   989 │             }
        │   990 │         };
        │   991 │     }, []);
        │   992 │
        │   993 │     // Fetch market data for all timeframes when component mounts and when symbol changes
        │   994 │     useEffect(() => {
        │   995 │         if (ws && ws.readyState === WebSocket.OPEN) {
        │   996 │             fetchAllTimeframeData();
        │   997 │         } else {
        │   998 │             console.log('⚠️ WebSocket not ready to fetch data');
        │   999 │         }
        │  1000 │     }, [ws, currentSymbol]);
        │  1001 │
        │  1002 │     const fetchMarketData = async (symbol: string, timeframe: string) => {
        │  1003 │         if (!ws || ws.readyState !== WebSocket.OPEN) {
        │  1004 │           console.log('❌ WebSocket not ready for data fetch');
        │  1005 │           return null;
        │  1006 │         }
        │  1007 │
        │  1008 │         return new Promise((resolve, reject) => {
        │  1009 │           const reqId = `candles_${timeframe}_${Date.now()}`;
        │  1010 │
        │  1011 │           // Handle response
        │  1012 │           const handleMessage = (event: MessageEvent) => {
        │  1013 │             try {
        │  1014 │               const data = JSON.parse(event.data);
        │  1015 │               if (data.req_id === reqId) {
        │  1016 │                 ws.removeEventListener('message', handleMessage);
        │  1017 │                 if (data.error) {
        │  1018 │                   console.log(`❌ Error fetching ${timeframe} data:`, data.error.message);
        │  1019 │                   reject(data.error);
        │  1020 │                 } else if (data.candles) {
        │  1021 │                   console.log(`✅ Received ${data.candles.length} candles for ${timeframe}`);
        │  1022 │                   console.log(`📊 Sample candle:`, data.candles[data.candles.length - 1]);
        │  1023 │                   resolve(data.candles);
        │  1024 │                 } else if (data.history && data.history.prices) {
        │  1025 │                   // Convert tick data to candles for 1HZ symbols
        │  1026 │                   console.log(`📈 Converting ${data.history.prices.length} ticks to ${timeframe} candles`);
        │  1027 │                   const candles = convertTicksToCandles(data.history.prices, data.history.times, timeframe);
        │  1028 │                   console.log(`✅ Generated ${candles.length} candles from ticks`);
        │  1029 │                   resolve(candles);
        │  1030 │                 } else {
        │  1031 │                   console.log(`⚠️ No candles or tick data in response for ${timeframe}`);
        │  1032 │                   resolve([]);
        │  1033 │                 }
        │  1034 │               }
        │  1035 │             } catch (error) {
        │  1036 │               ws.removeEventListener('message', handleMessage);
        │  1037 │               console.log(`❌ Exception processing ${timeframe} data:`, error);
        │  1038 │               reject(error);
        │  1039 │             }
        │  1040 │           };
        │  1041 │
        │  1042 │           ws.addEventListener('message', handleMessage);
        │  1043 │
        │  1044 │           // Determine granularity based on timeframe
        │  1045 │           const granularityMap: { [key: string]: number } = {
        │  1046 │             '1m': 60,
        │  1047 │             '5m': 300,
        │  1048 │             '15m': 900,
        │  1049 │             '30m': 1800,
        │  1050 │             '1h': 3600,
        │  1051 │             '4h': 14400
        │  1052 │           };
        │  1053 │
        │  1054 │           const granularity = granularityMap[timeframe] || 60;
        │  1055 │
        │  1056 │           // Check if symbol is 1HZ type and needs special handling
        │  1057 │           if (symbol.startsWith('1HZ')) {
        │  1058 │             console.log(`📍 Detected 1HZ symbol ${symbol} - requesting tick data for conversion`);
        │  1059 │
        │  1060 │             // For 1HZ symbols, we need to request more ticks to convert to candles
        │  1061 │             const tickCount = Math.max(granularity * 200, 12000); // Ensure enough ticks
        │  1062 │
        │  1063 │             const tickRequest = {
        │  1064 │               ticks_history: symbol,
        │  1065 │               count: tickCount,
        │  1066 │               end: "latest",
        │  1067 │               style: "ticks",
        │  1068 │               req_id: reqId
        │  1069 │             };
        │  1070 │
        │  1071 │             console.log(`📡 Requesting ${timeframe} tick data:`, JSON.stringify(tickRequest));
        │  1072 │             ws.send(JSON.stringify(tickRequest));
        │  1073 │           } else {
        │  1074 │             // For regular symbols, request candles directly
        │  1075 │             const candleRequest = {
        │  1076 │               ticks_history: symbol,
        │  1077 │               style: "candles",
        │  1078 │               adjust_start_time: 1,
        │  1079 │               count: 100,
        │  1080 │               end: "latest",
        │  1081 │               granularity: granularity,
        │  1082 │               req_id: reqId
        │  1083 │             };
        │  1084 │
        │  1085 │             console.log(`📡 Requesting ${timeframe} candles:`, JSON.stringify(candleRequest));
        │  1086 │             ws.send(JSON.stringify(candleRequest));
        │  1087 │           }
        │  1088 │
        │  1089 │           // Timeout after 15 seconds
        │  1090 │           setTimeout(() => {
        │  1091 │             ws.removeEventListener('message', handleMessage);
        │  1092 │             reject(new Error(`Timeout fetching ${timeframe} data`));
        │  1093 │           }, 15000);
        │  1094 │         });
        │  1095 │       };
        │  1096 │
        │  1097 │       // Helper function to convert tick data to OHLC candles
        │  1098 │       const convertTicksToCandles = (prices: number[], times: number[], timeframe: string) => {
        │       ·             ──────────┬──────────
        │       ·                       ╰── `convertTicksToCandles` redefined here
        │  1099 │         if (!prices || !times || prices.length === 0) return [];
        │  1100 │
        │  1101 │         const granularityMap: { [key: string]: number } = {
        │       ╰────
        │
Fix error, click outside, or press Esc to close the overlay.

Disable overlay by setting Rsbuild's dev.client.overlay config to false.