Your code has several structural and logical issues that are preventing the martingale strategy from working correctly. Let me analyze the problems and provide a corrected solution.

Key Issues Identified:
Mixed Implementation Approaches:

You're mixing JavaScript martingale logic with Blockly XML variables, causing conflicts

The Blockly XML at the bottom isn't properly integrated with the JavaScript logic

State Management Problems:

Multiple conflicting implementations of getMartingaleMultiplier and related functions

Inconsistent storage of martingale state between Blockly and JavaScript

Redundant Code:

Duplicate function definitions (like getTotalProfit appears twice)

Unused Blockly XML fragments that aren't properly connected

Implementation Conflicts:

The JavaScript implementation is complete but being overridden by Blockly variables

The Blockly implementation is incomplete and not properly synchronized

Corrected Solution:
Here's how to fix this properly:

Choose One Approach (recommend pure JavaScript):

javascript
// Remove all Blockly-dependent code and use this pure JS implementation:

export default Engine =>
    class Purchase extends Engine {
        constructor() {
            super();
            this.martingaleState = {
                baseAmount: null,
                multiplier: 1,
                consecutiveLosses: 0,
                lastTradeProfit: 0,
                currentPurchasePrice: 0
            };
        }

        applyMartingaleLogic() {
            const { lastTradeProfit, multiplier, consecutiveLosses, baseAmount } = this.martingaleState;
            const maxMultiplier = 64;
            const maxConsecutiveLosses = 10;

            // Initialize base amount on first run
            if (!baseAmount) {
                this.martingaleState.baseAmount = this.tradeOptions.amount;
                console.log(`Base amount set to: ${this.martingaleState.baseAmount}`);
                return;
            }

            if (lastTradeProfit < 0) {
                // On loss
                const newMultiplier = multiplier * 2;
                const newConsecutiveLosses = consecutiveLosses + 1;

                if (newMultiplier <= maxMultiplier && newConsecutiveLosses <= maxConsecutiveLosses) {
                    this.martingaleState.multiplier = newMultiplier;
                    this.martingaleState.consecutiveLosses = newConsecutiveLosses;
                    this.tradeOptions.amount = baseAmount * newMultiplier;
                    console.log(`Loss - New stake: ${this.tradeOptions.amount} (${newMultiplier}x)`);
                } else {
                    // Reset if limits reached
                    this.resetMartingale();
                    console.log('Max limits reached - resetting martingale');
                }
            } else if (lastTradeProfit > 0) {
                // On win
                this.resetMartingale();
                console.log('Win - resetting martingale');
            }
            // On break-even, do nothing
        }

        resetMartingale() {
            this.martingaleState.multiplier = 1;
            this.martingaleState.consecutiveLosses = 0;
            this.tradeOptions.amount = this.martingaleState.baseAmount;
        }

        // ... rest of your existing methods ...
    }
If You Must Use Blockly:

Remove the JavaScript state management

Fully implement the Blockly version with:

Proper variable declarations

Complete martingale logic blocks

Clear state persistence

Critical Fixes Needed:

Remove duplicate function definitions

Choose either JavaScript OR Blockly implementation (not both)

Ensure proper state persistence between trades

Add clear logging for debugging

Implementation Recommendations:

For JavaScript:

Remove all Blockly XML

Use the pure JS implementation above

Add thorough logging

For Blockly:

Remove all JavaScript martingale logic

Implement complete Blockly workflow:

xml
<variables>
  <variable id="base_amount">100</variable>
  <variable id="multiplier">1</variable>
  <variable id="consecutive_losses">0</variable>
</variables>
<!-- Then implement full logic blocks -->
Expected Behavior After Fix:
Trade	Result	Multiplier	Next Bet	Action
1	Win	1x	$10	-
2	Loss	2x	$20	2x
3	Loss	4x	$40	4x
4	Win	1x	$10	Reset
5	Loss	2x	$20	2x
The key is consistency - choose one approach and implement it completely. The JavaScript version above is the cleaner solution.