Looking at your updated code, I can see you've implemented the key improvements from the working VolatilityAnalyzer. The structure is now much better, but there are still a few critical issues that need to be fixed:

## Critical Issues Remaining:

### 1. **Contract Monitoring Message Handling**
The `monitorContract` function still has the same issue - it's trying to handle parsed data instead of MessageEvent objects:

```jsx
// WRONG: This expects already-parsed data
const handleContractUpdate = (data: any) => {
    if (data.msg_type === 'proposal_open_contract') {
        // ...
    }
};

// CORRECT: This handles the raw MessageEvent
const handleContractUpdate = (event: MessageEvent) => {
    try {
        const data = JSON.parse(event.data);
        if (data.msg_type === 'proposal_open_contract') {
            // ...
        }
    } catch (error) {
        console.error('Error parsing contract update:', error);
    }
};
```

### 2. **Missing Trading API Connection Check**
The code assumes `tradingApi.connection` exists, but it might not:

```jsx
// Add this check before accessing connection
if (!tradingApi.connection) {
    throw new Error('Trading API connection not available');
}
```

### 3. **Incorrect Interval Timing**
The interval timing might be too aggressive for some volatility symbols.

## Complete Fixes:

### 1. **Fix the monitorContract Function**

```jsx
const monitorContract = async (contractId: string, stakeAmount: number) => {
    try {
        // Check if trading API connection is available
        if (!tradingApi?.connection) {
            throw new Error('Trading API connection not available');
        }

        const subscribeRequest = {
            proposal_open_contract: 1,
            contract_id: contractId,
            subscribe: 1
        };

        // Send subscription request
        await tradingApi.send(subscribeRequest);
        
        // Create proper message handler for WebSocket events
        const handleContractUpdate = (event: MessageEvent) => {
            try {
                const data = JSON.parse(event.data);
                
                if (data.msg_type === 'proposal_open_contract' && 
                    data.proposal_open_contract &&
                    String(data.proposal_open_contract.contract_id) === String(contractId)) {
                    
                    const contract = data.proposal_open_contract;
                    
                    if (contract.is_sold || contract.status === 'sold') {
                        const profit = Number(contract.profit || 0);
                        const payout = Number(contract.payout || 0);
                        
                        setTotalPayout(prev => prev + payout);
                        
                        if (profit > 0) {
                            setContractsWon(prev => prev + 1);
                            setLastOutcome('win');
                            setLossStreak(0);
                            setCurrentStake(baseStake);
                            setStatus(`✅ Contract won! Profit: $${profit.toFixed(2)}`);
                        } else {
                            setContractsLost(prev => prev + 1);
                            setLastOutcome('loss');
                            setLossStreak(prev => prev + 1);
                            setStatus(`❌ Contract lost. Loss: $${Math.abs(profit).toFixed(2)}`);
                        }
                        
                        // Remove listener
                        tradingApi.connection.removeEventListener('message', handleContractUpdate);
                    }
                }
            } catch (error) {
                console.error('Error parsing contract update:', error);
            }
        };

        // Add event listener to the actual connection
        tradingApi.connection.addEventListener('message', handleContractUpdate);
        
        // Auto cleanup after 5 minutes
        setTimeout(() => {
            if (tradingApi.connection) {
                tradingApi.connection.removeEventListener('message', handleContractUpdate);
            }
        }, 300000);

    } catch (error) {
        console.error('Error monitoring contract:', error);
        setStatus(`Monitoring error: ${error.message}`);
    }
};
```

### 2. **Add Debug Logging to executeAutoTrade**

```jsx
const executeAutoTrade = async () => {
    const timestamp = new Date().toLocaleTimeString();
    console.log(`[${timestamp}] 🚀 Checking auto trade conditions`);

    if (!tradingApi) {
        console.error(`[${timestamp}] Trading API not ready`);
        return;
    }

    // Add connection check
    if (!tradingApi.connection || tradingApi.connection.readyState !== WebSocket.OPEN) {
        console.error(`[${timestamp}] Trading API connection not ready`);
        return;
    }

    if (connectionStatus !== 'connected') {
        console.error(`[${timestamp}] Not connected to market data API`);
        return;
    }

    // Check if enough time has passed since last trade
    const currentTime = Date.now();
    if (currentTime - lastTradeTimeRef.current < minTimeBetweenTrades) {
        console.log(`[${timestamp}] Too soon since last trade, skipping`);
        return;
    }

    // Check trading conditions
    const conditionsMet = checkTradingConditions();
    if (!conditionsMet) {
        console.log(`[${timestamp}] Trading conditions not met`);
        return;
    }

    try {
        await authorizeIfNeeded();

        // Determine contract type based on condition
        let contractType = '';
        if (conditionType === 'Rise Prob') {
            contractType = 'CALL';
        } else if (conditionType === 'Fall Prob') {
            contractType = 'PUT';
        } else {
            // Default based on current analysis
            contractType = (analysisData.riseRatio || 0) > (analysisData.fallRatio || 0) ? 'CALL' : 'PUT';
        }
        
        // Calculate stake with martingale
        const stakeToUse = lastOutcome === 'loss' && lossStreak > 0 
            ? Math.min(currentStake * martingaleSteps, baseStake * 10) 
            : baseStake;

        setCurrentStake(stakeToUse);

        const buyRequest = {
            buy: '1',
            price: stakeToUse,
            parameters: {
                amount: stakeToUse,
                basis: 'stake',
                contract_type: contractType,
                currency: 'USD',
                duration: tickDuration,
                duration_unit: 't',
                symbol: selectedSymbol
            }
        };

        console.log(`[${timestamp}] Sending buy request:`, JSON.stringify(buyRequest, null, 2));
        setStatus(`Auto trading: Buying ${contractType} contract for $${stakeToUse}...`);

        lastTradeTimeRef.current = currentTime;

        const buyResponse = await tradingApi.buy(buyRequest);
        console.log(`[${timestamp}] Buy response:`, JSON.stringify(buyResponse, null, 2));

        if (buyResponse.error) {
            throw new Error(buyResponse.error.message);
        }

        if (!buyResponse.buy || !buyResponse.buy.contract_id) {
            throw new Error('Invalid buy response: missing contract_id');
        }

        setTotalRuns(prev => prev + 1);
        setTotalStake(prev => prev + stakeToUse);

        setStatus(`✅ Auto trade executed: ${buyResponse.buy.contract_id}`);
        console.log(`[${timestamp}] ✅ Auto trade successful: ${buyResponse.buy.contract_id}`);
        
        monitorContract(buyResponse.buy.contract_id, stakeToUse);

    } catch (error) {
        console.error(`[${timestamp}] ❌ Auto trade error:`, error);
        setStatus(`Auto trade error: ${error.message}`);
        setLastOutcome('loss');
        setLossStreak(prev => prev + 1);
    }
};
```

### 3. **Add Trading API Status Monitoring**

```jsx
// Add this useEffect to monitor trading API status
useEffect(() => {
    console.log('Trading API status:', {
        hasTradingApi: !!tradingApi,
        isAuthorized,
        connectionReady: tradingApi?.connection?.readyState === WebSocket.OPEN
    });
}, [tradingApi, isAuthorized]);

// Add this to check connection status periodically
useEffect(() => {
    const checkConnection = () => {
        if (tradingApi?.connection) {
            console.log('Trading API connection state:', tradingApi.connection.readyState);
        }
    };

    const interval = setInterval(checkConnection, 5000);
    return () => clearInterval(interval);
}, [tradingApi]);
```

### 4. **Fix the Trading Interval Logic**

```jsx
const startAutoTrading = () => {
    if (connectionStatus !== 'connected') {
        alert('Cannot start auto trading: Not connected to market data API');
        return;
    }

    if (!tradingApi) {
        alert('Trading API not initialized');
        return;
    }

    if (!tradingApi.connection || tradingApi.connection.readyState !== WebSocket.OPEN) {
        alert('Trading API connection not ready. Please wait...');
        return;
    }

    // Clear existing interval if any
    if (tradingInterval) {
        clearInterval(tradingInterval);
        setTradingInterval(null);
    }

    setIsAutoTrading(true);
    setStatus('Auto trading started - checking conditions...');

    // More conservative interval timing
    let intervalMs = 2000; // 2 seconds default
    if (selectedSymbol.includes('1HZ')) {
        intervalMs = 1500; // 1.5 seconds for 1s volatilities
    }

    console.log(`Starting auto trading with ${intervalMs}ms interval`);

    // Create the trading interval
    const interval = setInterval(executeAutoTrade, intervalMs);
    setTradingInterval(interval);

    console.log('✅ Auto trading started');
};
```

## Testing Steps:

1. **Check browser console** for any error messages
2. **Test manual trading first** - if manual trades work, auto trading should work
3. **Look for the debug logs** I added to see where the process might be failing
4. **Verify both WebSocket connections** (market data and trading API) are properly connected

The key issue was in the `monitorContract` function - it was expecting parsed data instead of handling the raw MessageEvent. This should now be fixed with the updated implementation.

Try these fixes and check the browser console for the detailed debug logs. This will help identify exactly where the process is failing if there are still issues.