// === Standalone Speed Bot with WebSocket Integration ===
// This script retrieves real-time data from Deriv using WebSocket and executes trades based on strategies.

// Deriv WebSocket configuration
const APP_ID = 68848; // Replace with your app ID
const WS_URL = "wss://ws.binaryws.com/websockets/v3";

// Global variables
let currentBalance = 1000; // Starting balance
let stake = 1;             // Initial stake
let baseStake = 1;
let lossCount = 0;
let marketOpen = true;

const MAX_LOSS_COUNT = 2;

// WebSocket setup
let derivWs = null;
let tickHistory = [];
let currentSymbol = "R_10"; // Default symbol
let tickCount = 120;        // Number of ticks to fetch
let decimalPlaces = 2;
let overUnderBarrier = 5;

// Initialize WebSocket connection
function startWebSocket() {
    console.log("ðŸš€ Connecting to WebSocket API...");
    if (derivWs) {
        try {
            derivWs.onclose = null;
            derivWs.close();
            console.log("Closed existing connection");
        } catch (e) {
            console.error("Error closing existing connection:", e);
        }
        derivWs = null;
    }

    derivWs = new WebSocket(`${WS_URL}?app_id=${APP_ID}`);
    derivWs.onopen = () => {
        console.log("âœ… WebSocket connection established");
        requestAuthorization();
        requestTickHistory();
    };
    derivWs.onmessage = (event) => handleWebSocketMessage(event);
    derivWs.onerror = (error) => console.error("WebSocket error:", error);
    derivWs.onclose = (event) => handleWebSocketClose(event);
}

// Request authorization
function requestAuthorization() {
    console.log("Sending authorization request...");
    derivWs.send(JSON.stringify({ app_id: APP_ID }));
}

// Request tick history
function requestTickHistory() {
    console.log(`Requesting tick history for ${currentSymbol} (${tickCount} ticks)...`);
    const request = {
        ticks_history: currentSymbol,
        count: tickCount,
        end: "latest",
        style: "ticks",
        subscribe: 1,
    };
    derivWs.send(JSON.stringify(request));
}

// Handle WebSocket messages
function handleWebSocketMessage(event) {
    const message = JSON.parse(event.data);

    if (message.error) {
        console.error("WebSocket API error:", message.error);
        return;
    }

    if (message.msg_type === "tick") {
        tickHistory.push(message);
        console.log(`Received new tick: ${message.tick}`);
        executeStrategy();
    }
}

// Handle WebSocket close event
function handleWebSocketClose(event) {
    console.log("WebSocket connection closed", event);
    if (event.wasClean) {
        console.log("Connection closed cleanly");
    } else {
        console.error("Connection died");
        setTimeout(startWebSocket, 5000); // Reconnect after 5 seconds
    }
}

// Execute trading strategy
function executeStrategy() {
    if (!marketOpen) {
        console.log("[INFO] Market is closed. Waiting...");
        return;
    }

    const lastTick = tickHistory[tickHistory.length - 1]?.tick || 0;
    console.log(`[TICK] Current value: ${lastTick}`);

    // Strategy logic: Buy "Digit Over" when tick ends with .236
    if (lastTick.toString().endsWith('6')) {
        apollo_purchase("DIGITOVER");
    } else {
        console.log("[INFO] No trade condition met.");
    }
}

// Simulate trade execution
function apollo_purchase(contractType) {
    console.log(`[ACTION] Purchasing contract: ${contractType} with stake: $${stake.toFixed(2)}`);

    // Simulate random result
    const isWin = Math.random() > 0.5;
    const profit = isWin ? stake : -stake;
    currentBalance += profit;
    lossCount = isWin ? 0 : lossCount + 1;

    console.log(`[RESULT] ${isWin ? "Win" : "Loss"} | New Balance: $${currentBalance.toFixed(2)} | Loss Count: ${lossCount}`);

    // Apply strategy
    applyStrategy(isWin);

    return isWin;
}

// Apply Martingale/D'Alembert strategy
function applyStrategy(won) {
    // Martingale: double after loss
    if (!won) {
        stake *= 2;
    } else {
        stake = baseStake;
        lossCount = 0;
    }

    // Optional: D'Alembert
    // if (won) stake -= baseStake;
    // else stake += baseStake;

    // Clamp stake
    stake = Math.max(baseStake, stake);

    // Stop if max loss count reached
    if (lossCount >= MAX_LOSS_COUNT) {
        console.log("[INFO] Max loss limit reached. Stopping bot.");
        process.exit?.(); // For Node.js
        return false;
    }

    return true;
}

// Start the bot
function runSpeedBot() {
    console.log("ðŸš€ Speed Bot Started!");
    startWebSocket();
}

// Initialize the bot
runSpeedBot();