interface TickData {
    symbol: string;
    price: number;
    timestamp: number;
    epoch: number;
}

interface TrendSignal {
    direction: 'UP' | 'DOWN' | 'NEUTRAL';
    confidence: number; // 0-100
    strength: 'STRONG' | 'MEDIUM' | 'WEAK';
    recommendation: 'HIGHER' | 'LOWER' | 'HOLD';
    timeToExpiry: number; // seconds until signal expires
    reasons: string[];
}

interface TickAnalysis {
    ema5: number;
    ema13: number;
    ema21: number;
    rsi: number;
    momentum: number;
    tickVelocity: number;
    priceAction: 'BULLISH' | 'BEARISH' | 'NEUTRAL';
    volume?: number; // if available
}

export class DerivTickTrendAnalyzer {
    private tickHistory: Map<string, TickData[]> = new Map();
    private analysisCache: Map<string, TickAnalysis> = new Map();
    private signalHistory: Map<string, TrendSignal[]> = new Map();
    
    // Configuration for 2-minute trading
    private readonly TICK_BUFFER_SIZE = 600; // Keep last 10 minutes of ticks (assuming 1 tick/second)
    private readonly SIGNAL_VALIDITY_SECONDS = 30; // Signal valid for 30 seconds
    private readonly MIN_TICKS_FOR_ANALYSIS = 60; // Need at least 1 minute of data
    
    constructor() {
        console.log('Deriv Tick Trend Analyzer initialized for 2-minute binary options');
    }

    /**
     * Process incoming tick data and generate trading signals
     */
    processTick(tick: TickData): TrendSignal | null {
        this.storeTick(tick);
        
        const history = this.tickHistory.get(tick.symbol);
        if (!history || history.length < this.MIN_TICKS_FOR_ANALYSIS) {
            return null;
        }

        // Perform rapid tick analysis
        const analysis = this.analyzeTickData(tick.symbol);
        this.analysisCache.set(tick.symbol, analysis);

        // Generate trend signal
        const signal = this.generateTrendSignal(tick.symbol, analysis);
        
        // Store signal for tracking
        this.storeSignal(tick.symbol, signal);
        
        return signal;
    }

    private storeTick(tick: TickData): void {
        if (!this.tickHistory.has(tick.symbol)) {
            this.tickHistory.set(tick.symbol, []);
        }
        
        const history = this.tickHistory.get(tick.symbol)!;
        history.push(tick);
        
        // Keep buffer size manageable
        if (history.length > this.TICK_BUFFER_SIZE) {
            history.shift();
        }
    }

    private analyzeTickData(symbol: string): TickAnalysis {
        const ticks = this.tickHistory.get(symbol)!;
        const prices = ticks.map(t => t.price);
        const timestamps = ticks.map(t => t.timestamp);
        
        // Calculate ultra-fast EMAs for tick data
        const ema5 = this.calculateTickEMA(prices, 5);
        const ema13 = this.calculateTickEMA(prices, 13);
        const ema21 = this.calculateTickEMA(prices, 21);
        
        // Calculate RSI on tick data (last 30 ticks)
        const rsi = this.calculateTickRSI(prices.slice(-30));
        
        // Calculate momentum (rate of change over last 20 ticks)
        const momentum = this.calculateTickMomentum(prices, 20);
        
        // Calculate tick velocity (price change per second)
        const tickVelocity = this.calculateTickVelocity(ticks.slice(-20));
        
        // Analyze price action patterns
        const priceAction = this.analyzePriceAction(prices.slice(-40));

        return {
            ema5,
            ema13,
            ema21,
            rsi,
            momentum,
            tickVelocity,
            priceAction
        };
    }

    private calculateTickEMA(prices: number[], period: number): number {
        if (prices.length < period) return prices[prices.length - 1];
        
        const multiplier = 2 / (period + 1);
        let ema = prices[0];
        
        for (let i = 1; i < prices.length; i++) {
            ema = (prices[i] * multiplier) + (ema * (1 - multiplier));
        }
        
        return ema;
    }

    private calculateTickRSI(prices: number[]): number {
        if (prices.length < 14) return 50; // Neutral RSI
        
        let gains = 0;
        let losses = 0;
        
        for (let i = 1; i < prices.length; i++) {
            const change = prices[i] - prices[i - 1];
            if (change > 0) {
                gains += change;
            } else {
                losses += Math.abs(change);
            }
        }
        
        const avgGain = gains / (prices.length - 1);
        const avgLoss = losses / (prices.length - 1);
        
        if (avgLoss === 0) return 100;
        
        const rs = avgGain / avgLoss;
        const rsi = 100 - (100 / (1 + rs));
        
        return rsi;
    }

    private calculateTickMomentum(prices: number[], period: number): number {
        if (prices.length < period) return 0;
        
        const currentPrice = prices[prices.length - 1];
        const pastPrice = prices[prices.length - period];
        
        return ((currentPrice - pastPrice) / pastPrice) * 100;
    }

    private calculateTickVelocity(ticks: TickData[]): number {
        if (ticks.length < 2) return 0;
        
        const timeSpan = (ticks[ticks.length - 1].timestamp - ticks[0].timestamp) / 1000; // seconds
        const priceChange = ticks[ticks.length - 1].price - ticks[0].price;
        
        return priceChange / timeSpan; // price change per second
    }

    private analyzePriceAction(prices: number[]): 'BULLISH' | 'BEARISH' | 'NEUTRAL' {
        if (prices.length < 20) return 'NEUTRAL';
        
        // Analyze recent candle patterns using tick data
        const recentPrices = prices.slice(-20);
        const midPoint = Math.floor(recentPrices.length / 2);
        
        const firstHalf = recentPrices.slice(0, midPoint);
        const secondHalf = recentPrices.slice(midPoint);
        
        const firstHalfAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
        const secondHalfAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
        
        const changePercent = ((secondHalfAvg - firstHalfAvg) / firstHalfAvg) * 100;
        
        if (changePercent > 0.01) return 'BULLISH';
        if (changePercent < -0.01) return 'BEARISH';
        return 'NEUTRAL';
    }

    private generateTrendSignal(symbol: string, analysis: TickAnalysis): TrendSignal {
        const reasons: string[] = [];
        let bullishPoints = 0;
        let bearishPoints = 0;
        
        // EMA alignment analysis (25 points max)
        if (analysis.ema5 > analysis.ema13 && analysis.ema13 > analysis.ema21) {
            bullishPoints += 25;
            reasons.push('All EMAs aligned bullish');
        } else if (analysis.ema5 < analysis.ema13 && analysis.ema13 < analysis.ema21) {
            bearishPoints += 25;
            reasons.push('All EMAs aligned bearish');
        } else if (analysis.ema5 > analysis.ema13) {
            bullishPoints += 12;
            reasons.push('Short-term EMA bullish');
        } else if (analysis.ema5 < analysis.ema13) {
            bearishPoints += 12;
            reasons.push('Short-term EMA bearish');
        }
        
        // RSI analysis (20 points max)
        if (analysis.rsi > 70) {
            bearishPoints += 15;
            reasons.push('RSI overbought');
        } else if (analysis.rsi < 30) {
            bullishPoints += 15;
            reasons.push('RSI oversold');
        } else if (analysis.rsi > 55) {
            bullishPoints += 8;
            reasons.push('RSI bullish bias');
        } else if (analysis.rsi < 45) {
            bearishPoints += 8;
            reasons.push('RSI bearish bias');
        }
        
        // Momentum analysis (25 points max)
        if (analysis.momentum > 0.05) {
            bullishPoints += 20;
            reasons.push('Strong positive momentum');
        } else if (analysis.momentum < -0.05) {
            bearishPoints += 20;
            reasons.push('Strong negative momentum');
        } else if (analysis.momentum > 0.01) {
            bullishPoints += 10;
            reasons.push('Positive momentum');
        } else if (analysis.momentum < -0.01) {
            bearishPoints += 10;
            reasons.push('Negative momentum');
        }
        
        // Tick velocity analysis (15 points max)
        if (Math.abs(analysis.tickVelocity) > 0.001) {
            if (analysis.tickVelocity > 0) {
                bullishPoints += 15;
                reasons.push('Fast upward price movement');
            } else {
                bearishPoints += 15;
                reasons.push('Fast downward price movement');
            }
        } else if (Math.abs(analysis.tickVelocity) > 0.0005) {
            if (analysis.tickVelocity > 0) {
                bullishPoints += 8;
                reasons.push('Moderate upward movement');
            } else {
                bearishPoints += 8;
                reasons.push('Moderate downward movement');
            }
        }
        
        // Price action analysis (15 points max)
        if (analysis.priceAction === 'BULLISH') {
            bullishPoints += 15;
            reasons.push('Bullish price action');
        } else if (analysis.priceAction === 'BEARISH') {
            bearishPoints += 15;
            reasons.push('Bearish price action');
        }
        
        // Determine direction and confidence
        const totalPoints = bullishPoints + bearishPoints;
        const netBullish = bullishPoints - bearishPoints;
        const confidence = totalPoints > 0 ? Math.abs(netBullish) / totalPoints * 100 : 0;
        
        let direction: 'UP' | 'DOWN' | 'NEUTRAL' = 'NEUTRAL';
        let recommendation: 'HIGHER' | 'LOWER' | 'HOLD' = 'HOLD';
        let strength: 'STRONG' | 'MEDIUM' | 'WEAK' = 'WEAK';
        
        if (netBullish > 15 && confidence > 60) {
            direction = 'UP';
            recommendation = 'HIGHER';
            strength = confidence > 80 ? 'STRONG' : 'MEDIUM';
        } else if (netBullish < -15 && confidence > 60) {
            direction = 'DOWN';
            recommendation = 'LOWER';
            strength = confidence > 80 ? 'STRONG' : 'MEDIUM';
        }
        
        return {
            direction,
            confidence: Math.min(95, confidence),
            strength,
            recommendation,
            timeToExpiry: this.SIGNAL_VALIDITY_SECONDS,
            reasons
        };
    }

    private storeSignal(symbol: string, signal: TrendSignal): void {
        if (!this.signalHistory.has(symbol)) {
            this.signalHistory.set(symbol, []);
        }
        
        const history = this.signalHistory.get(symbol)!;
        history.push(signal);
        
        // Keep only last 20 signals
        if (history.length > 20) {
            history.shift();
        }
    }

    /**
     * Get the most recent signal for a symbol
     */
    getLatestSignal(symbol: string): TrendSignal | null {
        const history = this.signalHistory.get(symbol);
        return history && history.length > 0 ? history[history.length - 1] : null;
    }

    /**
     * Get current market conditions for decision making
     */
    getMarketCondition(symbol: string): {
        trending: boolean;
        volatility: 'HIGH' | 'MEDIUM' | 'LOW';
        suitableForTrading: boolean;
        reason: string;
    } {
        const analysis = this.analysisCache.get(symbol);
        if (!analysis) {
            return {
                trending: false,
                volatility: 'LOW',
                suitableForTrading: false,
                reason: 'Insufficient data'
            };
        }

        const ticks = this.tickHistory.get(symbol);
        if (!ticks) {
            return {
                trending: false,
                volatility: 'LOW',
                suitableForTrading: false,
                reason: 'No tick data'
            };
        }

        // Calculate volatility from recent price swings
        const recentPrices = ticks.slice(-60).map(t => t.price);
        const priceRange = Math.max(...recentPrices) - Math.min(...recentPrices);
        const avgPrice = recentPrices.reduce((a, b) => a + b, 0) / recentPrices.length;
        const volatilityPercent = (priceRange / avgPrice) * 100;

        let volatility: 'HIGH' | 'MEDIUM' | 'LOW' = 'LOW';
        if (volatilityPercent > 0.2) volatility = 'HIGH';
        else if (volatilityPercent > 0.05) volatility = 'MEDIUM';

        // Check if market is trending
        const emaSpread = Math.abs(analysis.ema5 - analysis.ema21) / analysis.ema21 * 100;
        const trending = emaSpread > 0.02 && Math.abs(analysis.momentum) > 0.01;

        // Determine if suitable for trading
        const suitableForTrading = trending && volatility !== 'LOW' && Math.abs(analysis.tickVelocity) > 0.0003;

        let reason = '';
        if (!trending) reason = 'Market not trending clearly';
        else if (volatility === 'LOW') reason = 'Low volatility';
        else if (Math.abs(analysis.tickVelocity) <= 0.0003) reason = 'Insufficient price movement';
        else reason = 'Good trading conditions';

        return {
            trending,
            volatility,
            suitableForTrading,
            reason
        };
    }

    /**
     * Generate trading recommendation with risk management
     */
    generateTradingDecision(symbol: string): {
        action: 'HIGHER' | 'LOWER' | 'WAIT';
        confidence: number;
        reasoning: string[];
        riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
    } {
        const signal = this.getLatestSignal(symbol);
        const marketCondition = this.getMarketCondition(symbol);

        if (!signal || !marketCondition.suitableForTrading) {
            return {
                action: 'WAIT',
                confidence: 0,
                reasoning: ['Market conditions not suitable for trading'],
                riskLevel: 'HIGH'
            };
        }

        // Risk assessment
        let riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' = 'MEDIUM';
        if (signal.confidence > 80 && signal.strength === 'STRONG' && marketCondition.volatility === 'MEDIUM') {
            riskLevel = 'LOW';
        } else if (signal.confidence < 65 || marketCondition.volatility === 'HIGH') {
            riskLevel = 'HIGH';
        }

        // Only trade if confidence is high enough
        if (signal.confidence < 60) {
            return {
                action: 'WAIT',
                confidence: signal.confidence,
                reasoning: ['Confidence too low for trading', ...signal.reasons],
                riskLevel
            };
        }

        return {
            action: signal.recommendation === 'HOLD' ? 'WAIT' : signal.recommendation,
            confidence: signal.confidence,
            reasoning: signal.reasons,
            riskLevel
        };
    }

    /**
     * Clean up old data
     */
    cleanup(): void {
        const now = Date.now();
        const maxAge = 10 * 60 * 1000; // 10 minutes

        for (const [symbol, ticks] of this.tickHistory.entries()) {
            const filteredTicks = ticks.filter(tick => now - tick.timestamp < maxAge);
            this.tickHistory.set(symbol, filteredTicks);
        }
    }
}