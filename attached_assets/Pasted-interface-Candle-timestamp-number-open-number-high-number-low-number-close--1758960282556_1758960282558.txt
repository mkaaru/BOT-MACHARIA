interface Candle {
  timestamp: number;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
}

interface TrendSignal {
  direction: 'bullish' | 'bearish' | 'neutral';
  strength: number; // 0-100
  confidence: number; // 0-100
  entry: boolean;
  exit: boolean;
}

class EhlersPredictiveSystem {
  private data: Candle[] = [];
  private period: number = 20;
  private alpha: number = 0.07; // Smoothing factor
  
  constructor(period: number = 20) {
    this.period = period;
    this.alpha = 2 / (period + 1);
  }

  // Add new candle data
  addCandle(candle: Candle): void {
    this.data.push(candle);
    // Keep only necessary data for calculations (last 100 candles)
    if (this.data.length > 100) {
      this.data.shift();
    }
  }

  // Ehlers Super Smoother Filter
  private superSmoother(prices: number[], period: number = 10): number[] {
    const result: number[] = [];
    const a1 = Math.exp(-1.414 * Math.PI / period);
    const b1 = 2 * a1 * Math.cos(1.414 * Math.PI / period);
    const c2 = b1;
    const c3 = -a1 * a1;
    const c1 = 1 - c2 - c3;

    for (let i = 0; i < prices.length; i++) {
      if (i < 2) {
        result.push(prices[i]);
      } else {
        const value = c1 * (prices[i] + prices[i - 1]) / 2 + 
                     c2 * result[i - 1] + 
                     c3 * result[i - 2];
        result.push(value);
      }
    }
    return result;
  }

  // Ehlers MESA Adaptive Moving Average (MAMA)
  private calculateMAMA(prices: number[]): { mama: number[], fama: number[] } {
    const mama: number[] = [];
    const fama: number[] = [];
    const period: number[] = [];
    const smooth: number[] = [];
    const detrender: number[] = [];
    const i1: number[] = [];
    const q1: number[] = [];
    const ji: number[] = [];
    const jq: number[] = [];
    const i2: number[] = [];
    const q2: number[] = [];
    const re: number[] = [];
    const im: number[] = [];
    const spp: number[] = [];
    const phase: number[] = [];

    for (let i = 0; i < prices.length; i++) {
      // Smooth prices
      if (i < 4) {
        smooth.push(prices[i]);
        detrender.push(0);
        period.push(0);
        mama.push(prices[i]);
        fama.push(prices[i]);
        continue;
      }

      smooth[i] = (4 * prices[i] + 3 * prices[i - 1] + 2 * prices[i - 2] + prices[i - 3]) / 10;
      
      // Detrend
      detrender[i] = (0.0962 * smooth[i] + 0.5769 * smooth[i - 2] - 
                     0.5769 * smooth[i - 4] - 0.0962 * smooth[i - 6]) * 
                     (0.075 * period[i - 1] + 0.54);

      // Compute InPhase and Quadrature components
      if (i < 7) {
        i1.push(0);
        q1.push(0);
      } else {
        i1[i] = detrender[i - 3];
        q1[i] = (0.0962 * detrender[i] + 0.5769 * detrender[i - 2] - 
                0.5769 * detrender[i - 4] - 0.0962 * detrender[i - 6]) * 
                (0.075 * period[i - 1] + 0.54);
      }

      // Advance the phase of I1 and Q1 by 90 degrees
      ji[i] = (0.0962 * i1[i] + 0.5769 * i1[i - 2] - 
              0.5769 * i1[i - 4] - 0.0962 * i1[i - 6]) * 
              (0.075 * period[i - 1] + 0.54);
      
      jq[i] = (0.0962 * q1[i] + 0.5769 * q1[i - 2] - 
              0.5769 * q1[i - 4] - 0.0962 * q1[i - 6]) * 
              (0.075 * period[i - 1] + 0.54);

      // Phasor addition for 3 bar averaging
      i2[i] = i1[i] - jq[i];
      q2[i] = q1[i] + ji[i];

      // Smooth the I and Q components before applying the discriminator
      i2[i] = 0.2 * i2[i] + 0.8 * (i2[i - 1] || 0);
      q2[i] = 0.2 * q2[i] + 0.8 * (q2[i - 1] || 0);

      // Homodyne Discriminator
      re[i] = i2[i] * (i2[i - 1] || 0) + q2[i] * (q2[i - 1] || 0);
      im[i] = i2[i] * (q2[i - 1] || 0) - q2[i] * (i2[i - 1] || 0);
      
      re[i] = 0.2 * re[i] + 0.8 * (re[i - 1] || 0);
      im[i] = 0.2 * im[i] + 0.8 * (im[i - 1] || 0);

      if (im[i] !== 0 && re[i] !== 0) {
        period[i] = 2 * Math.PI / Math.atan(im[i] / re[i]);
      } else {
        period[i] = period[i - 1] || 0;
      }

      if (period[i] > 1.5 * (period[i - 1] || 0)) period[i] = 1.5 * (period[i - 1] || 0);
      if (period[i] < 0.67 * (period[i - 1] || 0)) period[i] = 0.67 * (period[i - 1] || 0);
      if (period[i] < 6) period[i] = 6;
      if (period[i] > 50) period[i] = 50;
      
      period[i] = 0.2 * period[i] + 0.8 * (period[i - 1] || 0);
      spp[i] = 0.33 * period[i] + 0.67 * (spp[i - 1] || 0);

      phase[i] = Math.atan(q1[i] / i1[i]);

      const fastLimit = 0.5 / spp[i];
      const slowLimit = 0.05 / spp[i];

      if (i === 0) {
        mama.push(prices[i]);
        fama.push(prices[i]);
      } else {
        const mamaVal = fastLimit * prices[i] + (1 - fastLimit) * mama[i - 1];
        const famaVal = slowLimit * mamaVal + (1 - slowLimit) * fama[i - 1];
        mama.push(mamaVal);
        fama.push(famaVal);
      }
    }

    return { mama, fama };
  }

  // Ehlers Hilbert Transform Trend vs Cycle
  private hilbertTransform(prices: number[]): { trend: number[], signal: number[] } {
    const trend: number[] = [];
    const signal: number[] = [];
    const smooth: number[] = [];
    const detrender: number[] = [];
    const i1: number[] = [];
    const q1: number[] = [];
    const i2: number[] = [];
    const q2: number[] = [];
    const re: number[] = [];
    const im: number[] = [];
    const period: number[] = [];
    const smoothPeriod: number[] = [];
    const dcPeriod: number[] = [];
    const dcPhase: number[] = [];
    const instPeriod: number[] = [];

    for (let i = 0; i < prices.length; i++) {
      if (i < 7) {
        smooth.push(prices[i]);
        trend.push(prices[i]);
        signal.push(0);
        continue;
      }

      // Smooth the data
      smooth[i] = (4 * prices[i] + 3 * prices[i - 1] + 2 * prices[i - 2] + prices[i - 3]) / 10;

      // Detrend
      detrender[i] = (0.0962 * smooth[i] + 0.5769 * smooth[i - 2] - 
                     0.5769 * smooth[i - 4] - 0.0962 * smooth[i - 6]);

      // Hilbert Transform
      i1[i] = detrender[i - 3];
      q1[i] = (0.0962 * detrender[i] + 0.5769 * detrender[i - 2] - 
              0.5769 * detrender[i - 4] - 0.0962 * detrender[i - 6]);

      // Smooth the Hilbert Transform
      i2[i] = 0.2 * i1[i] + 0.8 * (i2[i - 1] || 0);
      q2[i] = 0.2 * q1[i] + 0.8 * (q2[i - 1] || 0);

      // Calculate period
      re[i] = i2[i] * (i2[i - 1] || 0) + q2[i] * (q2[i - 1] || 0);
      im[i] = i2[i] * (q2[i - 1] || 0) - q2[i] * (i2[i - 1] || 0);

      if (re[i] !== 0 && im[i] !== 0) {
        period[i] = 2 * Math.PI / Math.atan(im[i] / re[i]);
      } else {
        period[i] = period[i - 1] || 0;
      }

      // Smooth period
      smoothPeriod[i] = 0.33 * period[i] + 0.67 * (smoothPeriod[i - 1] || 0);

      // Calculate trend
      const trendValue = (smooth[i] + smooth[i - 1] + smooth[i - 2]) / 3;
      trend.push(trendValue);

      // Generate signal based on trend direction
      const trendSlope = trend[i] - (trend[i - 1] || trend[i]);
      signal.push(trendSlope > 0 ? 1 : trendSlope < 0 ? -1 : 0);
    }

    return { trend, signal };
  }

  // Ehlers Rocket RSI
  private rocketRSI(prices: number[], period: number = 8): number[] {
    const rsi: number[] = [];
    const momentum: number[] = [];
    const avgUp: number[] = [];
    const avgDown: number[] = [];

    for (let i = 0; i < prices.length; i++) {
      if (i === 0) {
        momentum.push(0);
        avgUp.push(0);
        avgDown.push(0);
        rsi.push(50);
        continue;
      }

      // Calculate momentum
      momentum[i] = prices[i] - prices[i - 1];

      // Separate up and down movements
      const upMove = momentum[i] > 0 ? momentum[i] : 0;
      const downMove = momentum[i] < 0 ? Math.abs(momentum[i]) : 0;

      // Calculate exponential moving averages
      if (i === 1) {
        avgUp[i] = upMove;
        avgDown[i] = downMove;
      } else {
        const alpha = 2 / (period + 1);
        avgUp[i] = alpha * upMove + (1 - alpha) * avgUp[i - 1];
        avgDown[i] = alpha * downMove + (1 - alpha) * avgDown[i - 1];
      }

      // Calculate RSI
      if (avgDown[i] === 0) {
        rsi[i] = 100;
      } else {
        const rs = avgUp[i] / avgDown[i];
        rsi[i] = 100 - (100 / (1 + rs));
      }
    }

    return rsi;
  }

  // Generate comprehensive trend signal
  generateTrendSignal(): TrendSignal | null {
    if (this.data.length < 50) {
      return null; // Need sufficient data
    }

    const closes = this.data.map(candle => candle.close);
    const highs = this.data.map(candle => candle.high);
    const lows = this.data.map(candle => candle.low);

    // Calculate Ehlers indicators
    const { mama, fama } = this.calculateMAMA(closes);
    const { trend, signal } = this.hilbertTransform(closes);
    const rsi = this.rocketRSI(closes);
    const smoothedPrices = this.superSmoother(closes);

    const currentIndex = closes.length - 1;
    const currentClose = closes[currentIndex];
    const currentMAMA = mama[currentIndex];
    const currentFAMA = fama[currentIndex];
    const currentTrend = trend[currentIndex];
    const currentRSI = rsi[currentIndex];
    const currentSignal = signal[currentIndex];

    // Determine trend direction
    let direction: 'bullish' | 'bearish' | 'neutral' = 'neutral';
    let strength = 0;
    let confidence = 0;

    // MAMA/FAMA trend analysis
    const mamaSignal = currentMAMA > currentFAMA ? 1 : -1;
    const trendSignal = currentSignal;
    const priceVsTrend = currentClose > currentTrend ? 1 : -1;

    // RSI momentum analysis
    let rsiSignal = 0;
    if (currentRSI > 70) rsiSignal = 1; // Overbought but strong
    else if (currentRSI < 30) rsiSignal = -1; // Oversold
    else if (currentRSI > 50) rsiSignal = 0.5;
    else if (currentRSI < 50) rsiSignal = -0.5;

    // Combine signals
    const combinedSignal = (mamaSignal + trendSignal + priceVsTrend + rsiSignal) / 4;

    if (combinedSignal > 0.25) {
      direction = 'bullish';
      strength = Math.min(100, Math.abs(combinedSignal) * 100);
    } else if (combinedSignal < -0.25) {
      direction = 'bearish';
      strength = Math.min(100, Math.abs(combinedSignal) * 100);
    }

    // Calculate confidence based on signal alignment
    const signalAlignment = [mamaSignal, trendSignal, priceVsTrend].filter(s => 
      Math.sign(s) === Math.sign(combinedSignal)
    ).length;
    confidence = (signalAlignment / 3) * 100;

    // Entry/Exit signals
    const prevMAMA = mama[currentIndex - 1] || currentMAMA;
    const prevFAMA = fama[currentIndex - 1] || currentFAMA;
    
    const entry = (currentMAMA > currentFAMA && prevMAMA <= prevFAMA && direction === 'bullish') ||
                  (currentMAMA < currentFAMA && prevMAMA >= prevFAMA && direction === 'bearish');

    const exit = (currentMAMA < currentFAMA && direction === 'bullish') ||
                 (currentMAMA > currentFAMA && direction === 'bearish');

    return {
      direction,
      strength,
      confidence,
      entry,
      exit
    };
  }

  // Get current market analysis
  getMarketAnalysis(): any {
    if (this.data.length < 20) return null;

    const signal = this.generateTrendSignal();
    const closes = this.data.map(candle => candle.close);
    const { mama, fama } = this.calculateMAMA(closes);
    const rsi = this.rocketRSI(closes);

    return {
      signal,
      currentPrice: closes[closes.length - 1],
      mama: mama[mama.length - 1],
      fama: fama[fama.length - 1],
      rsi: rsi[rsi.length - 1],
      timestamp: this.data[this.data.length - 1].timestamp
    };
  }
}

// Example usage and testing
class TradingBot {
  private ehlers: EhlersPredictiveSystem;
  private position: 'long' | 'short' | null = null;
  private entryPrice: number = 0;

  constructor() {
    this.ehlers = new EhlersPredictiveSystem(20);
  }

  processCandle(candle: Candle): void {
    this.ehlers.addCandle(candle);
    
    const analysis = this.ehlers.getMarketAnalysis();
    if (!analysis || !analysis.signal) return;

    const { signal } = analysis;
    
    console.log(`Analysis at ${new Date(candle.timestamp).toISOString()}:`);
    console.log(`Direction: ${signal.direction}`);
    console.log(`Strength: ${signal.strength.toFixed(2)}`);
    console.log(`Confidence: ${signal.confidence.toFixed(2)}`);
    console.log(`RSI: ${analysis.rsi.toFixed(2)}`);
    console.log(`MAMA: ${analysis.mama.toFixed(4)}`);
    console.log(`FAMA: ${analysis.fama.toFixed(4)}`);

    // Trading logic
    if (signal.entry && signal.confidence > 60) {
      if (signal.direction === 'bullish' && !this.position) {
        this.position = 'long';
        this.entryPrice = candle.close;
        console.log(`🟢 LONG Entry at ${candle.close}`);
      } else if (signal.direction === 'bearish' && !this.position) {
        this.position = 'short';
        this.entryPrice = candle.close;
        console.log(`🔴 SHORT Entry at ${candle.close}`);
      }
    }

    if (signal.exit && this.position) {
      const pnl = this.position === 'long' ? 
        candle.close - this.entryPrice : 
        this.entryPrice - candle.close;
      
      console.log(`🔄 Position closed. P&L: ${pnl.toFixed(2)}`);
      this.position = null;
      this.entryPrice = 0;
    }

    console.log('---');
  }
}

// Export for use
export { EhlersPredictiveSystem, TradingBot, Candle, TrendSignal };